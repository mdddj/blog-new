#!/usr/bin/env python3
"""
MySQL to PostgreSQL data migration script
Reads from test.sql (Navicat export) and generates postgres_import_ready.sql
"""

import re

with open('test.sql', 'r', encoding='utf-8') as f:
    content = f.read()

output_lines = []

# Disable foreign key checks at the start
output_lines.append("-- MySQL to PostgreSQL data migration")
output_lines.append("-- Generated by import_data.py")
output_lines.append("")
output_lines.append("SET session_replication_role = 'replica';")
output_lines.append("")

def escape_postgres(s):
    """Escape string for PostgreSQL"""
    if s is None:
        return 'NULL'
    # First unescape MySQL escapes, then escape for PostgreSQL
    s = s.replace("\\'", "'")  # MySQL escaped quotes
    s = s.replace("\\n", "\n")  # newlines
    return s.replace("'", "''")  # PostgreSQL escape

def parse_mysql_values(values_str):
    """Parse MySQL VALUES string into a list of values"""
    values = []
    current = ""
    in_quote = False
    i = 0
    
    while i < len(values_str):
        char = values_str[i]
        
        # Handle escape sequences
        if char == '\\' and i + 1 < len(values_str):
            current += char + values_str[i + 1]
            i += 2
            continue
            
        if char == "'" and not (i > 0 and values_str[i-1] == '\\'):
            in_quote = not in_quote
            current += char
        elif char == ',' and not in_quote:
            values.append(current.strip())
            current = ""
        else:
            current += char
        i += 1
    
    if current.strip():
        values.append(current.strip())
    
    return values

def strip_quotes(s):
    """Remove surrounding quotes from a string"""
    if s == 'NULL':
        return None
    if s.startswith("'") and s.endswith("'"):
        return s[1:-1]
    return s

# Process categories with a more robust pattern
# MySQL: (id, create_time, intro, logo, name)
# PostgreSQL: (id, name, intro, logo)
output_lines.append("-- Categories")

# Find category section
category_section = re.search(r"-- Records of category.*?BEGIN;(.*?)COMMIT;", content, re.DOTALL)
if category_section:
    cat_content = category_section.group(1)
    # Match each INSERT statement
    cat_pattern = r"INSERT INTO `category` \(`id`, `create_time`, `intro`, `logo`, `name`\) VALUES \((.+?)\);"
    for match in re.finditer(cat_pattern, cat_content, re.DOTALL):
        values_str = match.group(1)
        values = parse_mysql_values(values_str)
        if len(values) >= 5:
            id_val = values[0]
            # create_time = values[1] - skip
            intro = strip_quotes(values[2]) or ''
            logo = strip_quotes(values[3]) or ''
            name = strip_quotes(values[4]) or ''
            
            intro_escaped = escape_postgres(intro)
            logo_escaped = escape_postgres(logo)
            name_escaped = escape_postgres(name)
            
            output_lines.append(f"INSERT INTO categories (id, name, intro, logo) VALUES ({id_val}, '{name_escaped}', '{intro_escaped}', '{logo_escaped}');")

output_lines.append("")

# Process tags
# MySQL: (id, name) -> PostgreSQL: (id, name)
output_lines.append("-- Tags")
tag_pattern = r"INSERT INTO `tag` \(`id`, `name`\) VALUES \((\d+), '([^']*)'\);"
for match in re.finditer(tag_pattern, content):
    id_val = match.group(1)
    name = escape_postgres(match.group(2))
    output_lines.append(f"INSERT INTO tags (id, name) VALUES ({id_val}, '{name}');")

output_lines.append("")

# Process blogs - more robust parsing
# MySQL: (id, alias_string, author, content, create_time, date_string, html, thumbnail, title, category_id, view_count)
# PostgreSQL: (id, title, slug, author, content, html, thumbnail, category_id, view_count, is_published, created_at)
output_lines.append("-- Blogs")

# Find all blog INSERT statements using a different approach
blog_pattern = r"INSERT INTO `blog` \(`id`, `alias_string`, `author`, `content`, `create_time`, `date_string`, `html`, `thumbnail`, `title`, `category_id`, `view_count`\) VALUES \((.+?)\);\s*(?=INSERT INTO `blog`|COMMIT)"

for match in re.finditer(blog_pattern, content, re.DOTALL):
    values_str = match.group(1)
    values = parse_mysql_values(values_str)
    
    if len(values) >= 11:
        try:
            id_val = values[0]
            alias_string = strip_quotes(values[1]) or ''
            author = strip_quotes(values[2]) or ''
            content_val = strip_quotes(values[3]) or ''
            create_time = strip_quotes(values[4]) or ''
            # date_string = values[5] - skip
            html = strip_quotes(values[6]) or ''
            thumbnail_raw = values[7]
            title = strip_quotes(values[8]) or ''
            category_id = values[9] if values[9] != 'NULL' else 'NULL'
            view_count = values[10] if values[10] != 'NULL' else '0'
            
            # Generate slug
            slug = alias_string if alias_string else f"blog-{id_val}"
            
            # Escape for PostgreSQL
            title_escaped = escape_postgres(title)
            author_escaped = escape_postgres(author)
            content_escaped = escape_postgres(content_val)
            html_escaped = escape_postgres(html)
            slug_escaped = escape_postgres(slug)
            
            # Handle thumbnail
            if thumbnail_raw == 'NULL':
                thumbnail_sql = 'NULL'
            else:
                thumb_val = strip_quotes(thumbnail_raw)
                if thumb_val is None or thumb_val == '':
                    thumbnail_sql = 'NULL'
                else:
                    thumbnail_sql = f"'{escape_postgres(thumb_val)}'"
            
            output_lines.append(f"INSERT INTO blogs (id, title, slug, author, content, html, thumbnail, category_id, view_count, is_published, created_at) VALUES ({id_val}, '{title_escaped}', '{slug_escaped}', '{author_escaped}', '{content_escaped}', '{html_escaped}', {thumbnail_sql}, {category_id}, {view_count}, true, '{create_time}');")
        except Exception as e:
            print(f"Error parsing blog {values[0] if values else 'unknown'}: {e}")

output_lines.append("")

# Process blog_tags
# MySQL: (blog_id, tag_id) -> PostgreSQL: (blog_id, tag_id)
output_lines.append("-- Blog Tags")
blog_tags_pattern = r"INSERT INTO `blog_tags` \(`blog_id`, `tag_id`\) VALUES \((\d+), (\d+)\);"
for match in re.finditer(blog_tags_pattern, content):
    blog_id = match.group(1)
    tag_id = match.group(2)
    output_lines.append(f"INSERT INTO blog_tags (blog_id, tag_id) VALUES ({blog_id}, {tag_id});")

output_lines.append("")

# Process directories
# MySQL: (id, create_date, introduce, name, parent_id)
# PostgreSQL: (id, name, intro, parent_id, created_at)
output_lines.append("-- Directories")
# First insert directories with NULL parent_id, then others
dir_pattern = r"INSERT INTO `directory` \(`id`, `create_date`, `introduce`, `name`, `parent_id`\) VALUES \((\d+), '([^']*)', (NULL|'[^']*'), '([^']*)', (NULL|\d+)\);"
dir_entries = []
for match in re.finditer(dir_pattern, content):
    id_val = match.group(1)
    create_date = match.group(2)
    intro_raw = match.group(3)
    name = escape_postgres(match.group(4))
    parent_id = match.group(5)
    
    if intro_raw == 'NULL':
        intro_sql = 'NULL'
    else:
        intro_sql = f"'{escape_postgres(intro_raw.strip(chr(39)))}'"
    
    parent_sql = parent_id if parent_id != 'NULL' else 'NULL'
    dir_entries.append((id_val, name, intro_sql, parent_sql, create_date, parent_id == 'NULL'))

# Sort: NULL parent_id first
dir_entries.sort(key=lambda x: (not x[5], int(x[0])))
for entry in dir_entries:
    id_val, name, intro_sql, parent_sql, create_date, _ = entry
    output_lines.append(f"INSERT INTO directories (id, name, intro, parent_id, created_at) VALUES ({id_val}, '{name}', {intro_sql}, {parent_sql}, '{create_date}');")

output_lines.append("")

# Process projects
# MySQL: (id, description, download_url, github, logo, name, preview_url)
# PostgreSQL: (id, name, description, logo, github_url, preview_url, download_url)
output_lines.append("-- Projects")
project_pattern = r"INSERT INTO `project` \(`id`, `description`, `download_url`, `github`, `logo`, `name`, `preview_url`\) VALUES \((\d+), '([^']*)', '([^']*)', '([^']*)', '([^']*)', '([^']*)', '([^']*)'\);"
for match in re.finditer(project_pattern, content):
    id_val = match.group(1)
    description = escape_postgres(match.group(2))
    download_url = escape_postgres(match.group(3))
    github = escape_postgres(match.group(4))
    logo = escape_postgres(match.group(5))
    name = escape_postgres(match.group(6))
    preview_url = escape_postgres(match.group(7))
    
    # Handle empty strings as NULL for URLs
    github_sql = f"'{github}'" if github else 'NULL'
    preview_sql = f"'{preview_url}'" if preview_url else 'NULL'
    download_sql = f"'{download_url}'" if download_url else 'NULL'
    logo_sql = f"'{logo}'" if logo else 'NULL'
    desc_sql = f"'{description}'" if description else 'NULL'
    
    output_lines.append(f"INSERT INTO projects (id, name, description, logo, github_url, preview_url, download_url) VALUES ({id_val}, '{name}', {desc_sql}, {logo_sql}, {github_sql}, {preview_sql}, {download_sql});")

output_lines.append("")

# Process friend_links
# MySQL: (id, create_date, email, intro, logo, name, state, url)
# PostgreSQL: (id, name, url, logo, intro, email, status, created_at)
output_lines.append("-- Friend Links")
friend_pattern = r"INSERT INTO `friend_link` \(`id`, `create_date`, `email`, `intro`, `logo`, `name`, `state`, `url`\) VALUES \((\d+), '([^']*)', '([^']*)', '([^']*)', '([^']*)', '([^']*)', (\d+), '([^']*)'\);"
for match in re.finditer(friend_pattern, content):
    id_val = match.group(1)
    create_date = match.group(2)
    email = escape_postgres(match.group(3))
    intro = escape_postgres(match.group(4))
    logo = escape_postgres(match.group(5))
    name = escape_postgres(match.group(6))
    state = match.group(7)
    url = escape_postgres(match.group(8))
    
    email_sql = f"'{email}'" if email else 'NULL'
    intro_sql = f"'{intro}'" if intro else 'NULL'
    logo_sql = f"'{logo}'" if logo else 'NULL'
    
    output_lines.append(f"INSERT INTO friend_links (id, name, url, logo, intro, email, status, created_at) VALUES ({id_val}, '{name}', '{url}', {logo_sql}, {intro_sql}, {email_sql}, {state}, '{create_date}');")

output_lines.append("")

# Process texts
# MySQL: (id, context, intro, is_encryption_text, name, origin_password, view_password, create_date, update_date)
# PostgreSQL: (id, name, intro, content, is_encrypted, view_password, created_at, updated_at)
output_lines.append("-- Texts")

# Find text section
text_section = re.search(r"-- Records of text.*?BEGIN;(.*?)COMMIT;", content, re.DOTALL)
if text_section:
    text_content = text_section.group(1)
    # Match each INSERT statement
    text_pattern = r"INSERT INTO `text` \(`id`, `context`, `intro`, `is_encryption_text`, `name`, `origin_password`, `view_password`, `create_date`, `update_date`\) VALUES \((.+?)\);"
    for match in re.finditer(text_pattern, text_content, re.DOTALL):
        values_str = match.group(1)
        values = parse_mysql_values(values_str)
        if len(values) >= 9:
            try:
                id_val = values[0]
                context = strip_quotes(values[1]) or ''
                intro_raw = values[2]
                is_encryption = values[3]
                name = strip_quotes(values[4]) or ''
                # origin_password = values[5] - skip
                view_password_raw = values[6]
                create_date_raw = values[7]
                update_date_raw = values[8]
                
                # Escape for PostgreSQL
                name_escaped = escape_postgres(name)
                content_escaped = escape_postgres(context)
                
                # Handle intro
                if intro_raw == 'NULL':
                    intro_sql = 'NULL'
                else:
                    intro_sql = f"'{escape_postgres(strip_quotes(intro_raw) or '')}'"
                
                # Handle is_encrypted
                is_encrypted = 'true' if is_encryption != 'NULL' else 'false'
                
                # Handle view_password
                if view_password_raw == 'NULL':
                    view_password_sql = 'NULL'
                else:
                    pwd = strip_quotes(view_password_raw)
                    view_password_sql = f"'{escape_postgres(pwd)}'" if pwd else 'NULL'
                
                # Handle dates
                if create_date_raw == 'NULL':
                    created_at_sql = 'now()'
                else:
                    created_at_sql = f"'{strip_quotes(create_date_raw)}'"
                
                if update_date_raw == 'NULL':
                    updated_at_sql = 'now()'
                else:
                    updated_at_sql = f"'{strip_quotes(update_date_raw)}'"
                
                output_lines.append(f"INSERT INTO texts (id, name, intro, content, is_encrypted, view_password, created_at, updated_at) VALUES ({id_val}, '{name_escaped}', {intro_sql}, '{content_escaped}', {is_encrypted}, {view_password_sql}, {created_at_sql}, {updated_at_sql});")
            except Exception as e:
                print(f"Error parsing text {values[0] if values else 'unknown'}: {e}")

output_lines.append("")

# Process documents (markdown_file in MySQL)
# MySQL: (id, content, create_date, filename, name, directory_id)
# PostgreSQL: (id, name, filename, content, directory_id, created_at)
output_lines.append("-- Documents")

# Find markdown_file section
doc_section = re.search(r"-- Records of markdown_file.*?BEGIN;(.*?)COMMIT;", content, re.DOTALL)
if doc_section:
    doc_content = doc_section.group(1)
    # Match each INSERT statement - use lookahead to find the end
    doc_pattern = r"INSERT INTO `markdown_file` \(`id`, `content`, `create_date`, `filename`, `name`, `directory_id`\) VALUES \((.+?)\);\s*(?=INSERT INTO|$)"
    for match in re.finditer(doc_pattern, doc_content, re.DOTALL):
        values_str = match.group(1)
        values = parse_mysql_values(values_str)
        if len(values) >= 6:
            try:
                id_val = values[0]
                content_val = strip_quotes(values[1]) or ''
                create_date = strip_quotes(values[2]) or ''
                filename = strip_quotes(values[3]) or ''
                name = strip_quotes(values[4]) or ''
                directory_id = values[5] if values[5] != 'NULL' else 'NULL'
                
                # Escape for PostgreSQL
                name_escaped = escape_postgres(name)
                filename_escaped = escape_postgres(filename)
                content_escaped = escape_postgres(content_val)
                
                output_lines.append(f"INSERT INTO documents (id, name, filename, content, directory_id, created_at) VALUES ({id_val}, '{name_escaped}', '{filename_escaped}', '{content_escaped}', {directory_id}, '{create_date}');")
            except Exception as e:
                print(f"Error parsing document {values[0] if values else 'unknown'}: {e}")

output_lines.append("")

# Re-enable foreign key checks
output_lines.append("SET session_replication_role = 'origin';")
output_lines.append("")

# Update sequences
output_lines.append("-- Update sequences")
output_lines.append("SELECT setval('categories_id_seq', (SELECT COALESCE(MAX(id), 1) FROM categories));")
output_lines.append("SELECT setval('tags_id_seq', (SELECT COALESCE(MAX(id), 1) FROM tags));")
output_lines.append("SELECT setval('blogs_id_seq', (SELECT COALESCE(MAX(id), 1) FROM blogs));")
output_lines.append("SELECT setval('directories_id_seq', (SELECT COALESCE(MAX(id), 1) FROM directories));")
output_lines.append("SELECT setval('projects_id_seq', (SELECT COALESCE(MAX(id), 1) FROM projects));")
output_lines.append("SELECT setval('friend_links_id_seq', (SELECT COALESCE(MAX(id), 1) FROM friend_links));")
output_lines.append("SELECT setval('texts_id_seq', (SELECT COALESCE(MAX(id), 1) FROM texts));")
output_lines.append("SELECT setval('documents_id_seq', (SELECT COALESCE(MAX(id), 1) FROM documents));")

with open('postgres_import_ready.sql', 'w', encoding='utf-8') as f:
    f.write('\n'.join(output_lines))

# Count results
category_count = len([l for l in output_lines if l.startswith('INSERT INTO categories')])
tag_count = len([l for l in output_lines if l.startswith('INSERT INTO tags')])
blog_count = len([l for l in output_lines if l.startswith('INSERT INTO blogs')])
blog_tags_count = len([l for l in output_lines if l.startswith('INSERT INTO blog_tags')])
dir_count = len([l for l in output_lines if l.startswith('INSERT INTO directories')])
project_count = len([l for l in output_lines if l.startswith('INSERT INTO projects')])
friend_count = len([l for l in output_lines if l.startswith('INSERT INTO friend_links')])
text_count = len([l for l in output_lines if l.startswith('INSERT INTO texts')])

print(f"Generated postgres_import_ready.sql:")
print(f"  - Categories: {category_count}")
print(f"  - Tags: {tag_count}")
print(f"  - Blogs: {blog_count}")
print(f"  - Blog Tags: {blog_tags_count}")
print(f"  - Directories: {dir_count}")
print(f"  - Projects: {project_count}")
print(f"  - Friend Links: {friend_count}")
print(f"  - Texts: {text_count}")
doc_count = len([l for l in output_lines if l.startswith('INSERT INTO documents')])
print(f"  - Documents: {doc_count}")
print(f"  - Total lines: {len(output_lines)}")
