-- MySQL to PostgreSQL data migration
-- Generated by import_data.py

SET session_replication_role = 'replica';

-- Categories
INSERT INTO categories (id, name, intro, logo) VALUES (1, 'Flutter', 'Flutter是一个由谷歌开发的开源移动应用软件开发工具包，用于为Android、iOS、Windows、Mac、Linux、Google Fuchsia开发应用。 Flutter第一个版本支持Android操作系统，开发代号称作“Sky”', 'https://static.saintic.com/picbed/huang/2020/11/20/1605864943587.png');
INSERT INTO categories (id, name, intro, logo) VALUES (2, 'Java', 'Java是一种广泛使用的计算机编程语言，拥有跨平台、面向对象、泛型编程的特性，广泛应用于企业级Web应用开发和移动应用开发。', 'https://static.saintic.com/picbed/huang/2021/01/16/1610773404956.png');
INSERT INTO categories (id, name, intro, logo) VALUES (3, 'Kotlin', 'Kotlin是一种在Java虚拟机上运行的静态类型编程语言，它也可以被编译成为JavaScript源代码。它主要是由俄罗斯圣彼得堡的JetBrains开发团队所发展出来的编程语言，其名称来自于圣彼得堡附近的科特林岛。[3]2012年1月，著名期刊《Dr. Dobb''s Journal》中Kotlin被认定为该月的最佳语言。[4]虽然与Java语法并不兼容，但在JVM环境中Kotlin被设计成可以和Java代码相互运作，并可以重复使用如Java集合框架等的现有Java引用的函数库。Hathibelagal写道，“如果你正在为Android开发寻找一种替代编程语言，那么应该试下Kotlin。它很容易在Android项目中替代Java或者同Java一起使用。”', 'https://static.saintic.com/picbed/huang/2021/06/10/1623288096050.png');
INSERT INTO categories (id, name, intro, logo) VALUES (52, 'C++', '很棒的编程语言', 'https://minio.itbug.shop/blog/simple-file/c%252B%252B___1727680380156___.png');
INSERT INTO categories (id, name, intro, logo) VALUES (102, 'Rust', '牛逼的编程语言', 'https://minio.itbug.shop/blog/admin/Rust_programming_language_black_logo.svg___1705888960139___.png');
INSERT INTO categories (id, name, intro, logo) VALUES (103, 'Android', '移动开发平台', 'https://minio.itbug.shop/blog/admin/android___1705990710118___.png');
INSERT INTO categories (id, name, intro, logo) VALUES (104, 'Docker', '容器', 'https://minio.itbug.shop/blog/admin/docker___1706081053280___.png');
INSERT INTO categories (id, name, intro, logo) VALUES (152, '其他杂项', '其他杂项', 'https://minio.itbug.shop/blog/admin/jb___1712730724012___.png');
INSERT INTO categories (id, name, intro, logo) VALUES (202, '虚幻5', '强大的游戏框架', 'https://minio.itbug.shop/blog/simple-file/images___1727512608414___.png');

-- Tags
INSERT INTO tags (id, name) VALUES (1, 'compose');
INSERT INTO tags (id, name) VALUES (2, 'android');
INSERT INTO tags (id, name) VALUES (3, '路由');
INSERT INTO tags (id, name) VALUES (4, 'flutter');
INSERT INTO tags (id, name) VALUES (5, '图片');
INSERT INTO tags (id, name) VALUES (6, 'kotlin');
INSERT INTO tags (id, name) VALUES (7, '语法');
INSERT INTO tags (id, name) VALUES (52, 'c++函数');
INSERT INTO tags (id, name) VALUES (102, 'rust异步');
INSERT INTO tags (id, name) VALUES (152, 'gradle');
INSERT INTO tags (id, name) VALUES (202, 'rust');
INSERT INTO tags (id, name) VALUES (203, 'flutter_rust_bridge');
INSERT INTO tags (id, name) VALUES (252, 'C++');
INSERT INTO tags (id, name) VALUES (302, '学习');
INSERT INTO tags (id, name) VALUES (352, 'rust打包');
INSERT INTO tags (id, name) VALUES (353, 'docker');
INSERT INTO tags (id, name) VALUES (354, '基础学习');
INSERT INTO tags (id, name) VALUES (355, 'Github');
INSERT INTO tags (id, name) VALUES (402, 'IDEA插件开发');
INSERT INTO tags (id, name) VALUES (452, 'sea-orm-cli');
INSERT INTO tags (id, name) VALUES (453, '数据库');
INSERT INTO tags (id, name) VALUES (552, 'salvo');
INSERT INTO tags (id, name) VALUES (602, 'u++');
INSERT INTO tags (id, name) VALUES (603, '游戏引擎');
INSERT INTO tags (id, name) VALUES (652, 'swift');
INSERT INTO tags (id, name) VALUES (702, '建模');
INSERT INTO tags (id, name) VALUES (703, 'AI');

-- Blogs
INSERT INTO blogs (id, title, slug, author, content, html, thumbnail, category_id, view_count, is_published, created_at) VALUES (1, 'compose 桌面开发入门之输入框使用', 'test1', '梁典典', '```kotlin

import androidx.compose.desktop.Window
import androidx.compose.foundation.layout.Column
import androidx.compose.material.MaterialTheme
import androidx.compose.material.Text
import androidx.compose.material.TextField
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.ui.Modifier
import androidx.compose.ui.input.key.ExperimentalKeyInput
import androidx.compose.ui.input.key.Key
import androidx.compose.ui.input.key.plus
import androidx.compose.ui.input.key.shortcuts

@ExperimentalKeyInput
fun main() = Window {


    MaterialTheme {
        val text = remember { mutableStateOf(\"\") }

        Column {
            Text(\"请输入你的姓名\")


            TextField(
                value = text.value,
                onValueChange = {
                    text.value = it
                },
                modifier = Modifier.shortcuts {

                    on(Key.CtrlLeft + Key.Enter) {
                        print(\"输入了\")
                    }

                }
            )

        }
    }


}
```

# 输入汉字是可能会遇到这个报错
```
Exception in thread \"AWT-EventQueue-0\" java.lang.NullPointerException: event.text must not be null
```
# 解决办法
修改`build.gradle.kts` 文件, version 换成 `0.3.0-build133`
```
plugins {
    kotlin(\"jvm\") version \"1.4.20\"
    id(\"org.jetbrains.compose\") version \"0.3.0-build133\"
}
```', '', NULL, 1, 0, true, '2023-12-15 14:22:33.541000');
INSERT INTO blogs (id, title, slug, author, content, html, thumbnail, category_id, view_count, is_published, created_at) VALUES (2, 'compose 桌面开发入门之图片资源使用', 'blog-2', '梁典典', '```kotlin
import androidx.compose.desktop.Window
import androidx.compose.foundation.Image
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.size
import androidx.compose.material.Text
import androidx.compose.runtime.remember
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.ImageBitmap
import androidx.compose.ui.graphics.asImageBitmap
import androidx.compose.ui.res.imageResource
import androidx.compose.ui.unit.IntSize
import androidx.compose.ui.unit.dp
import java.awt.image.BufferedImage
import java.io.File
import javax.imageio.ImageIO

// 使用图像资源
fun main() = Window(size = IntSize(1000, 800), title = \"梁典典\", icon = getWindowIcon()) {


    val image = remember { imageFormFile(File(\"D://logo.png\")) }



    ///  horizontalAlignment = Alignment.CenterHorizontally 横向居中子元素
    Column(modifier = Modifier.fillMaxSize(), Arrangement.spacedBy(20.dp), horizontalAlignment = Alignment.CenterHorizontally) {

        /// 使用本地图片
        Text(\"使用资源图片\")
        Image(
            bitmap = imageResource(\"images/img.png\"),
            modifier = Modifier.size(200.dp, 200.dp)
        )


        Text(\"使用存储设备图片\")
        Image(
            bitmap = image
        )
    }

    /// 从存储设备中加载图片,电脑文件系统


}

/// 从资源管理器加载图片
fun imageFormFile(file: File): ImageBitmap {
    return org.jetbrains.skija.Image.makeFromEncoded(file.readBytes()).asImageBitmap()
}

/// 设置应用图标
fun getWindowIcon(): BufferedImage {
    var image: BufferedImage? = null
    try {
        image = ImageIO.read(File(\"D://logo.png\"))
    } catch (e: Exception) {
        print(\"图片不存在\")
    }
    if (image == null) {
        image = BufferedImage(1, 1, BufferedImage.TYPE_INT_RGB)
    }

    return image
}
```

# 效果
![image.png](https://upload-images.jianshu.io/upload_images/3671684-dc07373677b104f6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
', '', NULL, 2, 0, true, '2023-12-15 14:22:33.761000');
INSERT INTO blogs (id, title, slug, author, content, html, thumbnail, category_id, view_count, is_published, created_at) VALUES (3, 'Flutter 另一种方法实现 RouteAware 页面跳转生命周期', 'blog-3', '梁典典', '咳咳,先定义一个类集成`RouteObserver<PageRoute<dynamic>>`
```dart
import ''package:flutter/material.dart'';
import ''../h_utils/util/page_change_util.dart'';
import ''../event/route_event.dart'';

class MyRouteObserver extends RouteObserver<PageRoute<dynamic>> {
  void _sendScreenView(PageRoute<dynamic> route, ActionType type) {
    var screenName = route.settings.name;
    var isCurrent = route.isCurrent;
    PageChangeUtil()
        .pushRouteDetail(RouteEvent(screenName ?? '''', type, route, isCurrent));
  }

  @override
  void didPush(Route<dynamic> route, Route<dynamic> previousRoute) {
    super.didPush(route, previousRoute);
    if (route is PageRoute) {
      _sendScreenView(route, ActionType.DID_PUSH);
    }
  }

  @override
  void didReplace({Route<dynamic> newRoute, Route<dynamic> oldRoute}) {
    super.didReplace(newRoute: newRoute, oldRoute: oldRoute);
    if (newRoute is PageRoute) {
      _sendScreenView(newRoute, ActionType.DID_REPLACE);
    }
  }

  @override
  void didPop(Route<dynamic> route, Route<dynamic> previousRoute) {
    super.didPop(route, previousRoute);
    if (previousRoute is PageRoute && route is PageRoute) {
      _sendScreenView(previousRoute, ActionType.DID_POP);
    }
  }

  @override
  void didRemove(Route route, Route previousRoute) {
    super.didRemove(route, previousRoute);
    if(previousRoute is PageRoute && route is PageRoute){
      _sendScreenView(previousRoute, ActionType.DID_REMOVE);
    }
  }
}

```

把这个类加入到`MaterialApp`属性`navigatorObservers` 中
```dart
  navigatorObservers: [
    MyRouteObserver(),
    ...
  ]
```
model
 ```dart
import ''package:flutter/cupertino.dart'';

class RouteEvent {
  PageRoute<dynamic> route;
  String pageNmae;
  ActionType type;
  bool isCurrent;
  RouteEvent(this.pageNmae, this.type, this.route,this.isCurrent);
}

enum ActionType { DID_PUSH, DID_REPLACE, DID_POP, DID_REMOVE }

```

然后复制我的工具类
```dart
import ''dart:async'';

class PageChangeUtil {
  PageChangeUtil._internal() {
    init();
  }

  factory PageChangeUtil() => _instance;

  static final PageChangeUtil _instance = PageChangeUtil._internal();


  StreamController _controller;
  Stream _stream;

  static PageChangeUtil get instance => _instance;
  Stream get changeStream => _stream;
  StreamController get ctrl => _controller;

  void disposeStream() => _controller.close();

  void init() {
    _controller ??= StreamController.broadcast();
    _stream ??= _controller.stream;
    if(_controller.isClosed){
      _controller = null;
      _stream = null;
      init();
    }
  }

  void pushRouteDetail(dynamic data){
    init();
    _controller.sink.add(data);
  }
}

```
至此准备工作完成,使用也很简单
```dart
  @override
  void initState() {
    _listenPageChange();
    super.initState();
  }

 // 监听页面改变事件
  void _listenPageChange() {
    PageChangeUtil.instance.changeStream.listen((event) {

      switch(event.type){
        case ActionType.DID_REMOVE:
          break;
        case ActionType.DID_POP:
          print(''页面返回'');
          break;
        case ActionType.DID_PUSH:
          print(''跳转到下一页'');
          break;
        case ActionType.DID_REPLACE:
          break;
        default:
          break;
      }
    });
  }

  @override
  void dispose() {
    PageChangeUtil.instance.disposeStream();
    super.dispose();
  }
```', '', NULL, 1, 0, true, '2023-12-15 14:22:33.988000');
INSERT INTO blogs (id, title, slug, author, content, html, thumbnail, category_id, view_count, is_published, created_at) VALUES (4, 'Android Kotlin 加载一张网络图片', 'blog-4', '梁典典', 'flutter自学交流群1102781545，欢迎提问

在`build.gradle(Module:app)`文件下引入插件

```
implementation ''com.github.bumptech.glide:glide:4.8.0''
annotationProcessor ''com.github.bumptech.glide:compiler:4.8.0''
```
使用
```
    fun loadNetImage(src : String){
        Glide.with(this).load(src).into(imageView2);
    }
```
xml布局
```
           <ImageView
              android:id=\"@+id/imageView2\"
              android:layout_width=\"150dp\"
              android:layout_height=\"150dp\"
              android:layout_gravity=\"center\"
              android:layout_marginBottom=\"30dp\"
              android:scaleType=\"fitStart\"
              tools:srcCompat=\"@tools:sample/avatars\"
           />
```', '', NULL, 3, 0, true, '2023-12-15 14:22:34.187000');
INSERT INTO blogs (id, title, slug, author, content, html, thumbnail, category_id, view_count, is_published, created_at) VALUES (5, '学习kotlin过程中解决无法使用sp.edit{}语法糖问题', 'blog-5', '梁典典', '这里1.6 换成1.8的才能用

然后`build.gradle`添加依赖
```
implementation ''androidx.core:core-ktx:1.3.2''
```

咳咳如果还报错,这个也加上
 ```
   kotlinOptions { jvmTarget = 1.8}
```

ok', '', NULL, 3, 0, true, '2023-12-15 14:22:34.379000');
INSERT INTO blogs (id, title, slug, author, content, html, thumbnail, category_id, view_count, is_published, created_at) VALUES (52, 'C++中使用virtual虚函数', 'blog-52', '梁典典', '
```c
#include <iostream>


class Entity {
public:
    virtual std::string getName() { return \"hello\"; }
};

class MyPerson : public Entity {
public:
    std::string getName() override {
        return \"ldd\";
    }
};

int main() {
    Entity entity;
    MyPerson person;
    const auto basic_string = entity.getName();
    const auto name = person.getName();
    Entity *person2 = &person;
    std::cout << basic_string << std::endl;
    std::cout << name << std::endl;
    std::cout << person2->getName() << std::endl;
    return 0;
}
```
输出
![image.png](https://minio.itbug.shop/blog/simple-file/image___1705111877443___.png)

还有一种纯虚函数,可以理解为Java中的接口
它的表现形式在末尾添加`=0;`

```c
//Entity不能直接使用,因为有纯虚函数
class Entity {
public:
    virtual std::string getName() { return \"hello\"; }


    virtual void printName() = 0;//它的派生类必须实现这个方法
};
```
不能直接使用,会报错
![image.png](https://minio.itbug.shop/blog/simple-file/image___1705199839843___.png)', '', NULL, 52, 0, true, '2024-01-13 10:13:39.211000');
INSERT INTO blogs (id, title, slug, author, content, html, thumbnail, category_id, view_count, is_published, created_at) VALUES (102, 'Rust线程入门', 'blog-102', '梁典典', '
注意事项:

1. 主线程不会等待线程任务完成,需要使用`join`函数来实现
2. 线程中不能借用主线程中的值,需要使用`scope`范围线程来实现

```rs
use std::thread;
use std::thread::scope;
use std::time::Duration;

fn main() {
   let handle = thread::spawn(|| {
        for i in 1..10 {
            println!(\"线程中执行: {i}!\");
            thread::sleep(Duration::from_millis(5));
        }
    });

    for i in 1..5 {
        println!(\"主线程中执行: {i}\");
        thread::sleep(Duration::from_millis(5));
    }
    handle.join().unwrap(); //等待线程中执行完毕,默认是不会等待线程中任务完成的,会在打印10之前就结束主线程



    //foo();
    foo2();
}

//要注释,否则编译不通过
fn foo(){
    let s = String::from(\"Hello\");
    thread::spawn(|| {
       println!(\"Length:{}\",s.len()); //这里会报错,不能在线程中借用主线程环境中的值,下面可以使用范围线程来实现这个目的
    });
}


//范围线程来解决上面的问题
fn foo2(){
    let s=  String::from(\"Hello\");
    thread::scope(|scope| {
        scope.spawn(||{
            println!(\"Length: {}\",s.len());
        });
    });
}
```
![image.png](https://minio.itbug.shop/blog/simple-file/image___1705889050811___.png)', '', NULL, 102, 0, true, '2024-01-22 10:07:04.556000');
INSERT INTO blogs (id, title, slug, author, content, html, thumbnail, category_id, view_count, is_published, created_at) VALUES (103, 'Rust中使用通道,有界通道,无界通道', 'blog-103', '梁典典', '### Rust通道
 rust通道,它有两部分组成,一个发送方,一个接收方,Sender,Receiver, 这两个部分有通道进行连接

 注意:
* Sender 实现了Clone,所以可以有多个发送方,也可以叫生产方,但是Receiver不能
* send() 和 recv 会返回Result, 如果返回Err,表示通道被关闭,或者被丢弃


### 无界通道
简单,忽略

### 有界通道
 注意:
 * 需要sync_channel(5)需要传入一个参数,可以理解为消息容量,如果在子线程中发送了满足5条数量大小的消息,但是没有被消费掉,在子线程中会阻塞
 * 如果通道关闭,发送方发送消息将返回错误
 * 如果传入sync_channel(0)传入0,被称为交会通道,意思就是你每次发送一个,就要被消费一个,来回拉扯


```rs
use std::fmt::format;
use std::sync::mpsc;
use std::thread;

/**

 rust通道,它有两部分组成,一个发送方,一个接收方,Sender,Receiver, 这两个部分有通道进行连接

 注意:
* Sender 实现了Clone,所以可以有多个发送方,也可以叫生产方,但是Receiver不能
* send() 和 recv 会返回Result, 如果返回Err,表示通道被关闭,或者被丢弃

**/

fn main_1() {
 let (tx,rx) = mpsc::channel();
 tx.send(10).unwrap();
 tx.send(20).unwrap();

 println!(\"received: {:?}\",rx.recv());
 println!(\"received:{:?}\",rx.recv());


 let tx2 = tx.clone();
 tx2.send(30).unwrap();
 println!(\"received:{:?}\",rx.recv())
}



/// 在线程中使用无界通道
fn main2(){
 let (tx,rx) = mpsc::channel();
 thread::spawn(move || {
  let thread_id = thread::current().id();
  for i in 1..10 {
   tx.send(format!(\"Message {i}\")).unwrap();
   println!(\"{thread_id:?}: send message {i}\");
  }
  println!(\"{thread_id:?} : done\");
 });
 thread::sleep(std::time::Duration::from_millis(100));
 for msg in rx.iter() {
  println!(\"Main: got {msg}\");
 }
}


/**

 使用有界通道


 注意:
 * 需要sync_channel(5)需要传入一个参数,可以理解为消息容量,如果在子线程中发送了满足5条数量大小的消息,但是没有被消费掉,在子线程中会阻塞
 * 如果通道关闭,发送方发送消息将返回错误
 * 如果传入sync_channel(0)传入0,被称为交会通道,意思就是你每次发送一个,就要被消费一个,来回拉扯
**/
fn main(){
 let (tx,rx) = mpsc::sync_channel(5);
 thread::spawn(move || {
  let thread_id = thread::current().id();
  for i in 1..10 {
   tx.send(format!(\"Message: {i}\")).unwrap();
   println!(\"{thread_id:?}: send message {i}\");
  };
  println!(\"{thread_id:?} done\");
 });
 thread::sleep(std::time::Duration::from_millis(100));

 for msg in rx.iter() {
  println!(\"Main: got {msg}\");
 };
}
```', '', NULL, 102, 0, true, '2024-01-22 10:39:41.664000');
INSERT INTO blogs (id, title, slug, author, content, html, thumbnail, category_id, view_count, is_published, created_at) VALUES (104, 'Android打包so库封装成lib,上传到自建nexus仓库', 'blog-104', '梁典典', '# 1.准备so库
下载好第三方打包好的so库
在lib的根目录下创建一个`libs`目录,把so库,和一些三方jar包引入进去
![image.png](https://minio.itbug.shop/blog/simple-file/image___1705991568398___.png)

# 2.声明jinlib库

我这里用了kotlin的dsl脚本,所以需要在libary根目录下的`build.gradle.kts`文件中添加配置
```kotlin
android {
   .... 省略一些其他配置
   sourceSets {
        getByName(\"main\"){
            jniLibs.srcDir(\"libs\")
        }
    }
}
```
如果要引入第三方jar包,则添加
```kotlin
dependencies {
    implementation(files(\"libs/INetSDK.jar\"))
}

```
![image.png](https://minio.itbug.shop/blog/simple-file/image___1705991809105___.png)
后面更新一下gradle依赖库async一下就好了
```
android > gradlew -i --info
```


# 打包
在Android目录下,执行
> dd_dh_lib 换成libary名字

```
./gradlew dd_dh_lib:assembleRelease --info
```
它会在build/dd_dh_lib/outputs/arr/目录下生成一个`dd_dh_lib-release.aar`文件,
后面需要将这个aar上传到第三方的maven仓库,方便远程调用
![image.png](https://minio.itbug.shop/blog/simple-file/image___1705992662746___.png)

# 上传


> 我这里用的自建仓库

在`build.gradle.kts`添加maven-publish插件
![image.png](https://minio.itbug.shop/blog/simple-file/image___1705992732038___.png)

在最外层添加配置
```kotlin

try{
    val props = Properties()
    props.load(FileInputStream(File(\"/Users/ldd/maven.properties\")))
    val mavenUsername: String = props.getProperty(\"username\")
    val mavenPassword: String = props.getProperty(\"password\")
    afterEvaluate {
        publishing {
            repositories {
                maven {
                    name = \"sonatype\"
                    url = uri(\"http://198.23.137.134:8081/repository/maven-releases/\")
                    credentials {
                        username = mavenUsername
                        password = mavenPassword
                    }
                    isAllowInsecureProtocol = true
                }
                publications {
                    create<MavenPublication>(\"release\") {
                        groupId = \"shop.itbug\"
                        artifactId = \"dd_dh_lib\"
                        version = version
                        artifact(\"$buildDir/outputs/aar/${project.name}-release.aar\")
                        pom {
                            name.set(\"大华摄像头安卓操作模块\")
                            description.set(\"梁典典的服务接口\")
                            url.set(\"https://itbug.shop\")
                            developers {
                                developer {
                                    id.set(\"ldd\")
                                    name.set(\"梁典典\")
                                    email.set(\"hlxsmail@gmail.com\")
                                }
                            }
                            licenses {
                                license {
                                    name.set(\"The Apache License, Version 2.0\")
                                    url.set(\"http://www.apache.org/licenses/LICENSE-2.0.txt\")
                                }
                            }

                        }
                    }
                }
            }

        }
    }

}catch (e:Exception){
    println(\"error:${e.localizedMessage}\")
}

```


注意
要把第3步生成的aar包配置一下:`artifact(\"$buildDir/outputs/aar/${project.name}-release.aar\")`

执行命令![image.png](https://minio.itbug.shop/blog/simple-file/image___1705992969169___.png)
等待上传完毕就可以了

# 调用
可以在自建仓库中找到
![image.png](https://minio.itbug.shop/blog/simple-file/image___1705993060828___.png)
引用方式
![image.png](https://minio.itbug.shop/blog/simple-file/image___1705993083980___.png)

`build.gradle`添加
```kotlin
maven {
            url = \"http://198.23.137.134:8081/maven-releases\"
            allowInsecureProtocol = true
        }
```
完成', '', NULL, 103, 0, true, '2024-01-23 14:59:11.449000');
INSERT INTO blogs (id, title, slug, author, content, html, thumbnail, category_id, view_count, is_published, created_at) VALUES (105, 'Rust中的Arc和Mutex互斥锁在线程中的使用', 'blog-105', '梁典典', '```rust

use std::thread;
use std::sync::Arc;
use std::sync::Mutex;


/**

Arc 代表原子引用计数,它是使用原子操作的RC的线程安全版本
Arc::clone 在执行原子操作方面有开销,但是在此之后,T可以随意使用,而且没有任何开销


注意在循环里面使用,Arc不会使用垃圾回收器检测引用循环

**/
fn main1() {
    let v = Arc::new(vec![10,20,30]);
    let mut handles = Vec::new();
    for _ in 1..5 {
        let v= Arc::clone(&v);
        handles.push(thread::spawn(move || {
            let thread_id = thread::current().id();
            println!(\"{thread_id:?}:{v:?}\");
        }));
    }

    handles.into_iter().for_each(|h| h.join().unwrap());
    println!(\"v:{v:?}\")
}



/**


互斥器

rust中的互斥器看起来就像是包含一个元素的集合,其中的元素就是受保护的数据

在访问受保护的数据之前,不可能忘记获取互斥量

你可以通过获取锁,从&Mutex<T>中获取&mut T ,MutexGuard 能够确保&mut T存在的时间不会比持有锁的时间更长

读写锁版本==>> RwLock

为什么lock会返回Result?

如果持有Mutex的线程发生panic ,Mutex便会中毒并发出信号,表明其所保护的数据可能处于不一致的状态
对中毒的互斥量调用lock()就会失败,并将显示PoisonError(poison:翻译过来就是毒药的意思)
无论如何,你可以对这个错误调用into_inner()来恢复数据

**/
fn main2(){

    let v = Mutex::new(vec![10,20,30]);
    println!(\"v:{:?}\",v.lock().unwrap());
    {
        let mut guard = v.lock().unwrap();
        guard.push(40);
    }
    println!(\"v:{:?}\",v.lock().unwrap());
}


// fn main3(){
//     let mut v = vec![10, 20, 30];
//     let handle = thread::spawn(||{
//         v.push(10);
//     });
//     v.push(1000);
//     handle.join().unwrap();
//     println!(\"v:{v:?}\");
// }


///解决上面main3的问题
///
///
/// 注意:把Mutex封装在Arc里面是一种在线程之间共享可变状态的常见模式
/// v:Arc<_>必须先克隆为v2,让后才能移动到另一个线程中,注意:lambda签名中添加了move

fn main(){
    let v = Arc::new(Mutex::new(vec![10,20,30]));
    let v2 = Arc::clone(&v);
    let handle = thread::spawn(move||{
        let mut v2 = v2.lock().unwrap();
        v2.push(10);
    });
    {
        let mut v = v.lock().unwrap();
        v.push(1000);
    }
    handle.join().unwrap();
    println!(\"v:{v:?}\");
}
```', '', NULL, 102, 0, true, '2024-01-24 14:39:50.883000');
INSERT INTO blogs (id, title, slug, author, content, html, thumbnail, category_id, view_count, is_published, created_at) VALUES (106, '解决Idea连接不上服务器中的Docker', 'blog-106', '梁典典', '在服务器中执行

```ssh
sudo chmod a+rwx /var/run/docker.sock
sudo chmod a+rwx /var/run/docker.pid
```
参考[JB论坛帖子](https://intellij-support.jetbrains.com/hc/en-us/community/posts/360010126039-Cannot-connect-to-the-Docker-daemon-at-unix-var-run-docker-sock-Is-the-docker-daemon-running-)
', '', NULL, 104, 0, true, '2024-01-24 15:26:10.886000');
INSERT INTO blogs (id, title, slug, author, content, html, thumbnail, category_id, view_count, is_published, created_at) VALUES (152, '在Rust中使用异步futures', 'blog-152', '梁典典', '异步不是rust自带的标准库,所以要先添加依赖,后面要用异步控制流,把tokio也加上去
Cargo.toml
```toml
futures = \"0.3.30\"
tokio = { version = \"1.35.1\", features = [\"full\"] }
reqwest = \"0.11.23\"
anyhow = \"1.0.79\"
```

# 1.异步基础

基础语法,fn函数前面添加`async`,等待异步函数执行完毕,在函数末尾添加`.await`
```rust
use tokio::time;
async fn count_to(count: i32) {
    for i in 1..count {
        println!(\"count is : {i}!\");
    }
}

async fn async_main(count: i32) {
    count_to(count).await
}

#[tokio::main]
async fn main() {
    tokio::spawn(count_tov2(10));
    for i in 1..5 {
        println!(\"main task: {i}\");
        time::sleep(time::Duration::from_millis(5)).await;
    }
}

async fn count_tov2(count: i32) {
    for i in 1..count {
        println!(\"count in task : {i}?\");
        time::sleep(time::Duration::from_millis(5)).await
    }
}

```
# 2.异步控制流
可以使用`future::join_all`来等待所有的任务完成,单个任务使用`join`
```rust
use anyhow::Result;
use futures::future;
use reqwest;
use std::collections::HashMap;
async fn size_of_page(url: &str) -> Result<usize> {
    let resp = reqwest::get(url).await?;
    Ok(resp.text().await?.len())
}

#[tokio::main]
async fn main() {
    let urls: [&str; 4] = [
        \"https://baidu.com\",
        \"https://itbug.shop\",
        \"https://play.rust-lang.org/\",
        \"ABD_URL\",
    ];
    let futures_iter = urls.into_iter().map(size_of_page);
    let results = future::join_all(futures_iter).await;
    let page_size_dict: HashMap<&str, Result<usize>> =
        urls.into_iter().zip(results.into_iter()).collect();
    println!(\"{:?}\", page_size_dict)
}

```

# 3.异步通道
可以使用`tokio::sync::mpsc`通道来实现异步任务之间的数据传输和通讯
```rust
use tokio::sync::mpsc::{self, Receiver};

async fn ping_handle(mut input: Receiver<()>) {
    let mut count: usize = 0;
    while let Some(_) = input.recv().await {
        count += 1;
        println!(\"received {count} pings so far.\");
    }
    println!(\"ping_handle complete\");
}

#[tokio::main]
async fn main() {
    let (s, r) = mpsc::channel(32);

    let ping_handle_task = tokio::spawn(ping_handle(r));
    for i in 0..10 {
        s.send(()).await.expect(\"failed to send ping\");
        println!(\"sent {} pings so far.\", i + 1);
    }

    drop(s);
    ping_handle_task
        .await
        .expect(\"something went wrong in ping\");
}

```

# 4. 异步任务
在异步任务中使用io流来对连接进行读写
```rust
use tokio::io::{self, AsyncReadExt, AsyncWriteExt};
use tokio::net::TcpListener;
#[tokio::main]
async fn main() -> io::Result<()> {
    let listener = TcpListener::bind(\"127.0.0.1:6142\").await?;
    println!(\"listening on port 6142\");
    loop {
        let (mut socket, addr) = listener.accept().await?;
        println!(\"connection form {addr:?}\");
        tokio::spawn(async move {
            if let Err(e) = socket.write_all(b\"who are you?\
\").await {
                println!(\"socket error: {e:?}\");
                return;
            }
            let mut bug = vec![0; 1024];
            let reply = match socket.read(&mut bug).await {
                Ok(n) => {
                    let name = std::str::from_utf8(&bug[..n]).unwrap().trim();
                    format!(\"thanks for dialing in,{name}!\
\")
                }
                Err(e) => {
                    println!(\"socket error :{e:?}\");
                    return;
                }
            };
            if let Err(e) = socket.write_all(reply.as_bytes()).await {
                println!(\"socket error {e:?}\");
            }
        });
    }
}

```', '', NULL, 102, 0, true, '2024-01-26 15:33:32.729000');
INSERT INTO blogs (id, title, slug, author, content, html, thumbnail, category_id, view_count, is_published, created_at) VALUES (202, 'C++使用vector,以及优化技巧', 'blog-202', '梁典典', '# 基本使用
```c++
#include <iostream>
#include <ostream>
#include <vector>
//
// Created by ldd on 2024/1/28.
//
struct Vertex {
    float x,y,z;
};
std::ostream& operator<<(std::ostream& stream,const Vertex& vertex) {
    stream << vertex.x << \", \" << vertex.y << \", \" << vertex.z;
    return stream;
}
int main() {
    std::vector<Vertex> vertices;
    vertices.push_back({1,2,3});
    vertices.push_back({4,5,6});
    for (Vertex& vertex : vertices) {
        std::cout << vertex << std::endl;
    }
    //移除下标为0的数据
    vertices.erase(vertices.begin());
    //清理所有数据
    vertices.clear();
}
```
# 优化

* 使用` vertices.reserve(3);`来初始化分配内存空间

* 使用`emplace_back()`函数来放置元素,例: `vertices.emplace_back(Vertex({1,2,3}));` ', '', NULL, 52, 0, true, '2024-01-29 09:28:11.828000');
INSERT INTO blogs (id, title, slug, author, content, html, thumbnail, category_id, view_count, is_published, created_at) VALUES (252, '解决flutter Android gradle升级到8.0+namespace编译不通过的问题', 'blog-252', '梁典典', '打开项目根目录下的`android`文件夹,找到`build.grade`文件
添加下面的代码
```gradle
subprojects {
    afterEvaluate { project ->
        if (project.hasProperty(''android'')) {
            project.android {
                if (namespace == null) {
                    namespace project.group
                }
            }
        }
    }
}
```
重新build,问题解决.

如果后面遇到jvm target版本编译不一致的问题,则添加
```gradle
subprojects {
    tasks.withType(org.jetbrains.kotlin.gradle.tasks.KotlinCompile) {
        if (project.plugins.hasPlugin(\"com.android.application\") || project.plugins.hasPlugin(\"com.android.library\")) {
            kotlinOptions.jvmTarget = android.compileOptions.sourceCompatibility
        } else {
            kotlinOptions.jvmTarget = sourceCompatibility
        }
    }
}
```', '', NULL, 1, 0, true, '2024-02-22 10:24:41.677000');
INSERT INTO blogs (id, title, slug, author, content, html, thumbnail, category_id, view_count, is_published, created_at) VALUES (302, '使用flutter_rust_bridge编写rust和dart的组件库', 'blog-302', '梁典典', '**使用flutter_rust_bridge来编写一个aria2下载器**
# 效果预览
![image.png](https://minio.itbug.shop/blog/simple-file/image___1710568548503___.png)

# 安装基础库
```bash
cargo install ''flutter_rust_bridge_codegen@^2.0.0-dev.0''
```
# 新建/添加项目
```bash
flutter_rust_bridge_codegen create my_app #新建一个
or
flutter_rust_bridge_codegen integrate #现有目录中添加
```
# 编辑rust代码
找到rust文件夹,在src/api目录下编写rs代码
编写后插件目录下执行命令`flutter_rust_bridge_codegen generate --watch`,生成对应的dart代码


附上我写的aria2下载器api

`aria.rs`
```rs
use crate::frb_generated::StreamSink;
use aria2_ws::*;
use flutter_rust_bridge::{frb, DartFnFuture};
use futures::FutureExt;
use serde::{Deserialize, Serialize};
use serde_json::{json, Value};
use std::collections::HashMap;
// use aria2_ws::*;
// use serde_json::Value;
///新建连接
pub async fn connect_aria2_client(url: String) -> Client {
    let client = Client::connect(&url, None).await.unwrap();
    client
}

///创建配置
pub fn create_aria_task_option(
    header: Option<Vec<String>>,
    all_proxy: Option<String>,
    split: Option<i32>,
    dir: Option<String>,
    out: Option<String>,
    gid: Option<String>,
    r_continue: Option<bool>,
    auto_file_renaming: Option<bool>,
    check_integrity: Option<bool>,
    lowest_speed_limit: Option<String>,
    max_download_limit: Option<String>,
    max_tries: Option<i32>,
    max_connection_per_server: Option<i32>,
    timeout: Option<i32>,
    extra_options: HashMap<String, String>,
) -> TaskOptions {
    TaskOptions {
        header: header,
        split: split,
        all_proxy: all_proxy,
        dir: dir,
        out: out,
        gid: gid,
        r#continue: r_continue,
        auto_file_renaming: auto_file_renaming,
        check_integrity: check_integrity,
        lowest_speed_limit: lowest_speed_limit,
        max_download_limit: max_download_limit,
        max_connection_per_server: max_connection_per_server,
        max_tries: max_tries,
        timeout: timeout,
        extra_options: json!(extra_options).as_object().unwrap().clone(),
    }
}

///添加任务
pub async fn add_aria_task(
    urls: Vec<String>,
    client: &Client,
    options: Option<TaskOptions>,
    position: Option<u32>,
    on_complete: impl Fn() -> DartFnFuture<()> + Send + ''static,
    on_error: impl Fn() -> DartFnFuture<()> + Send + ''static,
) -> Result<String, MyError> {
    let gid = client
        .add_uri(
            urls,
            options,
            position,
            Some(Callbacks {
                on_download_complete: Some(
                    async move {
                        let result = on_complete().await;
                        result
                    }
                    .boxed(),
                ),
                on_error: Some(
                    async move {
                        let result = on_error().await;
                        result
                    }
                    .boxed(),
                ),
            }),
        )
        .await;
    match gid {
        Ok(id) => Ok(id),
        Err(e) => Err(MyError::from(e)),
    }
}

///监听aria消息
pub async fn listen_aria_msg(
    client: &Client,
    sink: StreamSink<MyNotification>,
) -> Result<(), String> {
    let mut not = client.clone().subscribe_notifications();
    flutter_rust_bridge::spawn(async move {
        while let Ok(msg) = not.recv().await {
            let _ = sink.add(MyNotification::from(msg));
        }
    });
    Ok(())
}

///获取任务的状态
pub async fn get_aria_status(client: &Client, gid: String) -> Result<String, MyError> {
    let result = client
        .call_and_wait::<Value>(\"tellStatus\", vec![Value::String(gid)])
        .await;
    match result {
        Ok(r) => Ok(serde_json::to_string(&r).unwrap()),
        Err(e) => {
            println!(\"call error: {:?}\", e);
            Err(MyError::from(e))
        }
    }
}

///通用函数调用
pub async fn call_aria_function(
    client: &Client,
    method: String,
    params: MyValue,
) -> Result<String, MyError> {
    let result = client
        .call_and_wait::<String>(&method, vec![my_value_to_value(params)])
        .await;
    match result {
        Ok(r) => Ok(r),
        Err(e) => {
            println!(\"error:{:?}\", e);
            Err(MyError::from(e))
        }
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[frb(dart_metadata=(\"freezed\", \"immutable\" import \"package:meta/meta.dart\" as meta))]
pub enum MyNotification {
    Aria2 { gid: String, event: MyEvent },
    WebSocketConnected,
    WebsocketClosed,
}

#[derive(Debug, Clone, PartialEq, Eq, Copy, Hash)]
#[frb(dart_metadata=(\"freezed\", \"immutable\" import \"package:meta/meta.dart\" as meta))]
pub enum MyEvent {
    Start,
    Pause,
    Stop,
    Complete,
    Error,
    /// This notification will be sent when a torrent download is complete but seeding is still going on.
    BtComplete,
}

impl From<Notification> for MyNotification {
    fn from(notification: Notification) -> Self {
        match notification {
            Notification::Aria2 { gid, event } => MyNotification::Aria2 {
                gid,
                event: event.into(),
            },
            Notification::WebSocketConnected => MyNotification::WebSocketConnected,
            Notification::WebsocketClosed => MyNotification::WebsocketClosed,
        }
    }
}

impl From<Event> for MyEvent {
    fn from(event: Event) -> Self {
        match event {
            Event::Start => MyEvent::Start,
            Event::Pause => MyEvent::Pause,
            Event::Stop => MyEvent::Stop,
            Event::Complete => MyEvent::Complete,
            Event::Error => MyEvent::Error,
            Event::BtComplete => MyEvent::BtComplete,
        }
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
#[frb(dart_metadata=(\"freezed\", \"immutable\" import \"package:meta/meta.dart\" as meta))]
pub enum MyValue {
    Bool(bool),
    String(String),
    Array(Vec<MyValue>),
}

pub fn my_value_to_value(my_value: MyValue) -> Value {
    match my_value {
        MyValue::Bool(b) => Value::Bool(b),
        MyValue::String(s) => Value::String(s),
        MyValue::Array(vec) => Value::Array(vec.into_iter().map(my_value_to_value).collect()),
    }
}
#[derive(Debug, Serialize, Deserialize, Clone, PartialEq, Eq, Hash)]
#[frb(dart_metadata=(\"freezed\", \"immutable\" import \"package:meta/meta.dart\" as meta))]
pub enum MyError {
    Aria2 { source: String },
    Parse { value: String, to: String },
    WebsocketIo { source: String },
    Json { source: String },
    WebsocketClosed { message: String },
    ReconnectTaskTimeout { source: String },
}

impl From<Error> for MyError {
    fn from(error: Error) -> Self {
        match error {
            Error::Aria2 { source } => MyError::Aria2 {
                source: format!(\"{:?}\", serde_json::to_string(&source)),
            },
            Error::Parse { value, to } => MyError::Parse { value, to },
            Error::WebsocketIo { source } => MyError::WebsocketIo {
                source: format!(\"{:?}\", source),
            },
            Error::Json { source } => MyError::Json {
                source: format!(\"{:?}\", source),
            },
            Error::WebsocketClosed { message } => MyError::WebsocketClosed { message },
            Error::ReconnectTaskTimeout { source } => MyError::ReconnectTaskTimeout {
                source: format!(\"{:?}\", source),
            },
        }
    }
}

```

# dart端插件封装
```dart
import ''dart:async'';
import ''dart:convert'';

import ''package:aria2_plugin/src/rust/api/aria.dart'';
import ''package:flutter/cupertino.dart'';

import ''model/aria_detail.dart'';

class Aria2Plugin {
  static final Aria2Plugin instance = Aria2Plugin._();

  factory Aria2Plugin() => instance;

  Aria2Plugin._();

  Client? client;
  StreamSubscription<MyNotification>? _stream;

  ///aria2 connection address
  Future<Client> connect(String address) async {
    client ??= await connectAria2Client(url: address);
    return client!;
  }

  ///add download task
  ///[return] gid
  Future<String> addTask(List<String> urls,
      {VoidCallback? onComplete, VoidCallback? onError}) async {
    if (client != null) {
      final opt = await createAriaTaskOption(extraOptions: {});
      final gid = await addAriaTask(
          urls: urls,
          client: client!,
          options: opt,
          onComplete: onComplete ?? () {},
          onError: onError ?? () {});
      return gid;
    }
    throw Aria2Error(message: ''please connect  first'');
  }

  ///add listener
  void addListen({ValueChanged<MyNotification>? listen}) {
    closeListen();
    if (client != null) {
      _stream ??= listenAriaMsg(client: client!).listen((event) {
        listen?.call(event);
      });
    }
  }

  ///turn off listening
  void closeListen() {
    if (_stream != null) {
      _stream!.cancel();
      _stream = null;
    }
  }

  ///get details
  Future<AriaDetail?> getInfo(String gid) async {
    if (client != null) {
      final info = await getAriaStatus(client: client!, gid: gid);
      return AriaDetail.fromJson(jsonDecode(info));
    }
    return null;
  }
}

class Aria2Error extends Error {
  final String message;

  Aria2Error({required this.message});

  @override
  String toString() {
    return message;
  }
}

```
# 项目中调用插件编写一个简单的下载器
```dart
import ''package:aria2_plugin/aria2_plugin.dart'';
import ''package:aria2_plugin/model/aria_detail.dart'';
import ''package:dd_js_util/dd_js_util.dart'';
import ''package:flutter/material.dart'';
import ''dart:async'';

import ''package:aria2_plugin/src/rust/api/aria.dart'';
import ''package:aria2_plugin/src/rust/frb_generated.dart'';
import ''package:provider/provider.dart'';

Future<void> main() async {
  await RustLib.init();
  runApp(const MyApp());
}

///状态管理
class Model extends ChangeNotifier {
  final gids = <String, MyEvent>{};
  final infos = <String, AriaDetail>{};
  Client? client;
  late Timer _timer;

  //连接
  Future<void> connect(String address) async {
    client = await Aria2Plugin().connect(address);
    Aria2Plugin().addListen(listen: _onListen);
    notifyListeners();
  }

  //添加任务
  Future<void> addTask(String url) async {
    Aria2Plugin().addTask([url]);
  }

  void cancelTimer() {
    if (!gids.containsValue(MyEvent.start)) {
      debugPrint(''canceled timer'');
      _timer.cancel();
    }
  }

  void startTimer() {
    debugPrint(\"start timer task\");
    _timer = Timer.periodic(const Duration(seconds: 1), _doGetInfo);
  }

  ///监听
  void _onListen(MyNotification value) {
    value.whenOrNull(
      aria2: (gid, event) {
        gids[gid] = event;
        notifyListeners();
        if (event == MyEvent.start) {
          startTimer();
        } else {
          delayFunction(() {
            cancelTimer();
          }, 2000);
        }
      },
    );
  }

  void _doGetInfo(Timer timer) {
    gids.forEach((key, value) {
      if (value case MyEvent.start) {
        Aria2Plugin().getInfo(key).then((r) {
          if (r != null) {
            infos[key] = r;
            notifyListeners();
          }
        });
      }
    });
  }

  void cancel() {
    _timer.cancel();
    client?.dispose();
  }
}

class MyApp extends StatefulWidget {
  const MyApp({super.key});

  @override
  State<MyApp> createState() => _MyAppState();
}

class _MyAppState extends State<MyApp> {
  final _textEditController =
      TextEditingController(text: ''ws://127.0.0.1:6800/jsonrpc'');
  final _urlController = TextEditingController(
      text:
          ''https://alist.azad.asia/d/189yun_2/%E7%BF%BC%E7%8B%90MAYA%E5%AE%8C%E5%85%A8%E8%87%AA%E5%AD%A6%E5%AE%9D%E5%85%B8%E3%80%90%E5%B7%B2%E6%95%B4%E5%90%8817%E7%AB%A0%E3%80%91/%E7%AC%AC04%E7%AB%A0%EF%BC%9A%E3%80%90%E6%A8%A1%E5%9E%8B%E7%AF%87%E3%80%91NURBS%E5%9F%BA%E7%A1%80.zip'');

  final model = Model();

  @override
  void initState() {
    super.initState();
  }

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      home: Scaffold(
          appBar: AppBar(
            title: const Text(''aria2下载器''),
          ),
          body: ChangeNotifierProvider(
            create: (context) => model,
            builder: (context, child) {
              return Consumer<Model>(
                builder: (context, value, child) {
                  final Model(:client, :gids, :infos) = value;
                  return SingleChildScrollView(
                    padding: const EdgeInsets.all(12),
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Row(
                          children: [
                            Expanded(
                                child: TextField(
                              controller: _textEditController,
                            )),
                            FilledButton(
                                onPressed: _connect, child: const Text(\"连接服务\"))
                          ],
                        ),
                        Row(
                          children: [
                            Expanded(
                              child: TextField(
                                controller: _urlController,
                                maxLines: 3,
                              ),
                            ),
                            FilledButton(
                                onPressed: client == null ? null : _addTask,
                                child: const Text(''添加下载任务''))
                          ],
                        ),
                        Padding(
                          padding: const EdgeInsets.symmetric(
                              vertical: 12, horizontal: 8),
                          child:
                              Text(''任务列表'', style: context.textTheme.titleLarge),
                        ),
                        ...gids.keys.map((e) {
                          final info = infos[e];
                          return _Info(item: info, event: gids[e]);
                        })
                      ],
                    ),
                  );
                },
              );
            },
          )),
    );
  }

  Future<void> _connect() async {
    final url = _textEditController.text;
    if (url.isNotEmpty) {
      model.connect(url);
    }
  }

  Future<void> _addTask() async {
    final url = _urlController.text;
    model.addTask(url);
  }
}

class _Info extends StatelessWidget {
  final AriaDetail? item;
  final MyEvent? event;
  const _Info({this.item, this.event});

  @override
  Widget build(BuildContext context) {
    final value = event == MyEvent.complete ? 1.0 : item?.percentage ?? 0.01;
    return Card(
      margin: const EdgeInsets.all(12),
      child: Padding(
        padding: const EdgeInsets.all(8.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(Uri.decodeComponent(
                item?.files.first.path.urlManager.filenameAll ?? '''')),
            const SizedBox(
              height: 12,
            ),
            Wrap(
              spacing: 6,
              runSpacing: 6,
              children: [
                //
                Chip(
                    label: Text(
                        ''总大小:${ByteModel.create(item?.totalLengthDouble ?? 0.1).format()}'')),
                Chip(
                    label: Text(
                        ''已下载:${ByteModel.create(item?.completedLengthDouble ?? 0.1).format()}'')),
                Chip(label: Text(''保存目录:${item?.dir ?? ''''}'')),
                Chip(label: Text(''已下载字节:${item?.completedLength ?? 0}'')),
                Chip(label: Text(''总字节大小:${item?.totalLength ?? 0}'')),
                Chip(
                    label: Text(
                        ''下载速度:${ByteModel.create(item?.downloadSpeedDouble ?? 0).format(2)}''))
              ],
            ),
            //
            const SizedBox(
              height: 12,
            ),
            LinearProgressIndicator(
              minHeight: 1,
              borderRadius: BorderRadius.circular(20),
              value: value, // 设置进度值，范围为0.0到1.0
              backgroundColor: Colors.grey, // 设置背景颜色
              valueColor:
                  const AlwaysStoppedAnimation<Color>(Colors.blue), // 设置进度条颜色
            ),
          ],
        ),
      ),
    );
  }
}

```', '', NULL, 1, 0, true, '2024-03-16 13:56:17.758000');
INSERT INTO blogs (id, title, slug, author, content, html, thumbnail, category_id, view_count, is_published, created_at) VALUES (352, '使用rust编写flutter插件流程()', 'blog-352', '梁典典', '# 1. 新建插件目录

> 注意: `hello_rust_ffi_plugin` 改成插件项目名字
```bash
flutter create --template=plugin_ffi hello_rust_ffi_plugin --platforms android,ios,macos,windows,linux
```
# 2. 添加cargokit自动编译脚本

> 注意: `hello_rust_ffi_plugin` 修改插件名
```bash
cd hello_rust_ffi_plugin
git init
git add --all
git commit -m \"initial commit\"
```
添加cargokit 到插件目录树
```bash
git subtree add --prefix cargokit https://github.com/irondash/cargokit.git main --squash
```

# 3.添加rust项目

> 注意: 修改`hello_rust_ffi_plugin`项目名字
```bash
cargo new rust --lib --name hello_rust_ffi_plugin
```
这个命令会在插件的项目目录下添加一个rust目录,需要在里面编写rust代码

打开`rust/cargo.toml`文件新增这些内容,不加会构建lib失败,注意单词拼写
```toml
## >>>>>>>>>>>>> ADDED CODE >>>>>>>>>>>>>
[lib]
crate-type = [\"cdylib\", \"staticlib\"]
## <<<<<<<<<<<< ADDED CODE <<<<<<<<<<<<
```

修改后完整内容如下
```toml
[package]
name = \"hello_rust_ffi_plugin\"
version = \"0.1.0\"
edition = \"2021\"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html
[lib]
crate-type = [\"cdylib\", \"staticlib\"]


```

# 4. 添加编译脚本

## 1. macos编译脚本
修改这个文件
![image.png](https://minio.itbug.shop/blog/simple-file/image___1710743511665___.png)
添加这些内容
> ⚠️注意修改替换插件名字

![image.png](https://minio.itbug.shop/blog/simple-file/image___1710743581995___.png)
修改后的内容如下
```podspec
#
# To learn more about a Podspec see http://guides.cocoapods.org/syntax/podspec.html.
# Run `pod lib lint hello_rust_ffi_plugin.podspec` to validate before publishing.
#
Pod::Spec.new do |s|
  s.name             = ''hello_rust_ffi_plugin''
  s.version          = ''0.0.1''
  s.summary          = ''A new Flutter FFI plugin project.''
  s.description      = <<-DESC
A new Flutter FFI plugin project.
                       DESC
  s.homepage         = ''http://example.com''
  s.license          = { :file => ''../LICENSE'' }
  s.author           = { ''Your Company'' => ''email@example.com'' }

  # This will ensure the source files in Classes/ are included in the native
  # builds of apps using this FFI plugin. Podspec does not support relative
  # paths, so Classes contains a forwarder C file that relatively imports
  # `../src/*` so that the C sources can be shared among all target platforms.
  s.source           = { :path => ''.'' }
  s.source_files     = ''Classes/**/*''
  s.dependency ''FlutterMacOS''

  s.platform = :osx, ''10.11''
  s.pod_target_xcconfig = { ''DEFINES_MODULE'' => ''YES'' }
  s.swift_version = ''5.0''


  s.script_phase = {
    :name => ''Build Rust library'',
    # First argument is relative path to the `rust` folder, second is name of rust library
    :script => ''sh \"$PODS_TARGET_SRCROOT/../cargokit/build_pod.sh\" ../rust hello_rust_ffi_plugin'',
    :execution_position => :before_compile,
    :input_files => [''${BUILT_PRODUCTS_DIR}/cargokit_phony''],
    # Let XCode know that the static library referenced in -force_load below is
    # created by this build step.
    :output_files => [\"${BUILT_PRODUCTS_DIR}/libhello_rust_ffi_plugin.a\"],
  }
  s.pod_target_xcconfig = {
    ''DEFINES_MODULE'' => ''YES'',
    # Flutter.framework does not contain a i386 slice.
    ''EXCLUDED_ARCHS[sdk=iphonesimulator*]'' => ''i386'',
    ''OTHER_LDFLAGS'' => ''-force_load ${BUILT_PRODUCTS_DIR}/libhello_rust_ffi_plugin.a'',
  }
end
```
## 2. iOS基本和macos一样,可以改为软连接

执行命令
```bash
rm -R ios
ln -s macos ios
```
## 3. Windows和Linux

> 都是一样的,复制就行,注意修改替换插件名字
```cmake
# The Flutter tooling requires that developers have CMake 3.10 or later
# installed. You should not increase this version, as doing so will cause
# the plugin to fail to compile for some customers of the plugin.
cmake_minimum_required(VERSION 3.10)

# Project-level configuration.
set(PROJECT_NAME \"hello_rust_ffi_plugin\")
project(${PROJECT_NAME} LANGUAGES CXX)

# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
# Replace add_subdirectory that references old C++ code with Cargokit:
include(\"../cargokit/cmake/cargokit.cmake\")
apply_cargokit(${PROJECT_NAME} ../rust hello_rust_ffi_plugin \"\")
# <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

# List of absolute paths to libraries that should be bundled with the plugin.
# This list could contain prebuilt libraries, or libraries created by an
# external build triggered from this build file.
set(hello_rust_ffi_plugin_bundled_libraries
  # Defined in ../src/CMakeLists.txt.
  # This can be changed to accommodate different builds.

  # >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
  # Replace original target file with the one produced by Cargokit:
  \"${${PROJECT_NAME}_cargokit_lib}\"
  # <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  PARENT_SCOPE
)
```
## 4.Android
在`android/build.gradle`修改如下内容
> 注意修改插件名

```gradle
group ''com.example.hello_ffi_plugin''
version ''1.0''

buildscript {
    repositories {
        google()
        mavenCentral()
    }

    dependencies {
        // The Android Gradle Plugin knows how to build native code with the NDK.
        classpath ''com.android.tools.build:gradle:7.3.0''
    }
}

rootProject.allprojects {
    repositories {
        google()
        mavenCentral()
    }
}

apply plugin: ''com.android.library''

android {
    if (project.android.hasProperty(\"namespace\")) {
        namespace ''com.example.hello_ffi_plugin''
    }

    // Bumping the plugin compileSdkVersion requires all clients of this plugin
    // to bump the version in their app.
    compileSdkVersion 33

    compileOptions {
        sourceCompatibility JavaVersion.VERSION_1_8
        targetCompatibility JavaVersion.VERSION_1_8
    }

    defaultConfig {
        minSdkVersion 19
    }
}

// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

apply from: \"../cargokit/gradle/plugin.gradle\"

cargokit {
    manifestDir = \"../rust\"
    libname = \"hello_rust_ffi_plugin\"
}

// >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
```

# 5 添加frb依赖

在`rust/Cargo.toml`文件添加依赖, `flutter_rust_bridge`可换成最新的,现在最新版本是`2.0.0-dev.28`
```toml
[dependencies]
flutter_rust_bridge = \"=2.0.0-dev.28\"
```
在插件项目中新增文件`flutter_rust_bridge.yaml`

> 这个文件是frb生产代码的一些配置,可以参考官网文档
```yaml
rust_input: rust/src/api/**/*.rs # 需要生成dart的rust代码文件
dart_output: lib/   # rust生成的基础代码目录,我这填的lib
```
# 6 生成代码

插件目录下执行
```bash
flutter_rust_bridge_codegen generate
```

全部搞定
', '', NULL, 1, 0, true, '2024-03-18 14:47:06.476000');
INSERT INTO blogs (id, title, slug, author, content, html, thumbnail, category_id, view_count, is_published, created_at) VALUES (402, 'c++封装一个Log类', 'blog-402', '梁典典', '```cpp

#include <iostream>
class Log {

public:
    const int LogLevelError = 0;
    const int LogLevelWarning = 1;
    const int LogLevelInfo = 2;
private:
    int m_LogLevel = LogLevelInfo;

public:
    void SetLevel(const int level) {
        m_LogLevel = level;
    }

    void Warn(const char* message) {
        if (m_LogLevel >= LogLevelWarning)
            std::cout << \"[WARN]:\" << message << std::endl;
    }
    void Error(const char* message) {
        if (m_LogLevel >= LogLevelError)
            std::cout << \"[Error]:\" << message << std::endl;
    }
    void Info(const char* message) {
        if (m_LogLevel >= LogLevelInfo)
            std::cout << \"[Info]:\" << message << std::endl;
    }
};

int main() {

    Log log;
    log.SetLevel(log.LogLevelError);
    log.Error(\"error message\");
    log.Info(\"info message\");
    log.Warn(\"warn message\");

    return 0;
}
```', '', NULL, 52, 0, true, '2024-04-06 16:30:59.884000');
INSERT INTO blogs (id, title, slug, author, content, html, thumbnail, category_id, view_count, is_published, created_at) VALUES (452, 'rust交叉编译Salvo项目并发布到docker运行', 'blog-452', '梁典典', '电脑需要先安装一下docker

# 1.配置交叉编译工具
工具链接: [rust-musl-cross](https://github.com/rust-cross/rust-musl-cross)

我这里用的是x86_64-musl,所以安装命令为
```bash
docker pull messense/rust-musl-cross:x86_64-musl
```
在~/.zshrc设置别名
```bash
alias rust-musl-builder=''docker run --rm -it -v \"$(pwd)\":/home/rust/src messense/rust-musl-cross:x86_64-musl''
```
以后就可以用这个命令来编译了
```bash
rust-musl-builder cargo build --release
```
编译后会在项目目录下生成执行可执行文件,我这里像这样
![image.png](https://minio.itbug.shop/blog/simple-file/image___1713404569271___.png)
# 2. 编写Dockerfile
`d_blog`替换为项目名字
```Dockerfile
FROM alpine:latest
ENV TZ Asia/Shanghai
RUN apk add tzdata && cp /usr/share/zoneinfo/${TZ} /etc/localtime \\
    && echo ${TZ} > /etc/timezone \\
    && apk del tzdata
WORKDIR /home/app-dir
COPY ./target/x86_64-unknown-linux-musl/release/d_blog ./d_blog
COPY ./data ./data
COPY ./config ./config
COPY ./assets ./assets
COPY ./logs ./logs
ENV LANG en US.UTF-8
ENV LANGUAGE en US:en
ENV LC ALL en US.UTF-8
EXPOSE 5800
ENTRYPOINT [\"/home/app-dir/d_blog\"]
```
这是我的项目结构
![image.png](https://minio.itbug.shop/blog/simple-file/image___1713404600437___.png)

# 3.打包镜像

项目根目录下执行
hello_rust 镜像名称
```bash
sudo docker build  -t hello_rust . 
```
执行过程如下图
![image.png](https://minio.itbug.shop/blog/simple-file/image___1713404756477___.png)

生成的镜像只有30多M
![image.png](https://minio.itbug.shop/blog/simple-file/image___1713404815857___.png)

可以看到可执行文件和一些配置文件已经拷贝到镜像里面去了
![image.png](https://minio.itbug.shop/blog/simple-file/image___1713409805160___.png)

# 4.执行
```
docker run --name test -it  hello_rust:latest 
```

`hello_rust:latest `: 镜像名称

`test`: 容器名称

可以看到已经跑起来了
![image.png](https://minio.itbug.shop/blog/simple-file/image___1713405066371___.png)

在orbStack也可以看到
![image.png](https://minio.itbug.shop/blog/simple-file/image___1713405122787___.png)', '', NULL, 102, 0, true, '2024-04-18 09:52:24.686000');
INSERT INTO blogs (id, title, slug, author, content, html, thumbnail, category_id, view_count, is_published, created_at) VALUES (453, 'Github action workflow 自动编译React项目并部署到服务器', 'blog-453', '梁典典', '# 添加workflow配置
在项目的根目录下新建一个文件,它的路径像这样`.github/workflows/build.yml`

触发条件是,push仓库到main分支就执行这个部署
```yaml
name: 打包上传
on:
  push:
    branches:
      - main
jobs:
  build:
    runs-on: ubuntu-latest
    strategy:
      matrix:

        node-version: [ 20 ]
    steps:
      - uses: actions/checkout@v4

#      - name: 安装nodejs
#        uses: actions/setup-node@v4
#        with:
#          node-version: 20
#
#      - name: 安装依赖
#        run: npm install
#
#      - name: 构建
#        run: npm run build

      - name: 发布到服务器
        uses: easingthemes/ssh-deploy@v5.0.3
        env:
          REMOTE_HOST: ${{ secrets.HOST }}
          REMOTE_USER: ${{ secrets.USER }}
          SSH_PRIVATE_KEY: ${{ secrets.PASS }}
          REMOTE_PORT: ${{ secrets.PORT }}
          SOURCE: \"dist/\"
          TARGET: ${{ secrets.PATH }}

```

> 注意 PASS 不能设置密码,要ssh私钥,一长串那个

不知道为啥我这里会出错,所以先注释了,好像有个三方依赖报错了
|属性 |描述 |
| --- | --- |
| REMOTE_HOST |服务器IP |
| REMOTE_USER |登录用户名 |
| SSH_PRIVATE_KEY |服务器私钥,这个私钥不能设置密码,否则会登不进 |
| REMOTE_PORT | SSH端口 |
| TARGET | 服务器上传路径|', '', NULL, 104, 0, true, '2024-04-20 15:12:31.223000');
INSERT INTO blogs (id, title, slug, author, content, html, thumbnail, category_id, view_count, is_published, created_at) VALUES (502, 'Rust使用Github action自动编译并发行Release版本', 'blog-502', '梁典典', '这里需要用到`taiki-e/create-gh-release-action@v1`这个action,可以到[Github action市场](https://github.com/marketplace/actions/create-github-releases-based-on-changelog)下载和查看相关文档

## 1.编写 `rust-build.yml`构建配置

```yaml
name: Release
permissions:
  contents: write
on:
  push:
    tags:
      - v[0-9]+.*  #新建tag触发,比如v0.1.1
jobs:
  create-release:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          ref: cross-compile-action #分支名字
      - uses: taiki-e/create-gh-release-action@v1
        with:
          changelog: CHANGELOG.md #获取更新日志,需要在changelog添加对应版本的更新日志,否则会失败
          token: ${{ secrets.ACTION_ACCESS }} # github token
  upload-assets:
    needs: create-release
    strategy:
      matrix:
        include: #编译的平台tager
          - target: aarch64-unknown-linux-gnu
          - target: aarch64-unknown-linux-musl
          - target: aarch64-apple-darwin
            os: macos-11
          - target: x86_64-unknown-linux-gnu
          - target: x86_64-unknown-linux-musl
          - target: x86_64-apple-darwin
            os: macos-10.15
          - target: x86_64-pc-windows-msvc
            os: windows-2019
    runs-on: ${{ matrix.os || ''ubuntu-18.04'' }}
    steps:
      - uses: actions/checkout@v4
      - uses: taiki-e/upload-rust-binary-action@v1
        with:
          bin: d_blog #项目名字
          target: ${{ matrix.target }}
          tar: unix
          zip: windows
          token: ${{ secrets.ACTION_ACCESS }}
```

# 编写changelog

发布前需要添加对应的更新日志否则会失败,如果没有配置`changelog`则不填写

模板像这样
```md
# Changelog

All notable changes to this project will be documented in this file.

This project adheres to [Semantic Versioning](https://semver.org).

<!--
Note: In this file, do not use the hard wrap in the middle of a sentence for compatibility with GitHub comment style markdown rendering.
-->

## [Unreleased]

## [0.1.1] - 2024-04-22
- test

## [0.0.5] - 2024-04-19
- bug fix

## [0.0.4] - 2024-04-19
- bug fix

## [0.0.3] - 2024-04-19
- bug fix
```

# 提交代码并新建标签

提交代码
```bash
git push origin main
```
新建本地标签
```bash
git tag v0.1.1
```
上传标签,这一步会触发github action 的任务
```
git push origin v0.1.1
```

# 效果预览
过程有点慢,需要耐心等待任务完成
![image.png](https://minio.itbug.shop/blog/simple-file/image___1713749320602___.png)

上传成功后就可以在release里面看到了,整个流程结束', '', NULL, 102, 0, true, '2024-04-22 09:29:33.186000');
INSERT INTO blogs (id, title, slug, author, content, html, thumbnail, category_id, view_count, is_published, created_at) VALUES (552, 'Idea插件开发技巧', 'blog-552', '梁典典', '# 高亮代码

```kotlin
    /**
     * 高亮代码段转html
     */
    fun highlightCodeToHtml(code: String, project: Project, lang: Language): String {
        val s = StringBuilder()
        val sb = HtmlSyntaxInfoUtil.appendHighlightedByLexerAndEncodedAsHtmlCodeSnippet(
            s,
            project,
            lang,
            code,
            true,
            0.65f
        )
        return sb.toString()
    }
```

# JBList常见用法

```kotlin
ScrollingUtil.installActions(this)
//右键选中
ListUiUtil.Selection.installSelectionOnRightClick(this)

ListUiUtil.Selection.installSelectionOnFocus(this)
//注册右键菜单
PopupHandler.installPopupMenu(this, rightMenuAction, \"Right Menu\")
TreeUIHelper.getInstance().installListSpeedSearch(this) { o -> o.api }

//触发搜索关键字
SpeedSearchUtil.applySpeedSearchHighlighting(list, this, false, selected)
```


# JTree

```kotlin
// 安装右键操作
CustomizationUtil.installPopupHandler(
            this, \"flutter-l10n-right-menu\", \"Flutter l10n\"
        )
//快速搜索
TreeUIHelper.getInstance().installTreeSpeedSearch(this)
//自动展开收缩子树
SmartExpander.installOn(this)
//增强操作
TreeHoverListener.DEFAULT.addTo(this)
//安装常用操作
TreeUtil.installActions(this)

```

# 拷贝文字到剪贴板

可以使用idea plugin 内置的SDK来进行处理

```kotlin
import java.awt.datatransfer.StringSelection
import com.intellij.openapi.ide.CopyPasteManager
//拷贝文本
fun copy(text: String) {
    CopyPasteManager.getInstance().setContents(StringSelection(text))
}
```

# 内联操作

在内部弹窗菜单添加内部操作
就是在这个位置添加操作
![image.png](https://minio.itbug.shop/blog/simple-file/image___1713927310516___.png)
在plugin.xml添加

```xml

<extensions defaultExtensionNs=\"com.intellij\">
    <intentionAction>
        <className>shop.itbug.salvorstool.intention.CopyAntdTableColumnAction</className>
        <language>Rust</language>
    </intentionAction>
</extensions>
```

需要两个参数`language`和`className`,`className`需要实现`IntentionAction`接口,如果操作PsiElement,可以继承
`PsiElementBaseIntentionAction`这个类,但是`IntentionAction`也要实现

举个例子

这个功能是实现Rust Struct生成antd table columns的模板并拷贝到剪贴板

```kotlin

class CopyAntdTableColumnAction : PsiElementBaseIntentionAction(), IntentionAction {

    override fun getFamilyName(): String {
        return \"Copy Antd Table Column\"
    }
    override fun getText(): String {
        return familyName
    }
    override fun isAvailable(project: Project, editor: Editor?, element: PsiElement): Boolean {
        return element.parent is RsStructItemImpl
    }
    override fun invoke(project: Project, editor: Editor?, element: PsiElement) {
        val rs = element.parent as? RsStructItemImpl ?: return
        val manager = rs.myManager
        val sb = StringBuilder()
        sb.appendLine(\"[\")
        manager.jsModelList.map {
            sb.append(\"\
\\t\\t\")
            sb.append(it.antdTableColumnItem)
            sb.append(\",\
\")
        }
        sb.appendLine(\"]\")
        CopyPasteManager.getInstance().setContents(StringSelection(sb.toString()))
    }

}
```

# 获取编辑器的字体

```kotlin
Font font = EditorColorsManager . getInstance ().globalScheme.getFont(EditorFontType.PLAIN)
```

# Searcheverywhere

就是在这个位置注入一个搜索选项tab栏目
![image.png](https://minio.itbug.shop/blog/simple-file/image___1714268617424___.png)
实现`searchEverywhereContributor`扩展

```xml

<searchEverywhereContributor implementation=\"shop.itbug.salvorstool.searcheverywhere.SalvoSearchApi\"/>
```

demo

```kotlin

fun fetchApiList(project: Project): List<SalvoApiItem> {
    return runReadAction {
        return@runReadAction FinderApiManager(project).findAllApiList()
    }
}

class SalvoSearchApi : SearchEverywhereContributorFactory<SalvoApiItem> {

    override fun createContributor(initEvent: AnActionEvent): SearchEverywhereContributor<SalvoApiItem> {
        return MySearchEverywhereProvider(initEvent.project!!)
    }

    override fun isAvailable(project: Project?): Boolean {
        return project != null
    }

    @OptIn(DelicateCoroutinesApi::class)
    private inner class MySearchEverywhereProvider(val project: Project) : SearchEverywhereContributor<SalvoApiItem> {

        var allApi: List<SalvoApiItem> = emptyList()

        init {
            val job = GlobalScope.launch {
                val result = async { fetchApiList(project) }.await()
                allApi = result
            }
            GlobalScope.launch {
                job.join()
            }
        }

        override fun getSearchProviderId(): String {
            return MySearchEverywhereProvider::class.java.name
        }

        override fun getGroupName(): String {
            return \"Salvo\"
        }

        override fun getSortWeight(): Int {
            return Integer.MAX_VALUE
        }

        override fun showInFindResults(): Boolean {
            return true
        }

        override fun getElementsRenderer(): ListCellRenderer<in SalvoApiItem> {
            return SalvoApiItemRender()
        }

        override fun getDataForItem(element: SalvoApiItem, dataId: String): Any? {
            return null
        }

        override fun processSelectedItem(selected: SalvoApiItem, modifiers: Int, searchText: String): Boolean {
            selected.navTo(project)
            return true
        }

        override fun fetchElements(
            pattern: String,
            progressIndicator: ProgressIndicator,
            consumer: Processor<in SalvoApiItem>
        ) {
            val list = if (pattern.isEmpty()) allApi else allApi.filter { it.api.contains(pattern) }
            list.forEach {
                if (consumer.process(it).not()) {
                    return
                }
            }
        }

        override fun isShownInSeparateTab(): Boolean {
            return true
        }

    }
}
```

2024年06月26日09:03:18 更新

## 同步执行耗时操作

```kotlin
ProgressManager.getInstance().runProcessWithProgressSynchronously({
    println(\"---\")
    Thread.sleep(3000)
}, \"执行中\", false, null)
```

## 执行系统级命令行操作

```kotlin
GeneralCommandLine commandLine =
new GeneralCommandLine (getOptions().getScriptName());
OSProcessHandler processHandler = ProcessHandlerFactory . getInstance ()
    .createColoredProcessHandler(commandLine);
ProcessTerminatedListener.attach(processHandler); //启动run窗口执行
```

# 保存所有文档

如果文件被修改后没有马上被触发，需要执行一下这个函数
```kotlin
FileDocumentManager.getInstance().saveAllDocuments()
```

其他待补充', '', NULL, 152, 0, true, '2024-04-24 10:59:57.063000');
INSERT INTO blogs (id, title, slug, author, content, html, thumbnail, category_id, view_count, is_published, created_at) VALUES (602, 'rust使用sea-orm-cli来操作数据库', 'blog-602', '梁典典', '详细文档链接[https://www.sea-ql.org/SeaORM/docs/migration/setting-up-migration/](https://www.sea-ql.org/SeaORM/docs/migration/setting-up-migration/)

## 初始化

```bash
sea-orm-cli migrate init
```

## 创建表
```bash
sea-orm-cli migrate generate table_name
```

## 生成实体数据
```bash
sea-orm-cli generate entity -o src/entities -v --with-serde both
```

## 设置外键
fk_role: 外键表名
from: 当前表的某个字段 (需要映射的外键)
to: 外表,对应表的对应ID
```rust
.foreign_key(ForeignKeyCreateStatement::new()
.name(\"fk_role\")
.from(PermissionRole::Table, PermissionRole::RoleId)
.to(Role::Table, Role::Id)
.on_delete(ForeignKeyAction::Cascade))
```', '', NULL, 102, 0, true, '2024-05-14 14:16:48.877000');
INSERT INTO blogs (id, title, slug, author, content, html, thumbnail, category_id, view_count, is_published, created_at) VALUES (603, 'gradle使用org.jetbrains.changelog在markdown中编写更新日志', 'blog-603', '梁典典', '## 1.引入依赖

```kotlin
plugins {
    id(\"org.jetbrains.changelog\") version \"2.2.0\"
}
```

## 2.编写配置
```kotlin
changelog {
    version = project.version as String
    path = file(\"CHANGELOG.md\").canonicalPath
    groups.empty()
}
```

## 3. 解析日志
```kotlin
    val myChangeLog = provider {
        changelog.renderItem(
            changelog
                .getOrNull(project.version as String) ?: changelog.getUnreleased()
                .withHeader(false)
                .withEmptySections(false),
            Changelog.OutputType.HTML
        )
    }
```

## 添加文件
在项目的根目录下添加文件`CHANGELOG.md`
文件的内容格式如下

> 替换[1.6.0] - 2024-05-13这里为最新版本号,和日期
```md
# Changelog
## Unreleased

## [1.6.0] - 2024-05-13
```

## 使用示例
```kotlin
import org.jetbrains.changelog.Changelog

plugins {
    id(\"org.jetbrains.kotlin.jvm\") version \"1.9.22\"
    id(\"org.jetbrains.intellij\") version \"1.17.2\"
    id(\"org.jetbrains.changelog\") version \"2.2.0\"
}

group = \"shop.itbug\"
version = \"1.6.0\"

repositories {
    mavenCentral()
}

intellij {
    version.set(\"LATEST-EAP-SNAPSHOT\")
    type.set(\"RR\")
    plugins.set(listOf(\"com.jetbrains.rust\", \"JavaScriptBase\"))
}

val pushToken: String? = System.getenv(\"PUBLISH_TOKEN\")

tasks {
    withType<JavaCompile> {
        sourceCompatibility = \"17\"
        targetCompatibility = \"17\"
    }

    val myChangeLog = provider {
        changelog.renderItem(
            changelog
                .getOrNull(project.version as String) ?: changelog.getUnreleased()
                .withHeader(false)
                .withEmptySections(false),
            Changelog.OutputType.HTML
        )
    }

    val descText = projectDir.resolve(\"DESCRIPTION.md\").readText()


    patchPluginXml {
        sinceBuild.set(\"232\")
        untilBuild.set(\"242.*\")
        changeNotes.set(myChangeLog)
        pluginDescription.set(descText)
    }

    signPlugin {
        certificateChain.set(System.getenv(\"CERTIFICATE_CHAIN\"))
        privateKey.set(System.getenv(\"PRIVATE_KEY\"))
        password.set(System.getenv(\"PRIVATE_KEY_PASSWORD\"))
    }

    publishPlugin {
        if (pushToken != null) {
            token.set(pushToken)
        }
    }

    runIde {
        jvmArgs = listOf(\"-XX:+AllowEnhancedClassRedefinition\")
    }

}

changelog {
    version = project.version as String
    path = file(\"CHANGELOG.md\").canonicalPath
    groups.empty()
}
```', '', NULL, 3, 0, true, '2024-05-15 10:40:09.754000');
INSERT INTO blogs (id, title, slug, author, content, html, thumbnail, category_id, view_count, is_published, created_at) VALUES (652, 'docker打包并上传到docker hub', 'blog-652', '梁典典', '## 注意

打包前记得bootJar编译 (dd_service)

## 1. 打包构建

> 需要替换0.0.3标签

```bash
sudo docker build -t liangdiandian/dd_server:0.0.3 -f ./Dockerfile .
```

## 2. 发布
> 需要替换0.0.3标签
```bash
docker push liangdiandian/dd_server:0.0.3
```', '', NULL, 104, 0, true, '2024-05-21 10:53:31.881000');
INSERT INTO blogs (id, title, slug, author, content, html, thumbnail, category_id, view_count, is_published, created_at) VALUES (702, 'idea plugin 开发升级到2.0.0.beta版本', 'blog-702', '梁典典', '## 文档

* v2: [文档](https://plugins.jetbrains.com/docs/intellij/tools-intellij-platform-gradle-plugin.html)
* 插件验证: [配置插件验证](https://plugins.jetbrains.com/docs/intellij/tools-intellij-platform-gradle-plugin-extension.html#intellijPlatform-verifyPlugin-ides)

## 修改settings.gradle.kts

添加`maven(\"https://oss.sonatype.org/content/repositories/snapshots/\")`

```gradle
pluginManagement {
    repositories {
        maven(\"https://oss.sonatype.org/content/repositories/snapshots/\")
    }
}
```

## 添加repositories
```gradle

repositories {
    mavenCentral()

    //新增
    intellijPlatform {
        defaultRepositories()
        releases()
        marketplace()
    }
}
```

## 修改plugin id 

```gradle
 id(\"org.jetbrains.intellij.platform\") version \"2.0.0-beta7\"
```

## 修改 dependencies

```gradle
dependencies {
    #新增
    intellijPlatform {
        rustRover(\"2024.1.2\") # 平台版本,按需修改
        bundledPlugins(\"com.jetbrains.rust\",\"JavaScriptBase\") #内置插件依赖
        instrumentationTools() #必要的
    }
}
```

## 完整的示例

```gradle
import org.jetbrains.changelog.Changelog
import org.jetbrains.intellij.platform.gradle.IntelliJPlatformType
import org.jetbrains.intellij.platform.gradle.models.ProductRelease
import org.jetbrains.kotlin.gradle.dsl.JvmTarget
import org.jetbrains.kotlin.gradle.dsl.KotlinVersion
import java.util.*

plugins {
    kotlin(\"jvm\") version \"2.0.0\"
    id(\"org.jetbrains.changelog\") version \"2.2.0\"
    id(\"org.jetbrains.intellij.platform\") version \"2.0.0-beta7\"

}

group = \"shop.itbug\"
version = \"1.0.3\"

repositories {
    mavenCentral()
    intellijPlatform {
        defaultRepositories()
        releases()
        marketplace()
    }
}

dependencies {
    intellijPlatform {
        intellijIdeaUltimate(\"2024.1.4\")
        bundledPlugins(\"org.jetbrains.kotlin\", \"JavaScript\")
        pluginVerifier()
        zipSigner()
        instrumentationTools()
    }
}


val changeLog = provider {
    changelog.renderItem(
        changelog
            .getOrNull(project.version as String) ?: changelog.getUnreleased()
            .withHeader(false)
            .withEmptySections(false),
        Changelog.OutputType.HTML
    )
}


tasks {
    withType<JavaCompile> {
        sourceCompatibility = \"17\"
        targetCompatibility = \"17\"
    }
    withType<org.jetbrains.kotlin.gradle.tasks.KotlinCompile> {
        compilerOptions {
            jvmTarget.set(JvmTarget.JVM_17)
            languageVersion.set(KotlinVersion.KOTLIN_2_0)
        }
    }

    patchPluginXml {
        sinceBuild.set(\"232\")
        changeNotes.set(changeLog)
    }

    runIde {
        jvmArgs = listOf(\"-XX:+AllowEnhancedClassRedefinition\")
    }

    signPlugin {
        certificateChain.set(System.getenv(\"certificateChain\".uppercase(Locale.getDefault())))
        privateKey.set(System.getenv(\"privateKey\".uppercase(Locale.getDefault())))
        password.set(System.getenv(\"password\".uppercase(Locale.getDefault())))
    }

    publishPlugin {
        token.set(System.getenv(\"PUBLISH_TOKEN\"))
    }

    dependencies {
        implementation(\"cn.hutool:hutool-all:5.8.15\")
        implementation(\"com.alibaba.fastjson2:fastjson2:2.0.25\")
        implementation(\"com.alibaba.fastjson2:fastjson2-kotlin:2.0.25\")
    }

}

intellijPlatform {
    verifyPlugin {
        ides {
            recommended()
            local(file(\"/Applications/IntelliJ IDEA Ultimate.app\"))
            local(file(\"/Users/ldd/Applications/IntelliJ IDEA Ultimate.app\"))
            select {
                types = listOf(IntelliJPlatformType.IntellijIdeaUltimate)
                channels = listOf(ProductRelease.Channel.RELEASE, ProductRelease.Channel.EAP)
                sinceBuild = \"232\"
            }
        }
    }
}


changelog {
    version = project.version as String
    path = file(\"CHANGELOG.md\").canonicalPath
    groups.empty()
}


```', '', NULL, 152, 0, true, '2024-06-20 13:32:41.653000');
INSERT INTO blogs (id, title, slug, author, content, html, thumbnail, category_id, view_count, is_published, created_at) VALUES (703, '写了个rust sea-orm迁移小工具', 'blog-703', '梁典典', '
* 下载地址:1. [idea插件市场](https://plugins.jetbrains.com/plugin/24142-salvorstool?noRedirect=true)  2. [Github](https://github.com/mdddj/SalvoRsTool)
* 文档地址: [https://mdddj.github.io/SalvoRsToolDocument/](https://mdddj.github.io/SalvoRsToolDocument/)
* 源码 : [Github](https://github.com/mdddj/SalvoRsTool)

## 1 安装
[文档安装教程](https://mdddj.github.io/SalvoRsToolDocument/default-topic.html)

## 2. 使用

先sea-orm-cli创建一个table迁移文件
```bash
sea-orm-cli migrate generate create_table
```

安装成功后,底部小状态栏有个功能入口
![image.png](https://minio.itbug.shop/blog/simple-file/image___1718949538445___.png)

输入你要生成迁移的json

![image.png](https://minio.itbug.shop/blog/simple-file/image___1718949574692___.png)

点击确定就OK了
![image.png](https://minio.itbug.shop/blog/simple-file/image___1718949603422___.png)

最后拷贝代码到你的文件', '', NULL, 102, 0, true, '2024-06-21 14:02:58.857000');
INSERT INTO blogs (id, title, slug, author, content, html, thumbnail, category_id, view_count, is_published, created_at) VALUES (752, '解决安卓打包编译上的一些坑', 'blog-752', '梁典典', '## 1

报错信息
```bash
 ''compileReleaseJavaWithJavac'' task (current target is 1.8) and ''compileReleaseKotlin'' task (current target is 17) jvm target compatibility should be set to the same Java version
```
解决方案
```gradle
android {
    //添加
    compileOptions {
        sourceCompatibility JavaVersion.VERSION_17
        targetCompatibility JavaVersion.VERSION_17
    }
    //添加
    kotlinOptions {
        jvmTarget = ''17''
    }
}
```

## 2.
报错信息
```bash
You are applying Flutter''s main Gradle plugin imperatively using the apply script method, which is deprecated and will be removed in a future release. Migrate to applying Gradle plugins with the declarative plugins block: https://flutter.dev/go/flutter-gradle-plugin-apply

ERROR: Missing classes detected while running R8. Please add the missing classes or apply additional keep rules that are generated in /Users/ldd/girlmerry/build/flutter_inappwebview_android/outputs/mapping/release/missing_rules.txt.
ERROR: R8: Missing class android.window.BackEvent (referenced from: void io.flutter.embedding.android.FlutterActivity.startBackGesture(android.window.BackEvent) and 3 other contexts)

FAILURE: Build failed with an exception.

* What went wrong:
Execution failed for task '':flutter_inappwebview_android:minifyReleaseWithR8''.
> A failure occurred while executing com.android.build.gradle.internal.tasks.R8Task$R8Runnable
   > Compilation failed to complete

* Try:
> Run with --stacktrace option to get the stack trace.
> Run with --info or --debug option to get more log output.
> Run with --scan to get full insights.
> Get more help at https://help.gradle.org.

BUILD FAILED in 15s
Running Gradle task ''assembleRelease''...                           16.0s
Gradle task assembleRelease failed with exit code 1
```
解决方案
在`build.gradle(android)`下面配置
```gradle
subprojects {
    project.buildDir = \"${rootProject.buildDir}/${project.name}\"
    afterEvaluate { project ->
        //解决gradle8.0+namespace编译失败的问题
        if (project.hasProperty(''android'')) {
            project.android {
                if (namespace == null) {
                    namespace project.group
                }
            }
        }
        //这里
        if (it.name == \"flutter_inappwebview_android\") {
            it.android.buildTypes.release.minifyEnabled = false
        }
    }
}
```
## 3
报错信息
```bash
 flutter build apk

You are applying Flutter''s main Gradle plugin imperatively using the apply script method, which is deprecated and will be removed in a future release. Migrate to applying Gradle plugins with the declarative plugins block: https://flutter.dev/go/flutter-gradle-plugin-apply

ERROR: Missing classes detected while running R8. Please add the missing classes or apply additional keep rules that are generated in /Users/ldd/项目名/build/app/outputs/mapping/release/missing_rules.txt.
ERROR: R8: Missing class com.huawei.android.telephony.ServiceStateEx (referenced from: int com.huawei.hms.framework.common.NetworkUtil.getHwNetworkType(android.content.Context))
Missing class com.huawei.hianalytics.process.HiAnalyticsConfig$Builder (referenced from: void com.huawei.hms.utils.HMSBIInitializer$a.onCallBackSuccess(java.lang.String))
Missing class com.huawei.hianalytics.process.HiAnalyticsConfig (referenced from: void com.huawei.hms.utils.HMSBIInitializer$a.onCallBackSuccess(java.lang.String))
Missing class com.huawei.hianalytics.process.HiAnalyticsInstance$Builder (referenced from: void com.huawei.hms.utils.HMSBIInitializer$a.onCallBackSuccess(java.lang.String))
Missing class com.huawei.hianalytics.process.HiAnalyticsInstance (referenced from: com.huawei.hianalytics.process.HiAnalyticsInstance com.huawei.hms.framework.common.hianalytics.HianalyticsHelper.defaultInstance and 14 other contexts)
Missing class com.huawei.hianalytics.process.HiAnalyticsManager (referenced from: void com.huawei.hms.framework.common.hianalytics.HianalyticsHelper.<init>() and 5 other contexts)
Missing class com.huawei.hianalytics.util.HiAnalyticTools (referenced from: void com.huawei.hms.support.hianalytics.HiAnalyticsUtils.enableLog(android.content.Context))

FAILURE: Build failed with an exception.

* What went wrong:
Execution failed for task '':app:minifyReleaseWithR8''.
> A failure occurred while executing com.android.build.gradle.internal.tasks.R8Task$R8Runnable
   > Compilation failed to complete

* Try:
> Run with --stacktrace option to get the stack trace.
> Run with --info or --debug option to get more log output.
> Run with --scan to get full insights.
> Get more help at https://help.gradle.org.

BUILD FAILED in 1m 17s
Running Gradle task ''assembleRelease''...                           78.3s
Gradle task assembleRelease failed with exit code 1
```
解决方案
把这里输出的内容复制到app的规则文件中

我这里的路径`/Users/ldd/项目名/build/app/outputs/mapping/release/missing_rules.txt`
拷贝到`proguard-rules.pro` 文件末尾解决

## 4 升级到flutter3.24无法打包的问题

在`android/build.gradle`下添加
```gradle
subprojects {
    afterEvaluate { project ->
        if (project.plugins.hasPlugin(\"com.android.application\") ||
                project.plugins.hasPlugin(\"com.android.library\")) {
            project.android {
                compileSdkVersion 34
                buildToolsVersion \"34.0.0\"
            }
        }
    }
}
```', '', NULL, 103, 0, true, '2024-08-01 10:11:04.902000');
INSERT INTO blogs (id, title, slug, author, content, html, thumbnail, category_id, view_count, is_published, created_at) VALUES (802, 'flutter windows配置CMakeLists.txt调用dll库', 'blog-802', '梁典典', '## 新建一个插件

```bash
flutter create --template=plugin_ffi ldd_tsclib --platforms windows
```
`ldd_tsclib`: 插件名称

## 引入dll文件

把dll文件拷贝到插件的根目录下的`windows`文件夹内
![image.png](https://minio.itbug.shop/blog/simple-file/image___1723010578342___.png)

## 配置cmakelists.txt

编辑`ldd_tsclib/windows/CMakeLists.txt`,在末尾加入
```cmake
set(ldd_tsclib_bundled_libraries
  \"${CMAKE_CURRENT_SOURCE_DIR}/TSCLIB.dll\"
  PARENT_SCOPE
)
```
`ldd_tsclib_bundled_libraries`改为: 项目名称_bundled_libraries

配置完编译的时候会把dll自动添加进exe运行文件的同级目录下

配置结束

## 在Dart中使用

加载dll文件
```dart
final DynamicLibrary _tsclib = DynamicLibrary.open(\"TSCLIB.dll\");
```
调用dll里面的函数
```dart
typedef ABOUT_NA = Void Function();//C类型定义
typedef ABOUT = void Function();//dart类型定义

///调用示例,如果about函数存在
void about() {
  final fun = _tsclib.lookupFunction<ABOUT_NA, ABOUT>(\"about\");
  fun();
}
```

传参示例,接收字符串类型,`String.toNativeUtf8()` 是ffi包自带的扩展方法
```dart
typedef OPEN_PORT_NA = Void Function(Pointer<ffi.Utf8> str);
typedef OPEN_PORT = void Function(Pointer<ffi.Utf8> str);

///打开打印机
void openport(String printer) {
  final fun = _tsclib.lookupFunction<OPEN_PORT_NA, OPEN_PORT>(\"openport\");
  fun.call(printer.toNativeUtf8()); // dart 的字符串转成c能识别的Pointer<ffi.Utf8>类型
}

```
', '', NULL, 1, 0, true, '2024-08-07 14:11:27.781000');
INSERT INTO blogs (id, title, slug, author, content, html, thumbnail, category_id, view_count, is_published, created_at) VALUES (852, '解决fastjson2序列化Jpa双向@OneToOne死循环问题', 'blog-852', '梁典典', '## 解决方案

配置序列化
```kotlin
JSONWriter.Feature.ReferenceDetection
```

## example 

```kotlin
        fun getWriterConfig() : FastJsonConfig {
            val config = FastJsonConfig()
            config.setReaderFeatures(JSONReader.Feature.FieldBased, JSONReader.Feature.SupportArrayToBean)
            config.setWriterFeatures(
                JSONWriter.Feature.WriteMapNullValue,
                JSONWriter.Feature.WriteNullBooleanAsFalse,
                JSONWriter.Feature.WriteLongAsString,
                JSONWriter.Feature.WriteNulls,
                JSONWriter.Feature.WriteEnumUsingToString,
                JSONWriter.Feature.ReferenceDetection
            )
            return config
        }
```


```kotlin
    override fun configureMessageConverters(converters: MutableList<HttpMessageConverter<*>>) {
        val converter = FastJsonHttpMessageConverter()
        converter.fastJsonConfig = getWriterConfig()
        converter.defaultCharset = StandardCharsets.UTF_8
        converter.supportedMediaTypes = Collections.singletonList(MediaType.APPLICATION_JSON)
        converters.add(0, converter)
        super.addDefaultHttpMessageConverters(converters)
        super.configureMessageConverters(converters)
    }
```', '', NULL, 2, 0, true, '2024-08-09 10:27:34.264000');
INSERT INTO blogs (id, title, slug, author, content, html, thumbnail, category_id, view_count, is_published, created_at) VALUES (902, 'Rust Sea-ORM 三表联查技巧', 'blog-902', '梁典典', '# 2个左连接,分组去重

sql语句
```sql
SELECT u.id,
       u.avatar,
       u.nick_name,
       u.username,
       GROUP_CONCAT(ur.role_id) AS role_ids,
       GROUP_CONCAT(ro.name) AS role_names
FROM users u
         LEFT JOIN user_role ur ON u.id = ur.user_id
         LEFT JOIN role ro ON ro.id = ur.role_id
GROUP BY u.id;

```
查询结果
![image.png](https://minio.itbug.shop/blog/simple-file/image___1724316540344___.png)

rust写法
```rust
pub async fn find_user_list() -> AppResult<Vec<UserResponse>> {
    let db = get_db();
    let users = Users::find()
        .join_as(JoinType::LeftJoin,users::Relation::UserRole.def(),Alias::new(\"user_role\"))
        .join_as(JoinType::LeftJoin,user_role::Relation::Role.def(),Alias::new(\"role\"))
        .select_only()
        .column(users::Column::Id)
        .column(users::Column::Username)
        .column(users::Column::Avatar)
        .column(users::Column::LastLogin)
        .column(users::Column::NickName)
        .expr_as(Expr::cust(\"GROUP_CONCAT(user_role.role_id)\"),\"role_ids\")
        .expr_as(Expr::cust(\"GROUP_CONCAT(role.name)\"),\"role_names\")
        .group_by(users::Column::Id)
        .into_model::<UserResponse>()
        .all(db).await?;
    Ok(users)
}
```
测试
![image.png](https://minio.itbug.shop/blog/simple-file/image___1724316604930___.png)

## 左连接查询
原生 sql
```sql
select * from permission per left join permission_role pr on pr.role_id == 1 group by per.id
```
sea-orm
```rust
///查找角色对应的权限列表
pub async fn find_permission_list_by_role_id(role_id: i32) -> AppResult<Vec<PermissionResponse>> {
    let db = get_db();
    let p = permission::Entity::find()
        .join(JoinType::LeftJoin, permission::Relation::PermissionRole.def())
        .group_by(permission::Column::Id)
        .all(db).await?;
    Ok(p.into_iter().map(|p| p.into()).collect())
}

```
', '', NULL, 102, 0, true, '2024-08-22 16:50:29.120000');
INSERT INTO blogs (id, title, slug, author, content, html, thumbnail, category_id, view_count, is_published, created_at) VALUES (903, 'flutter使用ldd_systen_listen来监听键盘和扫码枪的原始数据（Rawinput）', 'blog-903', '梁典典', '## 1.安装
将依赖添加进你的项目
```bash
dart pub add ldd_systen_listen
```
pub地址：[ https://pub.dev/packages/ldd_system_listen]( https://pub.dev/packages/ldd_system_listen)

源码: [https://github.com/mdddj/ldd_system_listen](https://github.com/mdddj/ldd_system_listen)

## 2.初始化Libaray
`await initLddSystenListen();`必须要await
```dart
Future<void> main() async {
  await initLddSystenListen();// 添加这行
  runApp(const MyApp());
}
```

## 3.创建键盘设备管理器
所有的api都基于这个类，统领全局操作，只能初始化一次，不能用作全局静态使用，不能在文件顶端进行创建
```
 final manager = LddKeyboardManager(printDebug: true, gunAddEndReturnKey: true); //键盘管理器
```
参数说明：

`printDebug`: 是否在控制台打印debug日志

`gunAddEndReturnKey`: 在扫码枪类型的扫描数据回调中添加return键

## 4.设置键盘类型的输入设备监听（重要API）

> 备注： 它会返回你电脑接入的所有键盘类型的设备列表，hid, 主要用它来区分传统键盘和扫码枪键盘
```dart
 // 返回接入的所有键盘输入设备，包括传统键盘+扫码枪键盘
 List<LddKeyboard> keyboards = manager.getLddKeyboardList();
```
`LddKeyboard `对象包含了你的设备唯一id,它很关键，主要用它来区分数据是扫码枪还是键盘

#### 建议： 需要做一个设置功能，可以叫做《绑定扫码枪》列出上面的设备列表，然后保存这个对象，标识它为扫码枪类型，它在后面一步非常重

## 5.监听键盘或者扫码枪数据 （重要API）

这个函数会在程序中开一个线程，来监听你的输入事件，它没有性能损耗，几乎完美实现
```dart
StreamSubscription<LddRawEvent> stream = manager
        .listenLddKeyboardEvent(gunDevice: keyboards.first)
        .listen(onKeyboardListen);
```
它可以传入一个参数叫`gunDevice`,需要传入一个扫码枪类型的设备，它在上一步的api中获得，我这里为了方便直接传第一个

`onKeyboardListen`函数会回调监听到的按键，如果传了`gunDevice`,会回调扫码枪扫描事件
```dart
  ///监听原始键盘事件
  void onKeyboardListen(LddRawEvent event) {
    event.printInfo();
  }
```
我这里为了方便直接打印。

## 6. 不用了记得销毁监听和释放内存，像这样
```dart
  @override
  void dispose() {
    //销毁监听
    stream?.cancel();
    //释放内存
    manager.dispose();
    super.dispose();
  }
```

## 7.其他

#### 来看看回调的按键对象有哪些(LddRawEvent)
这是回调的定义

它有两种类型的回调
1.传统键盘回调
2.扫码枪键盘回调
```dart

@freezed
sealed class LddRawEvent with _$LddRawEvent {
  const LddRawEvent._();
  const factory LddRawEvent.lddKeyboardEvent(
    BigInt field0,
    LddKeyId field1,
    LddState field2,
    LddKeyboard field3,
  ) = LddRawEvent_LddKeyboardEvent;
  const factory LddRawEvent.scanGunEvent(
    List<LddKeyId> field0,
    LddKeyboard field1,
  ) = LddRawEvent_ScanGunEvent;
}
```

#### 属性说明（传统）：

`field0`: 设备的下标，也就是getLddKeyboardList()函数返回列表的下标，可以用来标识触发的设备

`field1`: 键盘按下的键，是个枚举

`field2`: 它有两种状态，一个按下，一个松开

`field3`: 触发的键盘设备对象


#### 属性说明（扫码枪）：

`field0`: 扫描到的数据列表

`field1`: 触发扫码枪的设备对象

然后看看打印的扩展函数，像这样使用
```dart
void printInfo() {
    when(
      lddKeyboardEvent: (field0, field1, field2, field3) {
        print(\"普通键盘事件:${field1.keyIdToString()},类型:${field2.formatString()}\");
      },
      scanGunEvent: (field0, field1) {
        print(\"扫码枪事件:${field0.map((item) => item.keyIdToString())}\");
      },
    );
  }
```

## 完整的代码
`main.dart`
```dart
import ''dart:async'';

import ''package:flutter/material.dart'';
import ''package:ldd_system_listen/api/entitys.dart'';
import ''package:ldd_system_listen/api/multiinput.dart'';
import ''package:ldd_system_listen/ldd_system_listen.dart'';

Future<void> main() async {
  await initLddSystenListen();
  runApp(const MyApp());
}

class MyApp extends StatefulWidget {
  const MyApp({super.key});

  @override
  State<MyApp> createState() => _MyAppState();
}

class _MyAppState extends State<MyApp> {
  final manager =
      LddKeyboardManager(printDebug: true, gunAddEndReturnKey: true); //初始化键盘管理器
  List<LddKeyboard> keyboards = []; //电脑连接的设备列表
  StreamSubscription<LddRawEvent>? stream; //监听键盘事件流
  @override
  void initState() {
    super.initState();
    Future.microtask(init);
  }

  ///初始化键盘管理器
  void init() {
    manager.register(); //注册键盘监听事件
    keyboards = manager.getLddKeyboardList(); //获取键盘设备列表，包括传统键盘，扫码枪等特殊键盘
    setState(() {}); //刷新ui

    stream ??= manager
        .listenLddKeyboardEvent(gunDevice: keyboards.first)
        .listen(onKeyboardListen);
  }

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      home: Scaffold(
        appBar: AppBar(
          title: const Text(\"键盘测试\"),
        ),
        body: SingleChildScrollView(
          child: Column(
            children: [
              if (keyboards.isEmpty) const Text(''没有检测到键盘设备''),
              ...keyboards.map((item) {
                return Card(
                  child: ListTile(
                    title: Text(item.name),
                    subtitle: Text(item.serial ?? \"-\"),
                  ),
                );
              })
            ],
          ),
        ),
      ),
    );
  }

  ///监听原始键盘事件
  void onKeyboardListen(LddRawEvent event) {
    event.printInfo();
  }

  @override
  void dispose() {
    //销毁监听
    stream?.cancel();
    //释放内存
    manager.dispose();
    super.dispose();
  }
}

```
', '', NULL, 1, 0, true, '2024-08-28 17:01:22.246000');
INSERT INTO blogs (id, title, slug, author, content, html, thumbnail, category_id, view_count, is_published, created_at) VALUES (904, 'flutter_rust_bridge在控制台打印日志', 'blog-904', '梁典典', '## 添加日志相关依赖
```toml
lazy_static = \"1.5.0\"
log = \"0.4.22\"
parking_lot = \"0.12.3\"
simplelog = {version=\"0.12.2\",futures=[\"time\"]}
time = \"0.3.36\"
anyhow = \"1.0.86\"
```

## 创建`entitys.rs`文件
```rust
pub struct LogEntry {
    pub time_millis: i64,
    pub level: i32,
    pub tag: String,
    pub msg: String,
}

```

## 创建`log.rs`文件

```rust
use std::sync::Once;
use std::time::{Duration, SystemTime, UNIX_EPOCH};


use lazy_static::lazy_static;
use log::{error, info, warn, LevelFilter, Log, Metadata, Record};
use parking_lot::RwLock;
use simplelog::*;
use crate::frb_generated::StreamSink;

use super::entitys::LogEntry;

pub fn create_log_stream(s: StreamSink<LogEntry>) -> anyhow::Result<()> {
    SendToDartLogger::set_stream_sink(s);
    Ok(())
}

pub fn rust_set_up() {
    init_logger();
}


static INIT_LOGGER_ONCE: Once = Once::new();

pub fn init_logger() {
    // https://stackoverflow.com/questions/30177845/how-to-initialize-the-logger-for-integration-tests
    INIT_LOGGER_ONCE.call_once(|| {
        let level = if cfg!(debug_assertions) {
            LevelFilter::Debug
        } else {
            LevelFilter::Warn
        };

        assert!(
            level <= log::STATIC_MAX_LEVEL,
            \"Should respect log::STATIC_MAX_LEVEL={:?}, which is done in compile time. level{:?}\",
            log::STATIC_MAX_LEVEL,
            level
        );

        CombinedLogger::init(vec![
            Box::new(SendToDartLogger::new()),
            Box::new(MyMobileLogger::new()),
            // #[cfg(not(any(target_os = \"android\", target_os = \"ios\")))]
            TermLogger::new(
                level,
                ConfigBuilder::new()
                    .set_time_format_custom(format_description!(\"[hour]:[minute]:[second].[subsecond]\"))
                    .build(),
                TerminalMode::Mixed,
                ColorChoice::Auto,
            ),
        ])
        .unwrap_or_else(|e| {
            error!(\"init_logger (inside ''once'') has error: {:?}\", e);
        });
        info!(\"init_logger (inside ''once'') finished\");

        warn!(
            \"init_logger finished, chosen level={:?} (deliberately output by warn level)\",
            level
        );
    });
}

lazy_static! {
    static ref SEND_TO_DART_LOGGER_STREAM_SINK: RwLock<Option<StreamSink<LogEntry>>> =
        RwLock::new(None);
}

pub struct SendToDartLogger {
  
}

impl SendToDartLogger {
    pub fn set_stream_sink(stream_sink: StreamSink<LogEntry>) {
        let mut guard = SEND_TO_DART_LOGGER_STREAM_SINK.write();
        let overriding = guard.is_some();

        *guard = Some(stream_sink);

        drop(guard);

        if overriding {
            warn!(
                \"SendToDartLogger::set_stream_sink but already exist a sink, thus overriding. \\
                (This may or may not be a problem. It will happen normally if hot-reload Flutter app.)\"
            );
        }
    }

    pub fn new() -> Self {
        SendToDartLogger {
           
         }
    }

    fn record_to_entry(record: &Record) -> LogEntry {
        let time_millis = SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .unwrap_or_else(|_| Duration::from_secs(0))
            .as_millis() as i64;

        let level = match record.level() {
            Level::Trace => Self::LEVEL_TRACE,
            Level::Debug => Self::LEVEL_DEBUG,
            Level::Info => Self::LEVEL_INFO,
            Level::Warn => Self::LEVEL_WARN,
            Level::Error => Self::LEVEL_ERROR,
        };

        let tag = record.file().unwrap_or_else(|| record.target()).to_owned();

        let msg = format!(\"{}\", record.args());

        LogEntry {
            time_millis,
            level,
            tag,
            msg,
        }
    }

    const LEVEL_TRACE: i32 = 5000;
    const LEVEL_DEBUG: i32 = 10000;
    const LEVEL_INFO: i32 = 20000;
    const LEVEL_WARN: i32 = 30000;
    const LEVEL_ERROR: i32 = 40000;
}

impl Log for SendToDartLogger {
    fn enabled(&self, _metadata: &Metadata) -> bool {
        true
    }

    fn log(&self, record: &Record) {
        let entry = Self::record_to_entry(record);
        if let Some(sink) = &*SEND_TO_DART_LOGGER_STREAM_SINK.read() {
            let _ =  sink.add(entry);
        }
    }

    fn flush(&self) {
        // no need
    }
}

impl SharedLogger for SendToDartLogger {


    fn config(&self) -> Option<&Config> {
        None
    }

    fn as_log(self: Box<Self>) -> Box<dyn Log> {
        Box::new(*self)
    }
    
    fn level(&self) -> LevelFilter {
        LevelFilter::Debug
    }
}

pub struct MyMobileLogger {

    #[cfg(target_os = \"ios\")]
    ios_logger: oslog::OsLogger,
}

impl MyMobileLogger {
    pub fn new() -> Self {
        MyMobileLogger {
        
            #[cfg(target_os = \"ios\")]
            ios_logger: oslog::OsLogger::new(\"vision_utils_rs\"),
        }
    }
}

impl Log for MyMobileLogger {
    fn enabled(&self, _metadata: &Metadata) -> bool {
        true
    }

    #[allow(unused_variables)]
    fn log(&self, record: &Record) {
        #[cfg(any(target_os = \"android\", target_os = \"ios\"))]
        let modified_record = {
            let override_level = Level::Info;

            record.to_builder().level(override_level).build()
        };

        #[cfg(target_os = \"android\")]
        android_logger::log(&modified_record);

        #[cfg(target_os = \"ios\")]
        self.ios_logger.log(&modified_record);
    }

    fn flush(&self) {
        // no need
    }
}

impl SharedLogger for MyMobileLogger {
    fn level(&self) -> LevelFilter {
        LevelFilter::Debug
    }

    fn config(&self) -> Option<&Config> {
        None
    }

    fn as_log(self: Box<Self>) -> Box<dyn Log> {
        Box::new(*self)
    }
}
```

# 初始化日志
```rust
rust_set_up();
```

# 在flutter端监听日志
```dart
  void listenLog() {
    createLogStream().listen((log) {
      print(\"log ...\");
    });
  }
```

## 参考
[github issis](https://github.com/fzyzcjy/flutter_rust_bridge/issues/486)', '', NULL, 102, 0, true, '2024-08-29 16:57:07.973000');
INSERT INTO blogs (id, title, slug, author, content, html, thumbnail, category_id, view_count, is_published, created_at) VALUES (905, 'c++中的 lambda函数', 'blog-905', '梁典典', '一开始的变量捕获不太懂,写一遍就好理解了
```c++

#include <vector>
#include <algorithm>
#include <iostream>
using namespace std;

class Test {
public:
    void hello() {
        cout << \"test hello\" << endl;
    }


    void lambda() {
        auto fun = [this] { //捕获 this
            this->hello();
            };
        fun();
    }
};

int main() {


    std::vector<int> numbers = { 1,2,3,4,5 };
    std::for_each(numbers.begin(), numbers.end(), [](int x) {
        std::cout << \"下标x is \" << x << \" ;\" << std::endl;
        });



    auto sum = [](int a, int b) -> int {
        return a + b;
        };


    std::cout << sum(1, 3) << std::endl;


    ///捕获外部变量
    /**
     * 捕获外部变量,2 种方式
     * 1. 值捕获: 通过值拷贝外部变量
     * 2. 引用捕获: 通过引用捕获外部变量
     */

    int x = 10;

    auto lambda = [x]() {
        std::cout << \"x ====\" << x << std::endl;
        };
    lambda();//应该输出 10


    auto lambda_ref = [&x]() {
        x = 20;
        };
    lambda_ref();

    std::cout << x << std::endl;//输出 20

    ///经典的 lambda 排序
    std::vector<int> my_numbers = { 1,2,77,43,400,5,98,1 };
    std::sort(my_numbers.begin(), my_numbers.end(), [](int a, int b) {
        return a < b;
        });

    for (int i = 0; i < my_numbers.size(); i++)
    {
        std::cout << \"value is \" << my_numbers[i] << std::endl;
    }



    ///使用=来捕获外部的所有变量,会把外部的所有变量拷贝一份到 lambda内部
    ///格式大概像这样
    int my_i = 100;
    auto fun_my_i = [=] {
        std::cout << \"fun_my_i i is \" << my_i << std::endl;
        };


    ///引用的用[&],所有外部变量皆可引用
    int my_i_2 = 100;
    auto fun_my_i_2 = [&] {
        std::cout << \"my_i_2 is \" << &my_i_2 << std::endl;
        };

    ///复制并引用捕获

    int a1 = 100, a2 = 200;
    std::cout << \"a1=\" << a1 << std::endl;
    cout << \"a2=\" << a1 << endl;

    //这里是所有变量拷贝一份,a2则使用引用
    auto fun_a = [=, &a2] {
        std::cout << \"a1=\" << &a1 << std::endl;
        cout << \"a2=\" << &a1 << endl;
        };

    fun_a();

    //引用或者复制
    int b1 = 100, b2 = 200;
    cout << \"b1 =\" << b1 << endl;
    cout << \"b2 = \" << b2 << endl;
    auto fun_b = [b1] {
        cout << \"b1==\" << b1 << \",b1=(引用)\" << &b1 << endl;
        };
    fun_b();


    /// this类型的捕获
    Test test;
    test.lambda();


    return 0;
}



```

输出

```bash
$ 函数
下标x is 1 ;
下标x is 2 ;
下标x is 3 ;
下标x is 4 ;
下标x is 5 ;
4
x ====10
20
value is 1
value is 1
value is 2
value is 5
value is 43
value is 77
value is 98
value is 400
a1=100
a2=100
a1=0x16bb08de0
a2=0x16bb08de0
b1 =100
b2 = 200
b1==100,b1=(引用)0x16bb08dcc
test hello
```', '', NULL, 52, 0, true, '2024-09-09 10:40:21.903000');
INSERT INTO blogs (id, title, slug, author, content, html, thumbnail, category_id, view_count, is_published, created_at) VALUES (906, 'c++中的字符串操作', 'blog-906', '梁典典', '中文那里有点坑,需要注意
```c++
#include <iostream>
#include <string>
#include <sstream>

using namespace std;

void print_lines();
void print_lines() {
    cout << \"------------\" << endl;
}


void print_str(const std::string str);
void print_str(const std::string str) {
    cout << \"字符串:\" << str << endl;
}


void print_string_funs(std::string& str);

///常用的字符串函数 添加&引用类型,才能修改 str的原始数据
void print_string_funs(std::string& str) {
    int size = str.size();//字符串长度
    bool is_empty = str.empty();//是否为空
    char str_char = str[0]; //取下标字符
    std::string sub_str = str.substr(0, 1);//取值
    int find_index = str.find(\"梁\");//取下标,没找到返回-1
    std::string new_string = str.replace(0, 1, \"test\");//从位置 0 开始,替换后面 1 个字符为 test
    print_str(new_string);
    cout << \"字符长度:\" << size << endl;
    cout << \"是否为空:\" << is_empty << endl;
    cout << \"取下标 0 的char:\" << str_char << endl;
    cout << \"取指定位置:\" << sub_str << endl;
    cout << \"取下标梁的位置:\" << find_index << endl;

    print_lines();

    char char_2 = str.at(0);//取下标值,带边界检查,超出范围会报错: libc++abi: terminating due to uncaught exception of type std::out_of_range: basic_string
    cout << \"查找字符(带边界检查) char 2: \" << char_2 << endl;

    print_str(str);
    //从尾巴查找字符下标
    int index_r = str.rfind(\"梁\");
    cout << \"从尾巴开始查找下标:\" << index_r << \".\" << endl;

    //在尾巴添加一个新的字符串
    std::string new_append_string = new_string.append(\"梁典典....\");

    print_str(\"尾巴插入字符串: \" + new_append_string);

    //在指定位置插入字符串
    std::string new_insert_string = new_append_string.insert(0, string(\"欢迎来到 c++的世界\"));
    print_str(string(\"指定位置插入字符串:\") + new_insert_string);

    //删除指定位置的字符串
    new_insert_string = new_insert_string.erase(0, 1);
    print_str(string(\"删除指定位置的字符串:\") + new_insert_string);

    //清空
    new_insert_string.clear();

    print_str(string(\"清空后:\") + new_insert_string);


    new_insert_string = std::string(\"你好,梁典典,梁梁梁\");
    print_str(string(\"重新设置字符串\") + new_insert_string);

    //c风格的字符串
    const char* c_string = new_insert_string.c_str();
    print_str(c_string);

    print_lines();
    //返回指向字符数据的指针
    const char* poi = new_insert_string.data();
    cout << \"返回指向字符数据的指针:\" << poi << endl;
    print_lines();
    ///判断是否相等
    int is_eq = new_insert_string.compare(\"你\");//返回 0 相等,大于 1 不一样
    cout << \"是否相等:\" << is_eq << endl;
    print_lines();
    //查找第一个匹配的位置
    print_str(new_insert_string);
    int pos = new_insert_string.find_first_of(\"梁\");
    cout << \"查找梁的第一个匹配下标\" << pos << \",字符串大小:\" << new_insert_string.size() << endl;

    print_lines();



}



void string_num_funs();
/// 字符串和数字之间的转换
void string_num_funs() {


    //读取字符串中的数字
    string data = \"100 100.5\";
    std::istringstream iss(data);
    int i;
    double d;
    iss >> i >> d;
    cout << \"int value:\" << i << endl; // 100
    cout << \"doubel value:\" << d << endl; // 100.5
    /**
     * int value:100
     * doubel value:100.5
     */

     //数字转字符串

    std::ostringstream ss;
    int a = 100;
    double b = 100.5;
    ss << \"哈哈\" << i << \"  \" << d;
    string result = ss.str();
    cout << \"result string is:\" << result << endl;//result string is:哈哈100  100.5

    //同时读写的例子
    string my_data_string = \"100,200.2\";
    stringstream ss2(data);

    int i2;
    int d2;
    //从my_data_string读取数据
    ss2 >> i2 >> d2;
    cout << \"i2=\" << i2 << \",d2=\" << d2 << endl; //i2=100,d2=100

    //向stringstream写入数据
    ss2.str(\"\");
    ss2 << \"new ss2 data:\" << 50 << \" \" << 90.1;
    string new_data_string_is = ss2.str();
    cout << \"new data string is:\" << new_data_string_is << endl;//new data string is:new ss2 data:50 90.1
}


int main() {

    //声明字符串变量
    std::string my_string;


    //初始化字符串变量
    std::string my_str = \"hello,梁典典\";

    //使用+链接字符串
    std::string str1 = \"hello\";
    std::string str2 = \"梁典典\";

    std::string full = str1 + str2;


    print_string_funs(full);

    cout << \"full string is : \" << full << endl;
    print_lines();
    string_num_funs();

    return 0;
}
```
输出
```bash
$ string
字符串:testello梁典典
字符长度:14
是否为空:0
取下标 0 的char:h
取指定位置:h
取下标梁的位置:5
------------
查找字符(带边界检查) char 2: t
字符串:testello梁典典
从尾巴开始查找下标:8.
字符串:尾巴插入字符串: testello梁典典梁典典....
字符串:指定位置插入字符串:欢迎来到 c++的世界testello梁典典梁典典....
字符串:删除指定位置的字符串:��迎来到 c++的世界testello梁典典梁典典....
字符串:清空后:
字符串:重新设置字符串你好,梁典典,梁梁梁
字符串:你好,梁典典,梁梁梁
------------
返回指向字符数据的指针:你好,梁典典,梁梁梁
------------
是否相等:1
------------
字符串:你好,梁典典,梁梁梁
查找梁的第一个匹配下标7,字符串大小:26
------------
full string is : testello梁典典
------------
int value:100
doubel value:100.5
result string is:哈哈100  100.5
i2=100,d2=100
new data string is:new ss2 data:50 90.1
```', '', NULL, 52, 0, true, '2024-09-10 11:51:47.032000');
INSERT INTO blogs (id, title, slug, author, content, html, thumbnail, category_id, view_count, is_published, created_at) VALUES (907, 'c++里面的标准库,信号,字符串操作,命名空间,map,set,模板引擎,异常处理,异步future等', 'blog-907', '梁典典', '## cstdlib
```c++

#include <cstdlib>
#include <ctime>
#include <iostream>
using namespace std;
/**
 * 标准库操作
 */
int main() {


    //分配指定大小的内存
    int* ptr = (int*)malloc(10 * sizeof(int));
    cout << \"ptr: \" << ptr << endl;
    if (ptr == NULL) {
        cout << \"分配内存失败了\" << endl;
        exit(-1);
    }

    for (int i = 0; i < 10; i++) {
        ptr[i] = i * 1;//使用内存
    }
    for (int i = 0; i < 10; i++) {
        cout << \"i=\" << ptr[i] << endl;
    }

    //释放内存
    free(ptr);


    //atoi,atof 将字符串转数字和浮点数

    string a = \"111\";
    string b = \"100.11\";

    int aInt = atoi(a.c_str());
    double bDouble = atof(b.c_str());
    cout << \"a=\" << aInt << \",b=\" << bDouble << endl;



    //rand,srand 函数
    srand(time(nullptr));
    for (int i = 0;i < 5;i++) {
        cout << rand() % 100 << \" \";//0-99随机数
    }
    cout << endl;


    //执行一个命令行字符串
    system(\"kdoctor\");

    //终止程序,返回状态码
    exit(0);

    return 0;
}
```

## exception
```c++
#include <iostream>
#include <exception>
using namespace std;


double test(int a);
double test(int a) {
    if (a == 0) {
        throw \"a不能等于0\";
    }
    return a;
}


/**
 * 继承exception来定义新的异常
 * const throw: 异常规格说明,表名里面会抛出异常,不写可以抛出任何的异常
 */
struct MyException : public exception {
    const char* what() const throw () {
        return \"发现梁典典异常\";
    }
};



/**
 * 有三个关键字
 * try catch throw
 * throw: 有问题,通过它来抛出异常
 * catch: 捕获异常
 * try: 块中的代码被激活特定异常,后面可以跟随多个catch块
 */
int main() {
    try {
        test(1);
    }
    catch (const char* msg) {
        std::cout << msg << std::endl;
    }


    try {
        throw MyException();
    }
    catch (MyException& e) {
        cout << \"进入自定义异常\" << endl;
        cout << e.what() << endl;
    }
    catch (std::exception& e) {
        cout << \"出现其他错误\" << endl;
    }

    return 0;
}
```

## future
```c++

#include <iostream>
#include <future>
using namespace std;

/**
 *  future: 异步操作的结果,支持查询操作的状态,读取结果,等待完成
 *  promise: 和future结合使用,设置异步操作的结果
 *  packaged_task: 封装函数和对象,使其可以异步任务执行
 */
int main() {

    promise<int> my_promise;
    future<int> wait_future = my_promise.get_future();

    // 使用 std::move 将 promise 移动到线程内部
    thread my_thread([p = std::move(my_promise)]() mutable {
        p.set_value(1);
        });

    cout << \"结果: \" << wait_future.get() << endl;

    my_thread.join();

    return 0;
}
```

## map
```c++

#include <map>
#include <iostream>
using namespace std;

/**
 * 头文件: <map>
 * 1.map: 键值对,每个键都是唯一的
 * 2.元素都是按照键的顺序自动排序的,升序
 * 3.每个键只能出现一次
 * 4.提供了双向迭代器,支持向前,向后遍历元素
 */

int main() {

    map<string, int> devs;
    devs[\"c++\"] = 1;
    devs[\"java\"] = 2;
    devs[\"c\"] = 3;
    devs[\"test\"] = 4;


    //遍历
    for (std::map<string, int>::iterator it = devs.begin();it != devs.end();++it) {
        cout << it->first << \" is \" << it->second << \"\" << endl;
    }


    //检查键是否存在
    bool is_exit = devs.find(\"dev\") != devs.end();
    if (is_exit) {
        cout << \"已存在\" << endl;
    }

    //删除元素
    int count = devs.erase(\"test\");//返回1:成功,0不成功
    cout << \"count is:\" << count << endl;

    //获取大小
    int size = devs.size();
    cout << \"map 的大小is:\" << size << endl;

    //清空
    devs.clear();



    return 0;
}
```

## namespace
```c++
#include <iostream>

using namespace std;
using std::cout;//某个函数,不需要namespace

namespace myfuns {
    void func() {
        cout << \"my funs func\" << std::endl;
    }
}

namespace tools {
    void func2() {
        cout << \"my tool func\" << std::endl;
    }
}


///还能有嵌套
namespace a {


    int a = 1;
    void funa() {
        cout << \"a fun :\" << a << endl;
    }
    namespace b {
        void bfun() {
            a = 10;
            cout << \"b fun\" << a << endl;
        }
    }
}

//使用using 告诉编译器,后面的代码使用指定的命名空间的名称
using namespace a::b;
using namespace tools;
int main() {


    //正常调用
    myfuns::func();
    tools::func2();
    func2();
    bfun();

    return 0;
}
```

## set
```c++
#include <unordered_set>
#include <iostream>
using namespace std;
/**
 * unordered_set:存储唯一元素的集合,不保证元素排序,这点和set不同,可以用作更快的查找,插入,删除操作
 *
 */

int main() {

    unordered_set<int> my_set;

    my_set.insert(100);
    my_set.insert(200);
    my_set.insert(300);

    cout << \"element is in my set\";
    for (int ele : my_set) {
        cout << ele << \" \";
    }

    cout << endl;


    ///查找元素
    auto it = my_set.find(100);
    if (it != my_set.end()) {
        cout << \"找到了200元素\" << endl;
    }
    else {
        cout << \"200元素没有找到\" << endl;
    }

    //删除元素
    int is_delete = my_set.erase(200);
    if (is_delete == 1) {
        cout << \"删除成功\" << endl;
    }
    else {
        cout << \"删除失败了\" << endl;
    }

    //获取大小和检查是否为空
    int size = my_set.size();
    bool is_empty = my_set.empty();

    cout << \"大小:\" << size << \",是否为空\" << is_empty << endl;


    //清空
    my_set.clear();

    cout << \"是否为空?\" << (my_set.empty() ? \"yes\" : \"no\") << endl;
    return 0;
}
```
## singnal
```c++
#include <iostream>
#include <csignal>
#include <unistd.h>
using namespace std;



void mySingnalHandle(int  signum) {
    cout << \"中断信号:\" << signum << endl;
    exit(signum);
}

/**
 * 使用raise来生成信号
 */
void mySingalHanlde2(int signum) {
    cout << \"2.中断信号:\" << signum << endl;
    exit(signum);
}





/**
 * 信号处理
 */
int main() {

    ///注册信号
    signal(5, mySingalHanlde2);
    // while (1)
    // {
    //     cout << \"睡眠...\" << endl;
    //     sleep(1);
    // }

    int i = 1;

    while (++i)
    {
        cout << \"睡眠\" << endl;
        if (i == 5) {
            raise(i);
        }
        sleep(1);
    }


    return 0;
}
```

## template
```c++
#include <iostream>
#include <string>
#include <vector>
using namespace std;

/**
 * 函数模板
 * template <typename type> return-type func-name(parameter list)
 */
template <typename T>
inline T const& Max(T const& a, T const& b) {
    return a < b ? b : a;
}

/**
 * 类模板
 * template <class type> class class-name{}
 */

template <class T>
class Stack {
private:
    vector<T> elems; //元素列表
public:
    void push(T const&);//入
    void pop(); //出
    T top() const; //顶部元素
    bool empyu() const {
        return elems.empty();
    }
};

template <class T>
void Stack<T>::push(T const& elem) {
    this->elems.push_back(elem);
}

template <class T>
void Stack<T>::pop() {
    if (elems.empty()) {
        throw out_of_range(\"Stack<>::pop:empty stack\");
    }
    //删除最后一个元素
    this->elems.pop_back();
}

template <class T>
T Stack<T>::top() const {
    if (this->elems.empty()) {
        throw out_of_range(\"Stack<>::pop:empty stack\");
    }
    return this->elems.back();//返回最后一个元素
}





int main() {


    int a = 1;
    int b = 2;
    cout << \"Max(a,b)\" << Max(a, b) << endl;

    int a2 = 12.4;
    int b2 = 99.0;
    cout << \"Max(a2,b2)\" << Max(a2, b2) << endl;


    string a3 = \"dasdas\";
    string b3 = \"tetesgf\";

    cout << \"Max(a3,b3)\" << Max(a3, b3) << endl;


    try {

        Stack<int> int_stack;
        Stack<string> string_stack;

        int_stack.push(1);

        cout << int_stack.top() << endl;

        string_stack.push(\"梁典典\");
        cout << string_stack.top() << endl;

        string_stack.pop();
        string_stack.pop();
    }
    catch (exception const& ex) {
        cerr << \"exception is \" << ex.what() << endl;
        return -1;
    }

    return 0;
}
```', '', NULL, 52, 0, true, '2024-09-12 11:12:04.199000');
INSERT INTO blogs (id, title, slug, author, content, html, thumbnail, category_id, view_count, is_published, created_at) VALUES (908, 'c++基础之cassert,cfloat,climits,codecvt,cwchar,local,memory,new,random', 'blog-908', '梁典典', '## cassert - 断言
```c++
#include <cassert>
#include <iostream>
/**
 * 断言
 * false: 程序中止,程序中止执行
 */
int main() {
    int a = 7;
    int b = 2;
    assert(a > b);// true:继续正常执行
    std::cout << \"a需要大于b\" << std::endl;

    //高级用法
    int x = 1;
    int y = 2;
    assert(y == 0 && \"y需要=0\");
    std::cout << \"结束.\" << std::endl;

    return 0;
}
```
输出
```bash
$ ./cassert
a需要大于b
Assertion failed: (y == 0 && \"y需要=0\"), function main, file cassert.cpp, line 16.
[1]    74755 abort      ./cassert
```

## cfloat - 浮点数
```c++
#include <iostream>
#include <string>
#include <cfloat>
#include <cmath>
using namespace std;
/**
 * 浮点数
 * float: 单精度浮点数,占用4字节
 * double: 双精度浮点数,占用8个字节
 */
int main() {
    float f = 3.14f;
    double d = 2.334;


    ///输出float范围和精度
    cout << \"float:\
\";
    cout << \"Min:\" << FLT_MIN << \"\
\";
    cout << \"Max:\" << FLT_MAX << \"\
\";
    cout << \"Epsilon:\" << FLT_EPSILON << \"\
\";
    cout << \"Digits:\" << FLT_DIG << \"\
\";

    ///double
    cout << \"\
double:\
\";
    cout << \"min:\" << DBL_MIN << \"\
\";
    cout << \"max:\" << DBL_MAX << \"\
\";
    cout << \"epsilon:\" << DBL_EPSILON << \"\
\";
    cout << \"digits:\" << DBL_DIG << \"\
\";

    /// long double
    cout << \"\
long double:\
\";
    cout << \"min:\" << LDBL_MIN << \"\
\";
    cout << \"max:\" << LDBL_MAX << \"\
\";
    cout << \"epsilon:\" << LDBL_EPSILON << \"\
\";
    cout << \"digits:\" << LDBL_DIG << \"\
\";

    /**
     * float:
Min:1.17549e-38
Max:3.40282e+38
Epsilon:1.19209e-07
Digits:6

double:
min:2.22507e-308
max:1.79769e+308
epsilon:2.22045e-16
digits:15

long double:
min:2.22507e-308
max:1.79769e+308
epsilon:2.22045e-16
digits:15
     */


     ///使用cmath函数来操作
    double num = 9.0;
    double root = sqrt(num);//求平方根
    double power = pow(2.0, 3.0);//计算2的3次幂
    cout << \"root is :\" << root << endl; // =3
    cout << \"power is : \" << power << endl;//=8
    return 0;
}
```
输出
```bash
$ ./cfloat 
float:
Min:1.17549e-38
Max:3.40282e+38
Epsilon:1.19209e-07
Digits:6

double:
min:2.22507e-308
max:1.79769e+308
epsilon:2.22045e-16
digits:15

long double:
min:2.22507e-308
max:1.79769e+308
epsilon:2.22045e-16
digits:15
root is :3
power is 8
```
## climits - 限制
```c++
#include <iostream>
#include <climits>
using namespace std;
/**
 * 这个是和整数相关的限制和特性
 *
 */
int main() {
    cout << \"int最大值:\" << INT_MAX << endl;
    cout << \"int最小值:\" << INT_MIN << endl;

    cout << \"long最大值:\" << LONG_MAX << endl;
    cout << \"long最小值:\" << LONG_MIN << endl;

    cout << \"unsigned long最大值:\" << ULONG_MAX << endl;

    cout << \"char 最小值:\" << CHAR_MIN << endl;
    cout << \"char 最大值:\" << CHAR_MAX << endl;
    cout << \"char bit 位\" << CHAR_BIT << endl;

    /**
     * int最大值:2147483647
    int最小值:-2147483648
    long最大值:9223372036854775807
    long最小值:-9223372036854775808
    unsigned long最大值:18446744073709551615
    char 最小值:-128
    char 最大值:127
    char bit 位8
     */
    return 0;
}
```
输出
```bash
$ ./climits
int最大值:2147483647
int最小值:-2147483648
long最大值:9223372036854775807
long最小值:-9223372036854775808
unsigned long最大值:18446744073709551615
char 最小值:-128
char 最大值:127
char bit 位8
```
## codecvt - 字符转换工具
```c++

#include <iostream>
#include <codecvt>
#include <locale>
#include <string>
using namespace std;
/**
 * 字符转换工具
 */
int main() {


    //基于名称的转换器
    wstring_convert<codecvt_byname<wchar_t>> converter(\"zh_CN.UTF-8\");

    // wstring_convert<codecvt_utf8_utf16<wchar_t>> converter;

    //原始字符串
    string narrow_string = \"梁典典\";

    //转换utf-16宽字符串
    wstring wide_string = converter.from_bytes(narrow_string);
    wcout << L\"宽字符串:\" << wide_string << endl;
    //转回uft8字符串
    string onverted_string = converter.to_bytes(wide_string);
    cout << \"转回来了:\" << onverted_string << endl;

    return 0;
}
```
输出
```bash
转回来了:梁典典
```
## cwchar - 宽字符和宽字符串
```c++
#include <iostream>
#include <cwchar>
#include <locale>
using namespace std;

/**
 * 提供处理宽字符wchar_t和宽字符串的函数
 * 输入输出
 * 内存操作
 * 字符串操作
 *
 * wchar_t: 宽字符类型,存储宽字符
 * wint_t: 存储宽字符函数的返回值
 *
 * fgetwc: 文件流读取宽字符
 * fputwc: 向文件流写入宽字符
 * fgetws: 文件流读取宽字符串
 * fputws: 向文件流写入宽字符串
 *
 * 主要用途：

    •	处理多字节编码字符集（例如 Unicode）。
    •	开发国际化应用程序时，通过 wchar_t 处理各国语言的字符。

    对于需要处理不同语言的应用，宽字符提供了更好的支持，能够处理比 ASCII 更多的字符编码。
 */
int main() {

    setlocale(LC_ALL, \"zh_CN.UTF-8\");//设置本地化
    const wchar_t* filename = L\"示例.txt\";
    FILE* file = fopen(\"示例.txt\", \"w\");
    cout << \"file:\" << file << endl;
    if (file) {
        fputws(L\"你好,梁典典!\
\", file);
        fclose(file);
    }
    wprintf(L\"测试\");
    file = fopen(\"示例.txt\", \"r\");
    cout << \"读文件:\" << file << endl;
    if (file) {
        wchar_t buffer[256];
        if (fgetws(buffer, 256, file)) {
            wcout << \"从文件中读取\" << buffer << \".\" << endl;
        }
        else {
            wcout << L\"读取失败了.\" << endl;
        }
        fclose(file);
    }
    else {
        cout << \"读文件失败.\" << endl;
    }

    ///这里读取不到文件,不知道啥情况

    /**
     * 宽字符和宽字符串操作
     * wcscpy: 拷贝宽字符串
     * wcslen,获取宽字符串的长度
     * wcscmp: 比较宽字符串
     * wcsncpy: 拷贝指定长度的宽字符串
     */

    wchar_t str1[100] = L\"梁典典\";
    wchar_t str2[100] = L\"你好\";

    ///宽字符串拷贝
    wcscpy(str1, L\"你好啊梁典典\");
    wcout << L\"拷贝狂字符串:\" << str1 << endl;

    ///宽字符串长度
    size_t len = wcslen(str1);
    wcout << L\"长度:\" << len << endl;

    ///比较
    int result = wcscmp(str1, str2);
    wcout << L\"比较结果:\" << result << endl;

    ///部分拷贝,
    wcsncpy(str2, str1, 5);
    str2[5] = L''\\0'';
    wcout << \"部分字符串拷贝:\" << str2 << endl;


    /**
     * 宽字符分类和转换
     */

     //拍判断是不是字母
    wchar_t ch = L''A'';
    if (iswalpha(ch)) {
        wcout << ch << L\"是字母\" << endl;
    }
    //判断是不是数字
    ch = L''9'';
    if (iswdigit(ch)) {
        wcout << ch << L\"是数组\" << endl;
    }

    //转小写
    ch = L''G'';
    wchar_t lower_ch = towlower(ch);
    wcout << L\"转写:\" << lower_ch << endl;

    ch = L''g'';
    wchar_t upper_ch = towupper(ch);
    wcout << L\"转大写:\" << upper_ch << endl;

    /**
     * 宽字符和宽字符串的输入输出
     */
    wchar_t buffer[100];
    wprintf(L\"格式化输出:%d %s\
\", 42, L\"梁典典\");

    //格式化输入
    wprintf(L\"输入数字和字符串\");
    wscanf(L\"%d %ls\", &buffer);
    wprintf(L\"输入的是:%ls\
\", buffer);

    //格式化宽字符写入宽字符串
    swprintf(buffer, 100, L\"格式话:%d %s\", 42, L\"梁典典\");
    wcout << L\"buffer:\" << buffer << endl;

    //从宽字符串中读取格式化宽字符
    int number;
    wchar_t word[100];
    swscanf(buffer, L\"格式化:%d %s\", &number, word);
    wcout << \"转换后:\" << number << L\"字符:\" << word << endl;


    return 0;
}
```
输出
```bash
file:0x1ed2b3ad0
测试读文件:0x1ed2b3ad0
格式化输出:42输入数字和字符串1
```
## local - 国际化
```c++
#include <iostream>
#include <locale>
#include <string>
#include <ctime>
using namespace std;
/**
 * 国际化
 */
int main() {

    //创建默认的
    locale loc;

    // 使用locle对象
    cout.imbue(loc);//设置cout的locale

    //显示当前的locale名称
    cout << \"current locale\" << loc.name() << endl;
    //输出current localeC

    //    使用locale格式化数字

    locale loc2(\"en_US.UTF-8\");//设置美国英语
    cout.imbue(loc2);//设置cout的locale
    double number = 1234.7890;
    cout << \"formatted number is \" << number << endl;
    //输出:formatted number is 1,234.79



    /**
     * 比较字符串
     */

    locale loc3(\"en_US.UTF-8\");
    string str1 = \"apple\";
    string str2 = \"banana\";

    bool c1 = use_facet<collate<char>>(loc3).compare(str1.c_str(), str1.c_str() + str1.size(),
        str2.c_str(), str2.c_str() + str2.size());
    if (c1 < 0) {
        cout << str1 << \" comes before \" << str2 << endl;
    }
    else {
        cout << str1 << \" comes after \" << str2 << endl;
    }
    ///输出:apple comes after banana

    /**
     * 日期和时间格式化
     */


    locale loc4(\"en_US.UTF-8\");
    cout.imbue(loc4);
    time_t now = time(nullptr);
    tm* timeinfo = localtime(&now);
    char buffer[100];
    strftime(buffer, sizeof(buffer), \"%A, %B, %d %Y\", timeinfo);
    cout << \"current date: \" << buffer << endl;
    ///current date: Friday, September, 13 2024
    return 0;
}
```
输出
```bash
current localeC
formatted number is 1,234.79
apple comes after banana
current date: Wednesday, September, 18 2024
```

## memory - 内存管理
```c++

#include <iostream>
#include <memory>
using namespace std;
/**
 * 内存管理库
 * c++11新特性
 * 智能指针的主要类型:
 * unique_ptr: 独占所有权的智能指针,同一个时间只有有一个unique_ptr指向特定内存
 * shared_ptr: 共享所有权的智能指针,多个shared_ptr可以指向同一个内存,内存在最后一个shared_ptr被销毁时释放
 * weak_ptr: 弱引用智能指针,用于shared_ptr配合使用,避免循环引用导致的内存泄露
 */

class MyClass {
public:
    void doSomething() {
        cout << \"dosomethiing\" << endl;
    }
};


class Node {
public:
    shared_ptr<Node> next;
    weak_ptr<Node> prev;

    Node() :next(nullptr), prev() {}
};

int main() {

    unique_ptr<MyClass> myPtr(new MyClass());
    myPtr->doSomething();//使用智能指针调用成员函数
    //当main函数结束的时候,myPtr被销毁,自动释放MyClass的内存



    /**
     * 使用shared_ptr
     */


    shared_ptr<MyClass> obj1(new MyClass());
    shared_ptr<MyClass> obj2 = obj1;
    obj1->doSomething();
    obj2->doSomething();
    //当obj1,obj2都被销毁时,myclass对象的内存被释放

    /**
     * weak_ptr
     * 通常不单独使用,而是和shared_ptr结合使用,解决循环引用的问题
     */

     /**
      * 创建了两个节点 node1 和 node2，它们都被管理在 std::shared_ptr 中。
     node1->next = node2;: node1 的 next 指针指向 node2，这意味着 node1 持有 node2 的所有权。
     node2->prev = node1;: node2 的 prev 是一个 weak_ptr，指向 node1，但并不持有 node1 的所有权。
      */



    shared_ptr<Node> n1 = make_shared<Node>();
    shared_ptr<Node> n2 = make_shared<Node>();
    n1->next = n2;
    n2->prev = n1;

    //循环引用,使用weak_ptr避免了内存泄露



    /**
     * 分配器: 提供了基本的内存分配和释放功能
     */

    allocator<int> alloc;
    int* p = alloc.allocate(1);//分配内存
    alloc.construct(p, 2);//构造对象

    std::cout << *p << std::endl;

    alloc.destroy(p); // 销毁对象
    alloc.deallocate(p, 1); // 释放内存

    cout << \"end\" << endl;


    /**
     * align: 调整指针的对齐方式
     */

    alignas(16) char buffer2[64];
    void* p2 = buffer2;
    size_t space = sizeof(buffer2);
    void* aligned_ptr = align(16, sizeof(int), p2, space);
    if (aligned_ptr) {
        cout << \"内存对齐\" << endl;
    }
    else {
        cout << \"对齐失败\" << endl;
    }

    return 0;
}
```
输出
```bash
$ ./memory
dosomethiing
dosomethiing
dosomethiing
2
end
```
## new - 内存分配
```c++


#include <iostream>
#include <new> //头文件
using namespace std;


class MyClass {
public:
    int value;
    MyClass() : value(0) {}
};

int main() {


    /**
     * 动态分配单个对象
     */

    MyClass* obj = new MyClass; //分配一个 myclass对象
    obj->value = 10; //使用箭头操作符访问成员

    cout << \"value is \" << obj->value << endl;
    delete obj; //释放内存



    /**
     * 动态分配数组
     */


    int* arr = new int[10]; //分配一个包含10个整数的数组
    for (int i = 0; i < 10; ++i) {
        arr[i] = i * 2;//初始化数组
    }

    for (int i = 0; i < 10; ++i) {
        cout << \"arr[\" << i << \"] = \" << arr[i] << endl;
    }

    delete[] arr;


    /**
     * 使用nothrow避免异常
     */

    int* arr2 = new(nothrow) int[10000000000000000];
    if (!arr2) {
        cout << \"内存分配失败\" << endl;
    }
    else {
        cout << \"内存分配成功\" << endl;
        delete[] arr2;
    }

    /**
     * 异常处理
     * 内存分配失败的时候,会抛出一个std::bad_alloc异常
     * 使用try-catch来捕获异常
     */
    try {
        int* arr3 = new int[10000000000000000];
        cout << \"内存分配成功:arr3\" << endl;
        delete[] arr3;
    }
    catch (const std::bad_alloc& e) {
        cout << \"捕获到内存分配失败\" << e.what() << endl;
    }


    return 0;
}
```
```bash
$ ./new   
value is 10
arr[0] = 0
arr[1] = 2
arr[2] = 4
arr[3] = 6
arr[4] = 8
arr[5] = 10
arr[6] = 12
arr[7] = 14
arr[8] = 16
arr[9] = 18
内存分配失败
捕获到内存分配失败std::bad_alloc
```
## random -  随机数
```c++
#include <iostream>
#include <random>
#include <iomanip>
#include <chrono>
using namespace std;
using namespace std::chrono;
/**
 * 生成随机数的工具
 *
*/
int main() {

    //方式1: 使用random_device 生成种子
    random_device rd;

    //方式2: 使用当前时间作为种子
    unsigned seed = duration_cast<milliseconds>(system_clock::now().time_since_epoch()).count();

    ///使用基于 mersenne twister 随机数生成器,不传种子会固定生成
    mt19937 generator(rd());

    cout << \"random number:\" << generator() << endl;
    //输出random number:3499211612 (备注,每次输出都是一样的...)


/**
 * 使用均匀分布
 */
    mt19937 generator2(rd());

    //设置范围
    uniform_int_distribution<int> distribution(1, 10);
    for (int i = 0; i < 5;i++) {
        cout << \"随机数:\" << distribution(generator2) << endl;
    }
    /*
        输出:
        随机数:7
随机数:10
随机数:6
随机数:2
随机数:4
    */


    /**
     * 使用正态分布的随机数
     *
     */

    mt19937 generator3(seed);//使用当前时间作为种子
    //创建正态分布的随机数,均值为0,标准差为1
    normal_distribution<double> distribution2(0.0, 1.0);

    //设置输出格式,保留2位小数
    cout << fixed << std::setprecision(2);

    //生成
    for (int i = 0; i < 5; i++) {
        cout << \"随机数:\" << distribution2(generator3) << endl;
    }
    /*
        输出
        随机数:-0.15
随机数:0.13
随机数:-1.87
随机数:0.46
随机数:-0.21
    */

    return 0;
}
```
输出
```bash
$ ./random
random number:2805560704
随机数:7
随机数:7
随机数:6
随机数:3
随机数:5
随机数:0.35
随机数:0.44
随机数:0.71
随机数:-0.34
随机数:-0.91
```

## utility - 实用工具类和函数
```c++
#include <iostream>
#include <utility>
#include <vector>
#include <type_traits>
using namespace std;



void process(int& i) {
    cout << \"左值引用 i :\" << i << endl;
}

void process(int&& i) {
    cout << \"右值引用 i :\" << i << endl;
}


template <typename T>

void forward_example(T&& t) {
    process(std::forward<T>(t));
}





struct MyClass
{
    MyClass(int, double) {}
};

template <typename T>
void test() {
    //获取T的构造函数类型,不调用 (注意导包#include <type_traits>.)
    using R = decltype(T(std::declval<int>(), std::declval<double>()));
    cout << is_same<R, MyClass>::value << endl;
}


/**
 包含了实用的工具类和函数:
 pair: 模板类,存储2个不一样类型的值
 make_pair:函数模板,创建pair对象,
 swap: 函数模板,交换两个对象的值
*/
int main() {


    /*
        使用pair,和maake_pair

    */

    auto p = make_pair(10, 20);
    cout << \"firset value is \" << p.first << endl;
    cout << \"second value is \" << p.second << endl;


    /**
     * swap
     *
     */


    int a = 1;
    int b = 2;
    cout << \"初始化值,a=\" << a << \",b=\" << b << endl;

    swap(a, b);//交换
    cout << \"交换后,a=\" << a << \",b=\" << b << endl;


    /**
     * move函数
     */

    vector<int> v1 = { 1,2,3,4,5,6,7,8 };
    vector<int> v2 = std::move(v1);


    cout << \"v1 size: \" << v1.size() << endl;//空的
    cout << \"v2 size:\" << v2.size() << endl; //8


    /**
     * forward函数
     * std::forward 是 C++ 中一个模板函数，主要用于完美转发（perfect forwarding）场景。它的作用是根据传递的参数类型（左值或右值）将参数以相同的类型进行转发，避免不必要的拷贝或移动操作。

关键概念

为了理解 std::forward，你需要先了解几个相关概念：

    1.	左值和右值：左值（lvalue）是一个可以取地址的对象，右值（rvalue）是临时的值，通常在表达式中出现，如字面常量或返回的临时对象。
    2.	完美转发：在泛型编程中，你希望函数模板能够保持参数的原始类型（左值或右值）并正确地将其传递给其他函数。std::forward 就是用于在这种情况下保持参数的值类别。

std::forward 的作用

当你想要在函数模板中保持参数的左值或右值特性时，std::forward 能根据传递的参数类型正确地转发：

    •	如果传递的是左值，std::forward 会保留其左值特性。
    •	如果传递的是右值，std::forward 会保留其右值特性。
     */


    int x = 10;
    forward_example(x); //左值
    forward_example(20); //右值
    forward_example(std::move(x)); //右值



    /**
     * declval
     */

    test<MyClass>();

    return 0;
}
```
输出
```bash
$ ./utility               
firset value is 10
second value is 20
初始化值,a=1,b=2
交换后,a=2,b=1
v1 size: 0
v2 size:8
左值引用 i :10
右值引用 i :20
右值引用 i :10
```', '', NULL, 52, 0, true, '2024-09-18 10:05:49.348000');
INSERT INTO blogs (id, title, slug, author, content, html, thumbnail, category_id, view_count, is_published, created_at) VALUES (952, '虚幻5基础之基于c++类来创建蓝图', 'blog-952', '梁典典', '## 创建c++类
![image.png](https://minio.itbug.shop/blog/simple-file/image___1727354218222___.png)
![image.png](https://minio.itbug.shop/blog/simple-file/image___1727354273978___.png)
![image.png](https://minio.itbug.shop/blog/simple-file/image___1727354354673___.png)
点击创建类,等一会会在rider中打开这两个.h+.cpp文件
> 像这样
![image.png](https://minio.itbug.shop/blog/simple-file/image___1727354436083___.png)

## 设计c++类

在`ALddLearningCppObject.h`添加一些属性
![image.png](https://minio.itbug.shop/blog/simple-file/image___1727354712264___.png)

在`ALddLearningCppObject.cpp`初始化函数
![image.png](https://minio.itbug.shop/blog/simple-file/image___1727354793546___.png)

## 在虚幻引擎中使用
在虚幻中找到刚才创建的c++类
![image.png](https://minio.itbug.shop/blog/simple-file/image___1727354881353___.png)
打开右键菜单
![image.png](https://minio.itbug.shop/blog/simple-file/image___1727354929572___.png)
![image.png](https://minio.itbug.shop/blog/simple-file/image___1727354963169___.png)
打开蓝图,可以看到刚才定义的属性
![image.png](https://minio.itbug.shop/blog/simple-file/image___1727355072766___.png)', '', NULL, 202, 0, true, '2024-09-26 21:34:33.957000');
INSERT INTO blogs (id, title, slug, author, content, html, thumbnail, category_id, view_count, is_published, created_at) VALUES (1002, '解决在mac m系列芯片上使用emulator命令报错的问题的', 'blog-1002', '梁典典', '## 报错信息
```bash
emulator -avd Pixel_3_XL_API_30 -writable-system  
[8670044672]:ERROR:android/android-emu/android/qt/qt_setup.cpp:28:Qt library not found at ../emulator/lib64/qt/lib
Could not launch ''/Users/ldd/../emulator/qemu/darwin-x86_64/qemu-system-aarch64'': No such file or directory
```

## 解决方案

手动进入tools目录
```bash
cd $ANDROID_HOME/tools
cd ..
cd ./emulator
```
运行emulator命令
```bash
./emulator -avd Pixel_3_XL_API_30 -writable-system
```

## 修改虚拟机的host

```bash
adb root
adb remount
adb push /Users/ldd/xxx/hosts /etc/hosts

```
', '', NULL, 103, 0, true, '2024-10-23 14:17:03.264000');
INSERT INTO blogs (id, title, slug, author, content, html, thumbnail, category_id, view_count, is_published, created_at) VALUES (1052, '虚幻引擎中的游戏子系统,单例模式,线程', 'blog-1052', '梁典典', '## 创建c++对象,继承GmaeInstanceSubsystem


>  我的游戏引擎实例,获取实例方法: `UMyGameSubsystem* MySubsystem = GEngine->GetEngineSubsystem<UMyGameSubsystem>();`

> 注意它有多个子系统,这里使用的是gameinstance,获取方式为`const auto GameInstance = GetGameInstance(); ameInstance->GetSubsystem<UMyThreadGameInstanceSubsystem>()`

还有其他一些子系统
1. 	UGameInstanceSubsystem：游戏实例子系统，游戏中唯一。
2. 	UWorldSubsystem：世界子系统，在每个UWorld中存在。
3. 	ULocalPlayerSubsystem：每个本地玩家各自拥有一个。
4. 	UEngineSubsystem：整个引擎中的唯一子系统，游戏生命周期内始终存在。

![image.png](https://minio.itbug.shop/blog/simple-file/image___1731120779759___.png)

## 重写生命周期函数
.h
```c++
UCLASS()
class DEMO2_API UMyThreadGameInstanceSubsystem : public UGameInstanceSubsystem
{
	GENERATED_BODY()
public:
	UFUNCTION(BlueprintCallable,Blueprintable, Category = \"StartThreadTask\")
	void StartThreadTask();
private:
    //初始化执行
	virtual void Initialize(FSubsystemCollectionBase& Collection) override;
	//销毁时执行
    virtual void Deinitialize() override;
    //线程共享指针
	TSharedPtr<FMyTestThread> MyTestThread;
    //线程运行管理器
	FRunnableThread* RunnableThread;
};

```
.cpp

```c++

#include \"MyThreadGameInstanceSubsystem.h\"

void UMyThreadGameInstanceSubsystem::StartThreadTask()
{
	//创建一个线程
	UE_LOG(LogTemp, Warning, TEXT(\"StartThreadTask\"));
	MyTestThread = MakeShared<FMyTestThread>(\"测试线程\");
	RunnableThread = FRunnableThread::Create(MyTestThread.Get(),*MyTestThread->GetThreadName().ToString());
}

void UMyThreadGameInstanceSubsystem::Initialize(FSubsystemCollectionBase& Collection)
{
	UE_LOG(LogTemp,Log,TEXT(\"游戏实例初始化:UMyThreadGameInstanceSubsystem::Initialize\"));
	Super::Initialize(Collection);
}

void UMyThreadGameInstanceSubsystem::Deinitialize()
{
	UE_LOG(LogTemp,Log,TEXT(\"游戏实例销毁:UMyThreadGameInstanceSubsystem::DeInitialize\"));
	if(MyTestThread.IsValid())
	{
		MyTestThread->Stop();
	}
	if(RunnableThread)
	{
		RunnableThread->WaitForCompletion();
		delete RunnableThread;
		RunnableThread = nullptr;
	}
	Super::Deinitialize();
}

```

## 创建线程任务,注意对象名要F开头
.h
```c++
class DEMO2_API FMyTestThread final : public FRunnable
{
	
public:
	FMyTestThread();
	FMyTestThread(const FName& ThreadName);
	virtual ~FMyTestThread() override;
	//初始化,返回值表示是否初始化成功
	virtual bool Init() override;
	//运行任务,返回值0表示正常结束
	virtual uint32 Run() override;
	//任务停止
	virtual void Stop() override;
	//任务销毁退出
	virtual void Exit() override;
	//线程名称
	FName GetThreadName() const;

private:
	//属性,线程名
	FName ThreadName;
	//这是测试用,是否需要运行任务
	bool bIsRunning;
};
```
.cpp
```c++
FMyTestThread::FMyTestThread(): bIsRunning(false)
{
	UE_LOG(LogTemp, Warning, TEXT(\"FMyTestThread::FMyTestThread()\"));
}

FMyTestThread::FMyTestThread(const FName& ThreadName): ThreadName(ThreadName), bIsRunning(false)
{
	UE_LOG(LogTemp, Warning, TEXT(\"Thread Created\"));
}

FMyTestThread::~FMyTestThread()
{
	UE_LOG(LogTemp, Warning, TEXT(\"Thread Destroyed\"));
}

bool FMyTestThread::Init()
{
	bIsRunning = true;
	return FRunnable::Init();
}


uint32 FMyTestThread::Run()
{
	while (bIsRunning)
	{
		FPlatformProcess::Sleep(3);
		UE_LOG(LogTemp, Warning, TEXT(\"Thread Running\"));
	}
	return 0;
}

void FMyTestThread::Stop()
{
	UE_LOG(LogTemp, Warning, TEXT(\"FMyTestThread::Stop()\"));
	bIsRunning = false;
	FRunnable::Stop();
}

void FMyTestThread::Exit()
{
	UE_LOG(LogTemp, Warning, TEXT(\"FMyTestThread::Exit\"));
	FRunnable::Exit();
}

FName FMyTestThread::GetThreadName() const
{
	return ThreadName;
}
```


## 使用
```c++
///测试子系统
void AMyCharacter::StartTestThreadFunction()
{
	UE_LOG(LogTemp, Log, TEXT(\"测试游戏子系统.\"));
	if(const auto MyTestSubSystem = GetGameInstance()->GetSubsystem<UMyThreadGameInstanceSubsystem>())
	{
		MyTestSubSystem -> StartThreadTask();
	}
}
```
运行结果
![image.png](https://minio.itbug.shop/blog/simple-file/image___1731121357756___.png)
', '', NULL, 202, 0, true, '2024-11-09 11:03:55.903000');
INSERT INTO blogs (id, title, slug, author, content, html, thumbnail, category_id, view_count, is_published, created_at) VALUES (1152, '使用1Panel搭建RustDesk服务端', 'blog-1152', '梁典典', '## 安装的时候改成服务器IP
![image.png](https://minio.itbug.shop/blog/simple-file/image___1732937507330___.png)

## 开发端口
* TCP: 21115-21119
* UDP: 21116 (不开连不上)

## 客户端配置

- ID服务器输入步骤1的IP
- key可以在docker日志找到
![image.png](https://minio.itbug.shop/blog/simple-file/image___1732937721772___.png)
![image.png](https://minio.itbug.shop/blog/simple-file/image___1732937650505___.png)

## 可以看到连上了

![image.png](https://minio.itbug.shop/blog/simple-file/image___1732937759316___.png)', '', NULL, 152, 0, true, '2024-11-30 11:36:14.396000');
INSERT INTO blogs (id, title, slug, author, content, html, thumbnail, category_id, view_count, is_published, created_at) VALUES (1153, 'docker部署salvo和后台前端代码', 'blog-1153', '梁典典', '
## 1. 编写nginx.conf配置文件




```nginx configuration
events {
    worker_connections  1024;
}
http {
    include       /etc/nginx/mime.types;
    default_type  application/octet-stream;
    sendfile        on;
    keepalive_timeout  65;

    server {
        listen 5802;
        server_name 0.0.0.0;


        # API 代理配置
        location /api {
            proxy_pass http://0.0.0.0:5800;  # 转发到目标地址
            proxy_set_header Host $host;             # 转发请求的 Host 头
            proxy_set_header X-Real-IP $remote_addr; # 客户端真实 IP
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; # 转发链 IP
        }



        location / {
            root /usr/share/nginx/html;
            index index.html;
            try_files $uri /index.html;
        }



                # 直接提供静态资源
        location /static/ {
             root /usr/share/nginx/html;
        }
    }
    gzip  on;
    gzip_min_length  1k;
    gzip_buffers     4 16k;
    gzip_http_version 1.1;
    gzip_comp_level 9;
    gzip_types       text/plain application/x-javascript text/css application/xml text/javascript application/x-httpd-php application/javascript application/json;
    gzip_disable \"MSIE [1-6]\\.\";
    gzip_vary on;
}

```

要调整的参数有

| 名称                             | 描述           |
|--------------------------------|--------------|
| listen 5802                    | 自定义nginx监听端口 |
| proxy_pass http://0.0.0.0:5800 | salvo服务地址    |
| root /usr/share/nginx/html                               | html静态文件路径   |

## 2. 编写dockerfile

把savlo的一些配置和数据库拷贝进镜像,还有静态html文件

```dockerfile
FROM alpine:latest

RUN echo \"http://mirrors.aliyun.com/alpine/latest-stable/main/\" > /etc/apk/repositories && \\
    echo \"http://mirrors.aliyun.com/alpine/latest-stable/community/\" >> /etc/apk/repositories

ENV TZ Asia/Shanghai
RUN apk add tzdata && cp /usr/share/zoneinfo/${TZ} /etc/localtime \\
    && echo ${TZ} > /etc/timezone \\
    && apk del tzdata \\
    && apk update && apk add --no-cache nginx \\
    && apk add curl

RUN mkdir -p /run/nginx \\
    && mkdir -p /usr/share/nginx/html

COPY ./admin-antd/nginx.conf /etc/nginx/nginx.conf
COPY ./admin-antd/dist /usr/share/nginx/html

WORKDIR /home/app-dir
COPY ./target/x86_64-unknown-linux-musl/release/d_blog ./d_blog
COPY ./data ./data
COPY ./config ./config
COPY ./assets ./assets
COPY ./logs ./logs
ENV LANG en US.UTF-8
ENV LANGUAGE en US:en
ENV LC ALL en US.UTF-8
EXPOSE 5800 5801 5802
ENTRYPOINT [\"sh\", \"-c\",\"nginx -g ''daemon off;'' & /home/app-dir/d_blog\"]


```

entrypoint 要先启动nginx,rust可执行文件后面再运行

EXPOSE 5800 5801 5802 开放端口
', '', NULL, 102, 0, true, '2024-12-17 16:49:33.493000');
INSERT INTO blogs (id, title, slug, author, content, html, thumbnail, category_id, view_count, is_published, created_at) VALUES (1202, 'c++使用type_identity_t实现泛型自动推导', 'blog-1202', '梁典典', '
```c++
/**
 * 省略写if语句
 * @tparam ObjectType 指针类型
 * @param Objc 传入的指针
 * @param Call 执行有效执行
 */
template <typename ObjectType>
requires std::is_pointer_v<ObjectType>
static void Let(ObjectType Objc, std::function<void(std::type_identity_t<ObjectType>)> Call)
{
	if (Objc)
	{
		Call(Objc);
	}
}


// 用法
Let(PathComponent, [this](auto Path)
	{
		if (SplinePointCount > 0)
		{
			if (CurrentSplinePointIndex < SplinePointCount)
			{
				const auto Local = Path->GetSplineLocationByIndex(CurrentSplinePointIndex);
				MyPrintfDebug(\"开始往样条点移动....\");
				UE_LOG(LogTemp,Warning,TEXT(\"开始移动到样条点,样条点数量:%d\"),Path->GetPointCount());
				auto Result = MoveToLocation(Local); //往样条点位置移动
				if (Result == EPathFollowingRequestResult::RequestSuccessful)
				{
					MyPrintfDebug(\"成功了..\");
				}else
				{
					MyPrintfDebug(\"失败了\");
				}
				CurrentSplinePointIndex++;
			}
			else
			{
				///停止移动
				MyPrintfDebug(\"移动完成了\");
			}
		}
	});
```
`is_pointer_v`: 限制泛型为指针类型,除了这个,还有很多限制
![image.png](https://minio.itbug.shop/blog/simple-file/image___1735607685101___.png)', '', NULL, 52, 0, true, '2024-12-31 09:15:45.358000');
INSERT INTO blogs (id, title, slug, author, content, html, thumbnail, category_id, view_count, is_published, created_at) VALUES (1203, 'UE5(c++)使用rust编写插件给虚幻调用', 'blog-1203', '梁典典', '## 新建一个空的UE插件项目

在插件根目录下的Source新建一个rust lib项目

`html2markdown-dylib` 项目名
```bash
 cargo new --lib html2markdown-dylib
```
![image.png](https://minio.itbug.shop/blog/simple-file/image___1735801514819___.png)

路径如下
![image.png](https://minio.itbug.shop/blog/simple-file/image___1735801551017___.png)

## 配置Cargo.toml

> html2markdown_dylib 记得改这,不要使用-横杠
```toml
[package]
name = \"html2markdown-dylib\"
version = \"0.1.0\"
edition = \"2021\"

[dependencies]
mdka = \"1.2.10\"
reqwest = { version = \"0.12.12\", features = [\"blocking\"] }

[lib]
crate-type = [\"dylib\"]
name = \"html2markdown_dylib\"

[build-dependencies]
cbindgen = \"0.27.0\"

```
## 编写实际代码
`md_loader.rs`
```rust
pub struct MdLoader;

impl MdLoader {
    /// 从网络URL中加载markdown文本
    pub fn load_md_from_url(url: &str) -> String {
        let response = reqwest::blocking::get(url);
        if let Ok(response) = response {
            if let Ok(text) = response.text() {
                let md = mdka::from_html(&text);
                return md;
            }
        }
        return format!(\"Loading markdown from url: {}\", url);
    }
}

```
## 构建头文件
在根目录下新建`build.rs`
```rust
extern crate cbindgen;

use std::env;

fn main() {
    let create_dir = env::var(\"CARGO_MANIFEST_DIR\").unwrap();
    let mut config: cbindgen::Config = Default::default();
    config.language = cbindgen::Language::Cxx;
    cbindgen::generate_with_config(&create_dir, config)
        .expect(\"unable to generate bindings\")
        .write_to_file(\"include/UEHTML2MARKDOWN.h\");
}

```
## 编译
```rust
cargo build --release
```
会在include目录下生成一个头文件,后面会在ue项目中使用
像这样
```c++
#include \"UEHTML2MARKDOWN.h\"
```
最终结果
![image.png](https://minio.itbug.shop/blog/simple-file/image___1735801977180___.png)

## 在UE插件中添加依赖
在`UE插件名.Build.cs`编辑
```cs
using System;
using System.IO;
using UnrealBuildTool;

public class UEHtml2Md : ModuleRules
{
	public UEHtml2Md(ReadOnlyTargetRules Target) : base(Target)
	{


		if (Target.Platform == UnrealTargetPlatform.Mac)
		{
			Console.WriteLine($\"梁典典:module directory path: {ModuleDirectory}\");
			var includePath = Path.Combine(ModuleDirectory, \"../html2markdown-dylib/include\");
			Console.WriteLine($\"梁典典:header include path{includePath}\");
			PublicIncludePaths.Add(includePath);
			PublicAdditionalLibraries.Add(Path.Combine(ModuleDirectory, \"../html2markdown-dylib\",\"target\", \"release\", \"libhtml2markdown_dylib.dylib\"));
			RuntimeDependencies.Add(\"${PluginDir}/Binaries/Mac/libhtml2markdown_dylib.dylib\");
		}


		PCHUsage = ModuleRules.PCHUsageMode.UseExplicitOrSharedPCHs;
		
		PublicIncludePaths.AddRange(
			new string[] {
				// ... add public include paths required here ...
			}
			);
				
		
		PrivateIncludePaths.AddRange(
			new string[] {
			}
			);
			
		
		PublicDependencyModuleNames.AddRange(
			new string[]
			{
				\"Core\",
				\"Projects\",
				\"UEHtml2Md\"
			}
			);
			
		
		PrivateDependencyModuleNames.AddRange(
			new string[]
			{
				\"CoreUObject\",
				\"Engine\",
				\"Slate\",
				\"SlateCore\",
			}
			);
		
		
		DynamicallyLoadedModuleNames.AddRange(
			new string[]
			{
				// ... add any modules that your module loads dynamically here ...
			}
			);
	}
}

```

## 在插件模块接口中加载句柄
文件: `插件名.h`
```c++
#pragma once

#include \"Modules/ModuleManager.h\"

class FUEHtml2MdModule : public IModuleInterface
{
public:

	void* Instance; // 句柄
	

	/** IModuleInterface implementation */
	virtual void StartupModule() override;
	virtual void ShutdownModule() override;
};

```
文件:`插件名.cpp`
```c++

#include \"UEHtml2Md.h\"

#include \"Interfaces/IPluginManager.h\"

#define LOCTEXT_NAMESPACE \"FUEHtml2MdModule\"

void FUEHtml2MdModule::StartupModule()
{
	const auto PluginDir = IPluginManager::Get().FindPlugin(\"UEHtml2Md\")->GetBaseDir();
	if (const auto LibPath = FPaths::Combine(*PluginDir, TEXT(\"Binaries/Mac/libhtml2markdown_dylib.dylib\")); !LibPath.IsEmpty())
	{
		Instance = FPlatformProcess::GetDllHandle(*LibPath);
	}
	if (!Instance){
		UE_LOG(LogTemp,Error,TEXT(\"ldd: load dll failed!\"));
	}else
	{
		UE_LOG(LogTemp,Log,TEXT(\"ldd: load dll success!\"));
	}
}

void FUEHtml2MdModule::ShutdownModule()
{
	if (Instance)
	{
		FPlatformProcess::FreeDllHandle(Instance);
		Instance = nullptr;
	}
}

#undef LOCTEXT_NAMESPACE
	
IMPLEMENT_MODULE(FUEHtml2MdModule, UEHtml2Md)
```

## 最终: 在虚幻项目中引入插件
文件: `项目.Build.cs`
![image.png](https://minio.itbug.shop/blog/simple-file/image___1735802248194___.png)

## 使用
```c++
void AMyOutletBase::BeginPlay()
{
	Super::BeginPlay();

	// 测试加载,这里调用rust写的函数,可以在插件中封装更友好的类调用
	const auto Result = load_markdown_form_url_ffi(\"https://www.rust-lang.org\");
	const FString Str = FString(Result);
	UE_LOG(LogTemp, Display, TEXT(\"%s\"), *Str);
	if (TextComponent)
	{
		TextComponent->SetText(FText::FromString(Str));
	}
}

```
', '', NULL, 102, 0, true, '2025-01-02 15:21:51.850000');
INSERT INTO blogs (id, title, slug, author, content, html, thumbnail, category_id, view_count, is_published, created_at) VALUES (1252, 'UE5.5 C++ 动态绑定按键操作，和动态移除按键操作', 'blog-1252', '梁典典', '
## 需求
在指定AActor附近进行陷阱选择，通过按键N来打开陷阱选择器的UI，当玩家离开这个AActor区域后，给玩家动态移除N键操作绑定

## 定义按键操作
生命
```c++
	//按键操作
	UPROPERTY()
	UInputAction* OpenUIAction;
```
合适的地方初始化
```c++
if (!OpenUIAction)
	{
		OpenUIAction = CreateDefaultSubobject<UInputAction>(TEXT(\"打开选择陷阱UI面板\"));
	}
```
## 添加绑定
声明绑定和解绑操作函数
```c++
	//绑定按键
	UFUNCTION()
	void BindKeyBoard();

	//移除按键绑定
	UFUNCTION()
	void RemoveBindKey(AAMyGamePlayer* Player);
```
实现这两个方法
```c++

void ASelectTrapRegionActor::BindKeyBoard()
{
	if (!OpenUIAction)
	{
		OpenUIAction = CreateDefaultSubobject<UInputAction>(TEXT(\"打开选择陷阱UI面板\"));
	}
	if (PlayerCharacter)
	{
		const auto MappingContext = PlayerCharacter->DefaultInputMappingContext;
		if (const auto InputComponent = PlayerCharacter->MyInputComponent; MappingContext && InputComponent &&
			OpenUIAction)
		{
			const FKey NKey(EKeys::N);
			MappingContext->MapKey(OpenUIAction, NKey);
			InputComponent->BindAction(OpenUIAction, ETriggerEvent::Completed, this,
			                           &ASelectTrapRegionActor::OpenTrapSelectionUI);
		}
	}
}

void ASelectTrapRegionActor::RemoveBindKey(AAMyGamePlayer* Player)
{
	if (Player)
	{
		const auto MappingContext = PlayerCharacter->DefaultInputMappingContext;
		if (const auto InputComponent = PlayerCharacter->MyInputComponent; InputComponent && OpenUIAction)
		{
			// todo解绑 Action
			for (auto& BindActions = InputComponent->GetActionEventBindings(); const TUniquePtr<FEnhancedInputActionEventBinding>& BindAction : BindActions)
			{
				if (const auto Action = BindAction->GetAction(); Action == OpenUIAction)
				{
					if (const auto Index = BindActions.Find(BindAction); Index != INDEX_NONE)
					{
						MyPrintfDebug(\"移除 BindAction OpenUIAction\");
						InputComponent->RemoveBindingByHandle(BindAction->GetHandle());
						break;
					}
				}
			}
		}

		// 移除映射上下文中的N键映射
		const FKey NKey(EKeys::N);
		auto Mappings = MappingContext->GetMappings();
		for (int32 i = Mappings.Num() - 1; i >= 0; --i)
		{
			if (FEnhancedActionKeyMapping& Mapping = Mappings[i]; Mapping.Action == OpenUIAction && Mapping.Key == NKey)
			{
				Mappings.RemoveAt(i);
				MyPrintfDebug(\"移除按键映射 BindAction OpenUIAction\");
				break;
			}
		}
	}
}

```
完成

## 完整的代码
头文件
```c++
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include \"CoreMinimal.h\"
#include \"MyCharacter.h\"
#include \"GameFramework/Actor.h\"
#include \"Model/FMyTrapInfo.h\"
#include \"Widget/Trap/TrapListSelectUIWidget.h\"
#include \"SelectTrapRegionActor.generated.h\"

class UBoxComponent;

UCLASS()
class DEMO2_API ASelectTrapRegionActor : public AActor
{
	GENERATED_BODY()

public:
	UFUNCTION()
	void OnOverlapBegin(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult);
	UFUNCTION()
	void OnOverlapEnd(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
	
	ASelectTrapRegionActor();

protected:
	

	//加载数据表格，读取所有可以选择的陷阱
	UFUNCTION()
	void LoadAllTrapInfos();

	// 判断角色是否创建在触发盒体内部
	UFUNCTION()
	void CheckGamePlayerIsInTriggerBox();
	
	virtual void BeginPlay() override;


	//触发盒体
	UPROPERTY()
	UBoxComponent* TriggerBox;


	//UI用户界面
	UPROPERTY(EditAnywhere,BlueprintReadWrite,Category=\"用户界面\",DisplayName=\"陷阱选择组件\")
	TSubclassOf<UUserWidget> WidgetClass;
	
	
	//检查玩家是否在该区域
	bool IsPlayerInRegion;

	// 对玩家角色的引用（假设是单人游戏）
	UPROPERTY()
	AAMyGamePlayer* PlayerCharacter;

	//绑定按键
	UFUNCTION()
	void BindKeyBoard();

	//移除按键绑定
	UFUNCTION()
	void RemoveBindKey(AAMyGamePlayer* Player);


	//按键操作
	UPROPERTY()
	UInputAction* OpenUIAction;


	//选择陷阱组件
	UPROPERTY()
	UTrapListSelectUIWidget* TrapSelectWidget;

	//陷阱列表
	UPROPERTY()
	TArray<FMyTrapInfo> TrapInfoArray;

	//延迟执行 actor检测函数
	FTimerHandle TimerHandle;

public:
	// Called every frame
	virtual void Tick(float DeltaTime) override;

	// 打开陷阱选择UI
	UFUNCTION()
	void OpenTrapSelectionUI();

	//关闭陷阱选择 ui
	UFUNCTION()
	void CloseTrapSelectionUI() const;

	
};
```
cpp
```c++
// Fill out your copyright notice in the Description page of Project Settings.


#include \"Actor/MapRegion/SelectTrapRegionActor.h\"

#include \"EnhancedInputComponent.h\"
#include \"Blueprint/UserWidget.h\"
#include \"Components/BoxComponent.h\"
#include \"Tool/MyLogTool.h\"
#include \"Widget/Trap/TrapListSelectUIWidget.h\"

/// 
ASelectTrapRegionActor::ASelectTrapRegionActor()
{
	PrimaryActorTick.bCanEverTick = true;

	//创建触发盒体
	if (!TriggerBox)
	{
		TriggerBox = CreateDefaultSubobject<UBoxComponent>(TEXT(\"TriggerBox\"));
		TriggerBox->SetGenerateOverlapEvents(true); //生成时触发碰撞检测
		RootComponent = TriggerBox;
		TriggerBox->SetBoxExtent(FVector(700.0f, 700.0f, 200.0f));
		TriggerBox->SetCollisionEnabled(ECollisionEnabled::QueryOnly); // 只进行查询碰撞
		TriggerBox->SetCollisionProfileName(TEXT(\"Trigger\"));
		TriggerBox->OnComponentBeginOverlap.AddDynamic(this, &ASelectTrapRegionActor::OnOverlapBegin);
		TriggerBox->OnComponentEndOverlap.AddDynamic(this, &ASelectTrapRegionActor::OnOverlapEnd);
	}

	if (!OpenUIAction)
	{
		OpenUIAction = CreateDefaultSubobject<UInputAction>(TEXT(\"打开选择陷阱UI面板\"));
	}

	IsPlayerInRegion = false;
	TrapSelectWidget = nullptr;
}

void ASelectTrapRegionActor::LoadAllTrapInfos()
{
	for (auto Arr = GetTrapAllDataList(); const auto Trap : Arr)
	{
		TrapInfoArray.Add(*Trap);
	}
}

void ASelectTrapRegionActor::CheckGamePlayerIsInTriggerBox()
{
	if (TriggerBox)
	{
		TArray<AActor*> Actors;
		TriggerBox->GetOverlappingActors(Actors, AAMyGamePlayer::StaticClass());
		for (const auto Actor : Actors)
		{
			if (const auto Player = Cast<AAMyGamePlayer>(Actor))
			{
				OnOverlapBegin(nullptr, Player, nullptr, 0, false, FHitResult());
			}
		}
	}
}

void ASelectTrapRegionActor::BeginPlay()
{
	Super::BeginPlay();
	LoadAllTrapInfos();
	GetWorld()->GetTimerManager().SetTimer(TimerHandle, this, &ASelectTrapRegionActor::CheckGamePlayerIsInTriggerBox,
	                                       1.f, false);
}

void ASelectTrapRegionActor::Tick(float DeltaTime)
{
	Super::Tick(DeltaTime);
}

/// 
void ASelectTrapRegionActor::OnOverlapBegin(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor,
                                            UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool
                                            bFromSweep, const FHitResult& SweepResult)
{
	if (const auto Player = Cast<AAMyGamePlayer>(OtherActor))
	{
		MyPrintfDebug(\"进入选择陷阱碰撞区域==========\");
		UMyLogTool::DebugToScreen(UTF8_TO_TCHAR(\"进入陷阱选择区域。\"));
		PlayerCharacter = Player;
		IsPlayerInRegion = true;
		BindKeyBoard();
	}
}

/// 
void ASelectTrapRegionActor::OnOverlapEnd(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor,
                                          UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	if (auto Player = Cast<AAMyGamePlayer>(OtherActor))
	{
		MyPrintfDebug(\"离开选择陷阱碰撞区域==========\");
		UMyLogTool::DebugToScreen(UTF8_TO_TCHAR(\"离开陷阱选择区域\"));
		IsPlayerInRegion = false;
		CloseTrapSelectionUI();
		RemoveBindKey(Player);
	}
}

void ASelectTrapRegionActor::OpenTrapSelectionUI()
{
	MyPrintfDebug(\"触发陷阱选择面板UI\");
	if (TrapSelectWidget && TrapSelectWidget->IsInViewport())
	{
		TrapSelectWidget->RemoveFromParent();
		TrapSelectWidget = nullptr;
		return;
	}
	if (UWorld* World = GetWorld(); WidgetClass)
	{
		MyPrintfDebug(\"打开UI\");
		const auto TrapSelectionUI = CreateWidget<UTrapListSelectUIWidget>(World, WidgetClass);
		// Replace YOUR_UI_CLASS with the actual UI class
		TrapSelectWidget = TrapSelectionUI;
		if (TrapSelectionUI)
		{
			TrapSelectionUI->Setup(TrapInfoArray); //设置数据
			TrapSelectionUI->AddToViewport();
		}
	}
}

// 
void ASelectTrapRegionActor::CloseTrapSelectionUI() const
{
	if (UWorld* World = GetWorld())
	{
		MyPrintfDebug(\"关闭陷阱选择UI\");
		if (TrapSelectWidget)
		{
			TrapSelectWidget->RemoveFromParent();
		}
	}
}


void ASelectTrapRegionActor::BindKeyBoard()
{
	if (!OpenUIAction)
	{
		OpenUIAction = CreateDefaultSubobject<UInputAction>(TEXT(\"打开选择陷阱UI面板\"));
	}
	if (PlayerCharacter)
	{
		const auto MappingContext = PlayerCharacter->DefaultInputMappingContext;
		if (const auto InputComponent = PlayerCharacter->MyInputComponent; MappingContext && InputComponent &&
			OpenUIAction)
		{
			const FKey NKey(EKeys::N);
			MappingContext->MapKey(OpenUIAction, NKey);
			InputComponent->BindAction(OpenUIAction, ETriggerEvent::Completed, this,
			                           &ASelectTrapRegionActor::OpenTrapSelectionUI);
		}
	}
}

void ASelectTrapRegionActor::RemoveBindKey(AAMyGamePlayer* Player)
{
	if (Player)
	{
		const auto MappingContext = PlayerCharacter->DefaultInputMappingContext;
		if (const auto InputComponent = PlayerCharacter->MyInputComponent; InputComponent && OpenUIAction)
		{
			// todo解绑 Action
			for (auto& BindActions = InputComponent->GetActionEventBindings(); const TUniquePtr<FEnhancedInputActionEventBinding>& BindAction : BindActions)
			{
				if (const auto Action = BindAction->GetAction(); Action == OpenUIAction)
				{
					if (const auto Index = BindActions.Find(BindAction); Index != INDEX_NONE)
					{
						MyPrintfDebug(\"移除 BindAction OpenUIAction\");
						InputComponent->RemoveBindingByHandle(BindAction->GetHandle());
						break;
					}
				}
			}
		}

		// 移除映射上下文中的N键映射
		const FKey NKey(EKeys::N);
		auto Mappings = MappingContext->GetMappings();
		for (int32 i = Mappings.Num() - 1; i >= 0; --i)
		{
			if (FEnhancedActionKeyMapping& Mapping = Mappings[i]; Mapping.Action == OpenUIAction && Mapping.Key == NKey)
			{
				Mappings.RemoveAt(i);
				MyPrintfDebug(\"移除按键映射 BindAction OpenUIAction\");
				break;
			}
		}
	}
}

```', '', NULL, 202, 0, true, '2025-02-17 11:27:24.035000');
INSERT INTO blogs (id, title, slug, author, content, html, thumbnail, category_id, view_count, is_published, created_at) VALUES (1253, '若依接入 kotlin编译和 Springboot JPA模块', 'blog-1253', '梁典典', '## 模块中pom.xml引入JPA依赖
```xml
            <dependency>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-starter-data-jpa</artifactId>
                <version>${spring-boot.version}</version>
            </dependency>
            <dependency>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-starter-jdbc</artifactId>
            </dependency>
```

## 添加 kotlin依赖
主模块 pom.xml添加属性
```xml
        <kotlin.version>1.8.0</kotlin.version>
        <!--启用kotlin增量编译-->
        <kotlin.compiler.incremental>true</kotlin.compiler.incremental>
```

```xml
            <!-- kotlin-->
            <dependency>
                <groupId>org.jetbrains.kotlin</groupId>
                <artifactId>kotlin-stdlib-jdk8</artifactId>
                <version>${kotlin.version}</version>
            </dependency>
            <dependency>
                <groupId>org.jetbrains.kotlin</groupId>
                <artifactId>kotlin-test</artifactId>
                <version>${kotlin.version}</version>
                <scope>test</scope>
            </dependency>
            <dependency>
                <groupId>org.jetbrains.kotlin</groupId>
                <artifactId>kotlin-reflect</artifactId>
                <version>${kotlin.version}</version>
            </dependency>
```

## 添加 jpa数据库配置
在 admin模块中的`application-druid.yml`添加
```yaml
spring:
    jpa:
        hibernate:
            ddl-auto: update
        open-in-view: false
        show-sql: true
        generate-ddl: true
        properties:
            hibernate:
                dialect: org.hibernate.dialect.MySQL5InnoDBDialect
                format_sql: true
    datasource:
        url: jdbc:mysql://localhost:3306/ry-vue?serverTimezone=Asia/Shanghai
        username: root
        password: 123456
```

## 添加 maven编译插件
在模块中创建对应的 kotlin代码目录，我这里是`src/main/java/com/ruoyi/kotlin`
```xml
<!--            kotlin编译-->
            <plugin>
                <groupId>org.jetbrains.kotlin</groupId>
                <artifactId>kotlin-maven-plugin</artifactId>
                <version>${kotlin.version}</version>
                <executions>
                    <execution>
                        <id>compile</id>
                        <phase>process-sources</phase>
                        <goals>
                            <goal>compile</goal>
                        </goals>
                        <configuration>
                            <sourceDirs>
                                <sourceDir>${project.basedir}/src/main/java/com/ruoyi/kotlin</sourceDir>
                                <sourceDir>${project.basedir}/src/main/java</sourceDir>
                            </sourceDirs>
                        </configuration>
                    </execution>
                    <execution>
                        <id>test-compile</id>
                        <goals> <goal>test-compile</goal> </goals>
                        <configuration>
                            <sourceDirs>
                                <sourceDir>${project.basedir}/src/test/kotlin</sourceDir>
                                <sourceDir>${project.basedir}/src/test/java</sourceDir>
                            </sourceDirs>
                        </configuration>
                    </execution>
                </executions>
            </plugin>
```

## 编辑`BaseEntity`类
```java
package com.ruoyi.common.core.domain;

import java.io.Serializable;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;
import com.fasterxml.jackson.annotation.JsonFormat;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude;

import javax.persistence.MappedSuperclass;
import javax.persistence.Transient;

/**
 * Entity基类
 * 
 * @author ruoyi
 */

@MappedSuperclass
public class BaseEntity implements Serializable
{
    private static final long serialVersionUID = 1L;

    /** 搜索值 */
    @JsonIgnore
    private String searchValue;

    /** 创建者 */
    private String createBy;

    /** 创建时间 */
    @JsonFormat(pattern = \"yyyy-MM-dd HH:mm:ss\", timezone = \"GMT+8\")
    private Date createTime;

    /** 更新者 */
    private String updateBy;

    /** 更新时间 */
    @JsonFormat(pattern = \"yyyy-MM-dd HH:mm:ss\", timezone = \"GMT+8\")
    private Date updateTime;

    /** 备注 */
    private String remark;

    /** 请求参数 */
    @JsonInclude(JsonInclude.Include.NON_EMPTY)
    @Transient
    private Map<String, Object> params;

    public String getSearchValue()
    {
        return searchValue;
    }

    public void setSearchValue(String searchValue)
    {
        this.searchValue = searchValue;
    }

    public String getCreateBy()
    {
        return createBy;
    }

    public void setCreateBy(String createBy)
    {
        this.createBy = createBy;
    }

    public Date getCreateTime()
    {
        return createTime;
    }

    public void setCreateTime(Date createTime)
    {
        this.createTime = createTime;
    }

    public String getUpdateBy()
    {
        return updateBy;
    }

    public void setUpdateBy(String updateBy)
    {
        this.updateBy = updateBy;
    }

    public Date getUpdateTime()
    {
        return updateTime;
    }

    public void setUpdateTime(Date updateTime)
    {
        this.updateTime = updateTime;
    }

    public String getRemark()
    {
        return remark;
    }

    public void setRemark(String remark)
    {
        this.remark = remark;
    }

    @Transient
    public Map<String, Object> getParams()
    {
        if (params == null)
        {
            params = new HashMap<>();
        }
        return params;
    }

    public void setParams(Map<String, Object> params)
    {
        this.params = params;
    }
}

```

## 编辑 `SysUser`类
```java
package com.ruoyi.common.core.domain.entity;

import java.util.Date;
import java.util.List;
import javax.persistence.Entity;
import javax.persistence.Id;
import javax.persistence.Table;
import javax.persistence.Transient;
import javax.validation.constraints.*;
import org.apache.commons.lang3.builder.ToStringBuilder;
import org.apache.commons.lang3.builder.ToStringStyle;
import com.ruoyi.common.annotation.Excel;
import com.ruoyi.common.annotation.Excel.ColumnType;
import com.ruoyi.common.annotation.Excel.Type;
import com.ruoyi.common.annotation.Excels;
import com.ruoyi.common.core.domain.BaseEntity;
import com.ruoyi.common.xss.Xss;

/**
 * 用户对象 sys_user
 *
 * @author ruoyi
 */
@Entity
@Table(name = \"sys_user\")
public class SysUser extends BaseEntity
{
    private static final long serialVersionUID = 1L;

    /** 用户ID */
    @Excel(name = \"用户序号\", type = Type.EXPORT, cellType = ColumnType.NUMERIC, prompt = \"用户编号\")
    @Id
    private Long userId;

    /** 部门ID */
    @Excel(name = \"部门编号\", type = Type.IMPORT)
    private Long deptId;

    /** 用户账号 */
    @Excel(name = \"登录名称\")
    private String userName;

    /** 用户昵称 */
    @Excel(name = \"用户名称\")
    private String nickName;

    /** 用户邮箱 */
    @Excel(name = \"用户邮箱\")
    private String email;

    /** 手机号码 */
    @Excel(name = \"手机号码\", cellType = ColumnType.TEXT)
    private String phonenumber;

    /** 用户性别 */
    @Excel(name = \"用户性别\", readConverterExp = \"0=男,1=女,2=未知\")
    private String sex;

    /** 用户头像 */
    private String avatar;

    /** 密码 */
    private String password;

    /** 帐号状态（0正常 1停用） */
    @Excel(name = \"帐号状态\", readConverterExp = \"0=正常,1=停用\")
    private String status;

    /** 删除标志（0代表存在 2代表删除） */
    private String delFlag;

    /** 最后登录IP */
    @Excel(name = \"最后登录IP\", type = Type.EXPORT)
    private String loginIp;

    /** 最后登录时间 */
    @Excel(name = \"最后登录时间\", width = 30, dateFormat = \"yyyy-MM-dd HH:mm:ss\", type = Type.EXPORT)
    private Date loginDate;

    /** 部门对象 */
    @Excels({
        @Excel(name = \"部门名称\", targetAttr = \"deptName\", type = Type.EXPORT),
        @Excel(name = \"部门负责人\", targetAttr = \"leader\", type = Type.EXPORT)
    })
    private SysDept dept;

    /** 角色对象 */
    @Transient
    private List<SysRole> roles;

    /** 角色组 */
    @Transient
    private Long[] roleIds;

    /** 岗位组 */
    @Transient
    private Long[] postIds;

    /** 角色ID */
    private Long roleId;

    public SysUser()
    {

    }

    public SysUser(Long userId)
    {
        this.userId = userId;
    }

    public Long getUserId()
    {
        return userId;
    }

    public void setUserId(Long userId)
    {
        this.userId = userId;
    }

    public boolean isAdmin()
    {
        return isAdmin(this.userId);
    }

    public static boolean isAdmin(Long userId)
    {
        return userId != null && 1L == userId;
    }

    public Long getDeptId()
    {
        return deptId;
    }

    public void setDeptId(Long deptId)
    {
        this.deptId = deptId;
    }

    @Xss(message = \"用户昵称不能包含脚本字符\")
    @Size(min = 0, max = 30, message = \"用户昵称长度不能超过30个字符\")
    public String getNickName()
    {
        return nickName;
    }

    public void setNickName(String nickName)
    {
        this.nickName = nickName;
    }

    @Xss(message = \"用户账号不能包含脚本字符\")
    @NotBlank(message = \"用户账号不能为空\")
    @Size(min = 0, max = 30, message = \"用户账号长度不能超过30个字符\")
    public String getUserName()
    {
        return userName;
    }

    public void setUserName(String userName)
    {
        this.userName = userName;
    }

    @Email(message = \"邮箱格式不正确\")
    @Size(min = 0, max = 50, message = \"邮箱长度不能超过50个字符\")
    public String getEmail()
    {
        return email;
    }

    public void setEmail(String email)
    {
        this.email = email;
    }

    @Size(min = 0, max = 11, message = \"手机号码长度不能超过11个字符\")
    public String getPhonenumber()
    {
        return phonenumber;
    }

    public void setPhonenumber(String phonenumber)
    {
        this.phonenumber = phonenumber;
    }

    public String getSex()
    {
        return sex;
    }

    public void setSex(String sex)
    {
        this.sex = sex;
    }

    public String getAvatar()
    {
        return avatar;
    }

    public void setAvatar(String avatar)
    {
        this.avatar = avatar;
    }

    public String getPassword()
    {
        return password;
    }

    public void setPassword(String password)
    {
        this.password = password;
    }

    public String getStatus()
    {
        return status;
    }

    public void setStatus(String status)
    {
        this.status = status;
    }

    public String getDelFlag()
    {
        return delFlag;
    }

    public void setDelFlag(String delFlag)
    {
        this.delFlag = delFlag;
    }

    public String getLoginIp()
    {
        return loginIp;
    }

    public void setLoginIp(String loginIp)
    {
        this.loginIp = loginIp;
    }

    public Date getLoginDate()
    {
        return loginDate;
    }

    public void setLoginDate(Date loginDate)
    {
        this.loginDate = loginDate;
    }

    public SysDept getDept()
    {
        return dept;
    }

    public void setDept(SysDept dept)
    {
        this.dept = dept;
    }

    public List<SysRole> getRoles()
    {
        return roles;
    }

    public void setRoles(List<SysRole> roles)
    {
        this.roles = roles;
    }

    public Long[] getRoleIds()
    {
        return roleIds;
    }

    public void setRoleIds(Long[] roleIds)
    {
        this.roleIds = roleIds;
    }

    public Long[] getPostIds()
    {
        return postIds;
    }

    public void setPostIds(Long[] postIds)
    {
        this.postIds = postIds;
    }

    public Long getRoleId()
    {
        return roleId;
    }

    public void setRoleId(Long roleId)
    {
        this.roleId = roleId;
    }

    @Override
    public String toString() {
        return new ToStringBuilder(this,ToStringStyle.MULTI_LINE_STYLE)
            .append(\"userId\", getUserId())
            .append(\"deptId\", getDeptId())
            .append(\"userName\", getUserName())
            .append(\"nickName\", getNickName())
            .append(\"email\", getEmail())
            .append(\"phonenumber\", getPhonenumber())
            .append(\"sex\", getSex())
            .append(\"avatar\", getAvatar())
            .append(\"password\", getPassword())
            .append(\"status\", getStatus())
            .append(\"delFlag\", getDelFlag())
            .append(\"loginIp\", getLoginIp())
            .append(\"loginDate\", getLoginDate())
            .append(\"createBy\", getCreateBy())
            .append(\"createTime\", getCreateTime())
            .append(\"updateBy\", getUpdateBy())
            .append(\"updateTime\", getUpdateTime())
            .append(\"remark\", getRemark())
            .append(\"dept\", getDept())
            .toString();
    }
}


```

## 在`common`模块中添加依赖
```xml
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-jpa</artifactId>
            <version>${spring-boot.version}</version>
        </dependency>
```

## 若依 openapi连接地址
```bash
http://localhost:1024/dev-api/v3/api-docs
```
扫描所有，找到SwaggerConfig这个类开启', '', NULL, 2, 0, true, '2025-02-19 13:50:12.874000');
INSERT INTO blogs (id, title, slug, author, content, html, thumbnail, category_id, view_count, is_published, created_at) VALUES (1302, 'UE5&C++ 在 AIController中绑定行为树，和黑板初始化', 'blog-1302', '梁典典', '注意事项
* 绑定黑板不要在构造函数中写
* 建议在OnPossess函数绑定
## 定义行为树

```c++
	UPROPERTY(EditAnywhere,BlueprintReadWrite, Category = \"AI\")
	UBehaviorTree* BehaviorTreeAsset; // 关联编辑器中的行为树资源
```

## 绑定黑板
```c++
void AMyEnemyAIControllerBase::OnPossess(APawn* InPawn)
{
	Super::OnPossess(InPawn);
	BindBlackboardValue();
	if (const auto Enemy = Cast<AMyEnemyBase>(InPawn))
	{
		Enemy->GetCharacterMovement()->bOrientRotationToMovement = true;
		SetEnemyOutlet(Enemy->TryGetOutlet());
	}
	//运行行为树
	if (BehaviorTreeAsset)
	{
		RunBehaviorTree(BehaviorTreeAsset);
	}
	
}

void AMyEnemyAIControllerBase::BindBlackboardValue()
{
	if (BehaviorTreeAsset)
	{
		UBlackboardComponent* MyBlackboard = nullptr;
		UseBlackboard(BehaviorTreeAsset->BlackboardAsset, MyBlackboard);
	}
}

void AMyEnemyAIControllerBase::SetEnemyOutlet(AMyOutletBase* OutletBase) const
{
	if (OutletBase && BehaviorTreeAsset && Blackboard)
	{
		Blackboard->SetValueAsObject(TEXT(\"Outlet\"), OutletBase);
		UE_LOG(LogTemp, Log, TEXT(\"设置出怪口成功(黑板)\"))
	}else
	{
		UE_LOG(LogTemp, Error, TEXT(\"设置出怪口失败\"));
	}
}
```

## 完整的代码

`AMyEnemyAIControllerBase.h`
```c++
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include \"CoreMinimal.h\"
#include \"Actor/Outlet/MyOutletBase.h\"
#include \"Runtime/AIModule/Classes/AIController.h\"
#include \"MyEnemyAIControllerBase.generated.h\"


/**
 * 怪物的AI控制器,不能直接使用
 */
UCLASS(ABstract)
class DEMO2_API AMyEnemyAIControllerBase : public AAIController
{
	GENERATED_BODY()

public:
	AMyEnemyAIControllerBase();

	/// 控制胖时调用
	virtual void OnPossess(APawn* InPawn) override;

	UPROPERTY(EditAnywhere,BlueprintReadWrite, Category = \"AI\")
	UBehaviorTree* BehaviorTreeAsset; // 关联编辑器中的行为树资源
	
	
protected:

	
	virtual void BeginPlay() override;

	UFUNCTION()
	void SetEnemyOutlet(AMyOutletBase* OutletBase) const;


	UFUNCTION()
	void BindBlackboardValue();
	
public:
	virtual void Tick(float DeltaTime) override;

};

```

`AMyEnemyAIControllerBase.cpp`
```c++
// Fill out your copyright notice in the Description page of Project Settings.


#include \"AI/MyEnemyAIControllerBase.h\"

#include \"BehaviorTree/BehaviorTree.h\"
#include \"BehaviorTree/BlackboardComponent.h\"
#include \"GameFramework/CharacterMovementComponent.h\"
#include \"Navigation/PathFollowingComponent.h\"
#include \"Tool/MyCoreTool.h\"
#include \"Tool/MyLogTool.h\"


AMyEnemyAIControllerBase::AMyEnemyAIControllerBase(): BehaviorTreeAsset(nullptr)
{
	PrimaryActorTick.bCanEverTick = false;
}


/// 控制胖时调用,可以设置初始目标和行为树 
void AMyEnemyAIControllerBase::OnPossess(APawn* InPawn)
{
	Super::OnPossess(InPawn);
	BindBlackboardValue();
	if (const auto Enemy = Cast<AMyEnemyBase>(InPawn))
	{
		Enemy->GetCharacterMovement()->bOrientRotationToMovement = true;
		SetEnemyOutlet(Enemy->TryGetOutlet());
	}
	//运行行为树
	if (BehaviorTreeAsset)
	{
		RunBehaviorTree(BehaviorTreeAsset);
	}
	
}

void AMyEnemyAIControllerBase::BeginPlay()
{
	Super::BeginPlay();
}



void AMyEnemyAIControllerBase::SetEnemyOutlet(AMyOutletBase* OutletBase) const
{
	if (OutletBase && BehaviorTreeAsset && Blackboard)
	{
		Blackboard->SetValueAsObject(TEXT(\"Outlet\"), OutletBase);
		UE_LOG(LogTemp, Log, TEXT(\"设置出怪口成功(黑板)\"))
	}else
	{
		UE_LOG(LogTemp, Error, TEXT(\"设置出怪口失败\"));
	}
}


void AMyEnemyAIControllerBase::BindBlackboardValue()
{
	if (BehaviorTreeAsset)
	{
		UBlackboardComponent* MyBlackboard = nullptr;
		UseBlackboard(BehaviorTreeAsset->BlackboardAsset, MyBlackboard);
	}
}


void AMyEnemyAIControllerBase::Tick(float DeltaTime)
{
	Super::Tick(DeltaTime);
}


```', '', NULL, 202, 0, true, '2025-03-13 17:20:42.265000');
INSERT INTO blogs (id, title, slug, author, content, html, thumbnail, category_id, view_count, is_published, created_at) VALUES (1352, 'Swift对比Kotlin协程', 'blog-1352', '梁典典', 'Swift 的异步编程模型（Swift Concurrency）和 Kotlin 协程在目标上类似，都旨在简化异步代码的编写，但在实现和语法上有一些不同。以下是 Swift 中类似 Kotlin 协程的操作和特性：

---

### 1. **`async`/`await` 语法**
Swift 5.5 引入了 `async`/`await` 语法，允许开发者以同步的方式编写异步代码，类似 Kotlin 协程的挂起函数：
```swift
// Swift 示例
func fetchData() async throws -> Data {
    let url = URL(string: \"https://example.com\")!
    let (data, _) = try await URLSession.shared.data(from: url)
    return data
}

// 调用异步函数
Task {
    do {
        let data = try await fetchData()
        print(\"Data received: \\(data)\")
    } catch {
        print(\"Error: \\(error)\")
    }
}
```
Kotlin 协程的等效代码：
```kotlin
// Kotlin 示例
suspend fun fetchData(): Data {
    return withContext(Dispatchers.IO) {
        URL(\"https://example.com\").readBytes()
    }
}

// 启动协程
viewModelScope.launch {
    try {
        val data = fetchData()
        println(\"Data received: $data\")
    } catch (e: Exception) {
        println(\"Error: $e\")
    }
}
```

---

### 2. **结构化并发（Structured Concurrency）**
Swift 通过 `Task` 和 `TaskGroup` 实现结构化并发，确保子任务的生命周期与父任务绑定（类似 Kotlin 协程的作用域）：
```swift
// Swift 示例
func processMultipleRequests() async {
    await withTaskGroup(of: Data.self) { group in
        for url in urls {
            group.addTask {
                let (data, _) = try await URLSession.shared.data(from: url)
                return data
            }
        }
        
        // 收集结果
        for await result in group {
            print(\"Received data: \\(result)\")
        }
    }
}
```
类似 Kotlin 的 `coroutineScope`：
```kotlin
// Kotlin 示例
suspend fun processMultipleRequests() = coroutineScope {
    val deferredList = urls.map { url ->
        async(Dispatchers.IO) {
            URL(url).readBytes()
        }
    }
    deferredList.awaitAll().forEach { data ->
        println(\"Received data: $data\")
    }
}
```

---

### 3. **调度器与线程切换**
Kotlin 协程通过 `Dispatchers`（如 `Dispatchers.IO`、`Dispatchers.Main`）切换线程，而 Swift 通过 `Task` 的调度器参数或 `MainActor` 实现主线程切换：
```swift
// Swift 示例
Task { 
    // 默认在后台线程执行
    let data = await fetchData()
    
    // 切回主线程更新 UI
    await MainActor.run {
        self.label.text = \"Data loaded\"
    }
}
```

---

### 4. **取消与协作式任务**
Swift 的 `Task` 支持取消操作，通过检查 `Task.isCancelled` 或调用 `Task.cancel()`：
```swift
let task = Task {
    guard !Task.isCancelled else { return }
    // 执行耗时操作
}

// 取消任务
task.cancel()
```
类似 Kotlin 协程的 `Job.cancel()`。

---

### 5. **`AsyncSequence` 与 Flow**
Swift 的 `AsyncSequence` 允许按需异步生成值（类似 Kotlin 的 `Flow`）：
```swift
// Swift 示例
func countNumbers() async {
    let stream = AsyncStream(Int.self) { continuation in
        Task {
            for i in 1...10 {
                continuation.yield(i)
                try await Task.sleep(nanoseconds: 1_000_000_000)
            }
            continuation.finish()
        }
    }
    
    for await number in stream {
        print(number)
    }
}
```

---

### 主要区别
| 特性               | **Swift Concurrency**                     | **Kotlin 协程**                     |
|--------------------|------------------------------------------|-------------------------------------|
| **语法**           | `async`/`await` + `Task`                 | `suspend` + `launch`/`async`       |
| **调度器**         | `MainActor`、全局 Actor                  | `Dispatchers.Main`、`Dispatchers.IO`|
| **底层机制**       | 编译器生成状态机 + Continuation          | 状态机 + 挂起函数                  |
| **结构化并发**     | `TaskGroup`、`async let`                 | `coroutineScope`、`supervisorScope`|

---

### 总结
- **Swift Concurrency**（`async`/`await` + `Task` + Actor）提供了与 Kotlin 协程类似的能力，核心目标都是简化异步代码。
- 如果需要更细粒度的控制（如自定义线程池），可以结合 `DispatchQueue` 使用，但官方推荐优先使用 Swift 的原生并发模型。
- 学习资源：[Swift 并发官方文档](https://docs.swift.org/swift-book/LanguageGuide/Concurrency.html)。', '', NULL, 3, 0, true, '2025-03-27 17:37:03.474000');
INSERT INTO blogs (id, title, slug, author, content, html, thumbnail, category_id, view_count, is_published, created_at) VALUES (1402, 'idea插件开发创建 PsiElement引用', 'blog-1402', '梁典典', '# 需求

按住ctrl+点击资产字符串打开这个文件

# 扩展点

```xml

<psi.referenceContributor
        implementation=\"shop.itbug.fluttercheckversionx.reference.AssetReferenceContributor\"
        language=\"Dart\"
/>
```

# 实现

```kotlin
class AssetReferenceContributor : PsiReferenceContributor() {
    override fun registerReferenceProviders(registrar: PsiReferenceRegistrar) {
        registrar.registerReferenceProvider(
            PlatformPatterns.psiElement(DartStringLiteralExpressionImpl::class.java),
            AssetReferenceProvider()
        )
    }
}

internal class AssetReferenceProvider : PsiReferenceProvider() {

    override fun getReferencesByElement(
        element: PsiElement,
        context: ProcessingContext
    ): Array<out PsiReference?> {
        val dartStringLiteral = element as? DartStringLiteralExpressionImpl ?: return PsiReference.EMPTY_ARRAY
        val fileResult = DartPsiElementHelper.checkHasFile(dartStringLiteral)
        if (fileResult != null) {
            return arrayOf<PsiReference>(AssetPsiReference(dartStringLiteral, fileResult))
        }
        return PsiReference.EMPTY_ARRAY
    }
}

internal class AssetPsiReference(
    element: DartStringLiteralExpressionImpl,
    private val fileResult: DartStringIconShowInlay.FileResult
) :
    PsiReferenceBase<PsiElement?>(element, TextRange(1, element.string!!.length + 1)) {
    override fun resolve(): PsiElement? {
        val project = runReadAction { element.project }
        val relativePath = fileResult.basePath
        val projectRoot = runReadAction { project }.guessProjectDir() ?: return null
        val targetFile = projectRoot.findFileByRelativePath(relativePath) ?: return null
        return runReadAction { PsiManager.getInstance(project).findFile(targetFile) }
    }
}

```', '', NULL, 3, 0, true, '2025-04-02 10:33:38.488000');
INSERT INTO blogs (id, title, slug, author, content, html, thumbnail, category_id, view_count, is_published, created_at) VALUES (1452, 'Docker 部署 Nexus 搭建 Maven 私服', 'blog-1452', '梁典典', '## 拉取镜像
登录云服务器
```bash
docker pull sonatype/nexus3
```
## 创建挂载文件
```bash
mkdir -p /data/nexus3
chown -R 200:200 /data/nexus3
```

## 运行
限制启动内存为 512M
```bash
docker run -d -p 8981:8081 -p 8982:8082 --name nexus \\
--restart=always --privileged=true \\
-e NEXUS_CONTEXT=nexus -e \"INSTALL4J_ADD_VM_PARAMS=-Xms128m -Xmx512m -XX:MaxDirectMemorySize=512m -Djava.util.prefs.userRoot=/nexus-data/javaprefs\" \\
-v /data/nexus3:/nexus-data sonatype/nexus3:latest
```

## 查看管理员密码
```bash
docker exec -it nexus /bin/bash
cat /nexus-data/admin.password
```', '', NULL, 152, 0, true, '2025-04-02 16:08:58.513000');
INSERT INTO blogs (id, title, slug, author, content, html, thumbnail, category_id, view_count, is_published, created_at) VALUES (1502, 'CMakefiles.txt基础', 'blog-1502', '梁典典', '```makefile
cmake_minimum_required(VERSION 4.0)
project(cmake)

set(CMAKE_CXX_STANDARD 20)

if (\" ${CMAKE_SOURCE_DIR}\" STREQUAL \" ${CMAKE_BINARY_DIR}\")
    MESSAGE(FATAL_ERROR \"错误: 禁止源码内编译
    请为构建文件创建一个单独的目录
\")
endif ()

add_executable(cmake main.cpp
        mylib.cpp
        mylib.h)


#使用 option变量
option(BUILD_MYLIB \"构建mylib目标\")
if (BUILD_MYLIB)
    add_library(MyLib
            mylib.cpp
            mylib.h)
else ()
    message(\"忽略构建mylib目标\")
endif ()


# for循环
set(list1 2 4 6 8)
set(list2 1 3 5 7)
foreach (v IN LISTS list1 list2)
    message(\"v = ${v}\")
endforeach ()
message(\"============================\")
foreach (v IN ITEMS 1 2 3 4 5 6 7 8)
    message(\"v = ${v}\")
endforeach ()
message(\"==========================\")
foreach (v 1 2 3 4 5 6 7)
    message(\"v = ${v}\")
endforeach ()
message(\"==========================\")
foreach (v IN ITEMS ${list1})
    message(\"v= ${v}\")
endforeach ()

message(\" zip list ========分别获取列表中的2个元素 \")
foreach (v IN ZIP_LISTS list1 list2)
    message(\"v : (${v_0},${v_1})\")
endforeach ()
message(\"设置步长\")
set(start 1)
set(end 8)
set(step 2)
foreach (v RANGE ${start} ${end} ${step})
    message(\"v=${v}\")
endforeach ()
#设置步长
#v=1
#v=3
#v=5
#v=7


#=========函数


function(my_function a b)
    message(\"========================\")
    message(\"a=${a},b=${b}\")
    message(\"========================\")
    message(\"argc:${ARGC}\")
    message(\"argv: ${ARGV}\")
    message(\"argv0: ${ARGV0},argv1:${ARGV1}\")
    message(\"argn:${ARGN}\")
endfunction()

my_function(hello world 3 4 5)


#=====未命名参数
# ARGC 参数的数量
# ARGV 参数列表
# ARGN 未命名参数列表
# 还可以用ARGV0 ARGV1 来代码第0个，第一个参数


#=======关键字参数
function(my_function2 targetName)
    message(\"==========my function2 ===========\")
    message(\"targetName:${targetName}\")
    message(\"argv:${ARGV}\")
endfunction()


my_function2(USE_LIB
        MYLIB_PATH \"/usr/local/lib\"
        SOURCE \"main.cpp\"
        INCLUDES \"include\" \"include2\"
)

# 输出
#==========my function2===========
#targetName:USE_LIB
#argv:USE_LIB;MYLIB_PATH;/usr/local/lib;SOURCE;main.cpp;INCLUDES;include;include2


# 参数解析: cmake_parse_arguments
function(my_function3 targetName)
    set(options USE_MYLIB)
    set(oneValueArgs MYLIB_PATH)
    set(multiValueArgs SOURCES INCLUDES)
    cmake_parse_arguments(arg_myfunction3 \"${options}\" \"${oneValueArgs}\" \"${multiValueArgs}\" ${ARGN})
    message(\"
        USE_MYLIB:${arg_myfunction3_USE_MYLIB}
        MYLIB_PATH:${arg_myfunction3_MYLIB_PATH}
        SOURCE:${arg_myfunction3_SOURCES}
        INCLUDES:${arg_myfunction3_INCLUDES}
        targetName:${targetName}

    \")
endfunction()

my_function3(USE_LIB
        MYLIB_PATH \"/usr/local/lib\"
        SOURCES \"main.cpp\"
        INCLUDES \"include\" \"include2\"
)
#输出
#USE_MYLIB:FALSE
#MYLIB_PATH:/usr/local/lib
#SOURCE:main.cpp
#INCLUDES:include;include2
#targetName:USE_LIB

# un parsed arguments 和 keywords missing values

function(my_function4 targetName)
    set(options USE_MYLIB)
    set(oneValueArgs MYLIB_PATH)
    set(multiValueArgs SOURCES INCLUDES)
    cmake_parse_arguments(arg_myfunction4 \"${options}\" \"${oneValueArgs}\" \"${multiValueArgs}\" ${ARGN})
    message(\"=my function4=============================\")
    message(\"
            UNPARSED_ARGUMENTS:${arg_myfunction4_UNPARSED_ARGUMENTS}
            KEYWORDS_MISSING_VALUES: ${arg_myfunction4_KEYWORDS_MISSING_VALUES}
    \")
endfunction()

my_function4(hello
        MYLIB_PATH \"/usr/local/lib\" \"/usr/local/lib2\"
        SOURCES
        INCLUDES \"include\" \"include2\"
)

#=my function4=============================
#
#UNPARSED_ARGUMENTS:/usr/local/lib2
#KEYWORDS_MISSING_VALUES: SOURCES



# 函数返回值: 方式1
function(my_fun1 returnValue)
    set(${returnValue} \"hello world\" PARENT_SCOPE)
endfunction()
my_fun1(result)
message(\"result:${result}\") # hello world

#方式2 return 命令
function(my_fun2 returnValue)
    set(${returnValue} \"hello world2\")
    return(PROPAGATE ${returnValue})
endfunction()

my_fun2(result)
message(\"result2=${result}\") #result2=hello world2


# 宏

function(my_fun3 a)
   message(\"================my_fun3==============\")
    if(a)
        message(\"===> a is true\")
    elseif ()
        message(\"===> a is false\")
    endif ()
endfunction()

macro(my_macro a )
    message(\"===============my macro==================\")
    if(a)
        message(\"===> a  is true\")
    else()
        message(\"===> a is false\")
    endif ()
endmacro()


my_fun3(hello) # true  在函数中参数a用做变量来判断。不是FALSE 常量，所以为true
my_macro(hello) # false 宏参数最终会替换成字符串hello, 字符串除了常量TRUE以外都为假



## 宏里面不能使用return 否则会导致整个代码提前返回






# list
message(\"===============list ================\")
set(listVar a b c)
list(LENGTH listVar listLen) # 获取长度
message(\"list length is ${listLen}\") # list length is 3

list(GET listVar 0 firstItem) # 获取第0个元素
message(\"first item is ${firstItem}\") # first item is a

list(APPEND listVar d)  # 末尾追加元素
list(JOIN listVar \"-\" outtStr)  # 使用连接符链接起来
message(\"outtStr:${outtStr}\") # outtStr:a-b-c-d


# string 字符串
message(\"=================string 字符串===================\")
string(FIND interesting in fIndex) # 在字符串‘interesting’中查找 ‘in’ 的下标
string(FIND interesting in rIndex REVERSE) # 反向查找
message(\"fIndex=${fIndex}\")  # fIndex=0
message(\"rIndex=${rIndex}\")  # fIndex=8


# math 命令
message(\"================math===========\")
math(EXPR a 1+2*6/2)
math(EXPR b ${a}*3)
message(\"a=${a}\
b=${b}\") #a=7 b=21


# file命令
file(GLOB varFilelist LIST_DIRECTORIES false CONFIGURE_DEPENDS RELATIVE ${CMAKE_SOURCE_DIR} \"*.cpp\")
message(\"var file list :${varFilelist}\")  # var file list :main.cpp;mylib.cpp

# CONFIGURE_DEPENDS 如果文件列表发送了变化，则重新构建生成，不建议使用
# add_executable(MyApp ${varFilelist})

```', '', NULL, 52, 0, true, '2025-05-24 10:54:03.696000');
INSERT INTO blogs (id, title, slug, author, content, html, thumbnail, category_id, view_count, is_published, created_at) VALUES (1504, 'rust 1.88 新特性，if let 链，裸指针，cfg新判断 ', 'blog-1504', '梁典典', '
编译要加--edition 2024 不然会报错
```bash
rustc --edition 2024 new_future.rs
```

```rust

use std::cell::Cell;

enum UserStatus {
    Active(u32,String),
    Inactive,
    Pending
}

fn get_current_user_status() -> UserStatus {
    UserStatus::Active(922111,\"梁典典\".to_string())
}


// cfg - 总会被调用
#[cfg(true)]
fn feature_always_on(){
    println!(\"这个函数总是会被调用\");
}

// cfg - 永远不编译
#[cfg(false)]
fn feature_never_compiled(){
     println!(\"这个函数永远不会被编译\");
}


// cfg - 仅在特定条件下编译
#[cfg(all(target_os = \"linux\",true))] // true 结合其他条件
fn linux_specific_function(){
    println!(\"这个函数仅在特定条件下编译\");
}




// 1.88 新特性
fn main(){

    feature_always_on();
    #[cfg(target_os = \"linux\")]
    linux_specific_function();

    if let UserStatus::Active(id,name) = get_current_user_status() && id>100000 && id < 199999 && name.len() > 5{
        println!(\"{}\",name);
    }else{
        println!(\"不符合要求\");
    }


    //cell update
    let count = Cell::new(0);
    count.update(|x| x + 1);
    println!(\"count: {}\", count.get());


    let default_const_ptr: *const u32 =  Default::default();
    let default_mut_ptr: *mut String = Default::default();

    println!(\"default_const_ptr: {:?}, default_mut_ptr: {:?}\", default_const_ptr, default_mut_ptr);
}
```

输出
```bash
$ ./new_future
这个函数总是会被调用
不符合要求
count: 1
default_const_ptr: 0x0, default_mut_ptr: 0x0
```', '', NULL, 102, 0, true, '2025-07-23 11:59:03.729000');
INSERT INTO blogs (id, title, slug, author, content, html, thumbnail, category_id, view_count, is_published, created_at) VALUES (1505, 'idea 插件开发之使用内置依赖，比如 ktor的 CIO', 'blog-1505', '梁典典', '## 声明依赖
使用bundledModule函数声明依赖jar包名字
```kotlin

dependencies {
    implementation(\"org.smartboot.socket:aio-pro:latest.release\")
    testImplementation(\"junit:junit:latest.release\")
    testRuntimeOnly(\"org.junit.jupiter:junit-jupiter-engine:latest.release\")
    intellijPlatform {
        testFramework(TestFrameworkType.Platform)
        when (ideType) {
            \"243\" -> {
                intellijIdeaCommunity(\"2024.3.5\")
            }

            \"251\" -> {
                intellijIdeaCommunity(\"251.26094.98\")
            }
        }
        bundledPlugins(bPlugins)
        plugins(\"Dart:$dartVersion\")
        pluginVerifier()
        zipSigner()
        javaCompiler()

        bundledModule(\"intellij.libraries.ktor.client\") // <--------- 关键点
        bundledModule(\"intellij.libraries.ktor.client.cio\") // <--------- 关键点

    }

}
```
jar包名字可以在这个地方找到
![image.png](https://minio.itbug.shop/blog/simple-file/image___1753405805912___.png)

我这里用的是这 2 个
![image.png](https://minio.itbug.shop/blog/simple-file/image___1753405855132___.png)

# 打包进插件
在 plugin.xml声明 module
```xml
<idea-plugin>
    <dependencies>
        <plugin id=\"com.intellij.modules.platform\"/>
        <plugin id=\"org.jetbrains.plugins.yaml\"/>
        <plugin id=\"Dart\"/>
        <plugin id=\"org.intellij.plugins.markdown\"/>
        <plugin id=\"org.jetbrains.plugins.terminal\"/>
        <plugin id=\"com.intellij.modules.json\"/>
        <plugin id=\"com.intellij.gradle\"/>
        <plugin id=\"com.intellij.platform.images\"/>
        <plugin id=\"org.jetbrains.plugins.gradle\"/>
        <plugin id=\"org.intellij.groovy\"/>


        <module name=\"intellij.libraries.ktor.client\"/>  <!-- 这里-->
        <module name=\"intellij.libraries.ktor.client.cio\"/> <!-- 这里-->

    </dependencies>
</idea-plugin>
```
这样就不会运行中报找到类的错误了

相关 issues
[https://github.com/JetBrains/intellij-platform-gradle-plugin/issues/1979](https://github.com/JetBrains/intellij-platform-gradle-plugin/issues/1979)', '', NULL, 3, 0, true, '2025-07-25 09:13:57.309000');
INSERT INTO blogs (id, title, slug, author, content, html, thumbnail, category_id, view_count, is_published, created_at) VALUES (1552, 'idea 插件开发之使用 Jewel (idea 风格的Compose)', 'blog-1552', '梁典典', '# 添加plugins + dependencies
```kotlin
plugins {
    id(\"org.jetbrains.compose\") version \"1.8.2\"
    id(\"org.jetbrains.kotlin.plugin.compose\") version \"2.1.20\"
}


dependencies {
    implementation(\"org.smartboot.socket:aio-pro:latest.release\")
    testImplementation(\"junit:junit:latest.release\")
    testRuntimeOnly(\"org.junit.jupiter:junit-jupiter-engine:latest.release\")

    intellijPlatform {
        when (ideType) {
            \"252\" -> {
                intellijIdea(\"2025.2\")
            }

            \"251\" -> {
//                intellijIdeaCommunity(\"2025.1.4.1\")
                local(\"/Applications/Android Studio.app\")
            }
        }
        bundledPlugins(bPlugins)
        //\"io.flutter:87.1\"
        plugins(\"Dart:$dartVersion\", \"io.flutter:87.1\")
        pluginVerifier()
        zipSigner()
        javaCompiler()

        bundledModule(\"intellij.libraries.ktor.client\")
        bundledModule(\"intellij.libraries.ktor.client.cio\")

        testBundledModules(\"intellij.libraries.ktor.client\", \"intellij.libraries.ktor.client.cio\")

        testFramework(TestFrameworkType.Platform)



        // jewel
        bundledModule(\"intellij.platform.jewel.foundation\")
        bundledModule(\"intellij.platform.jewel.ui\")
        bundledModule(\"intellij.platform.jewel.ideLafBridge\")
        bundledModule(\"intellij.platform.jewel.markdown.core\")
        bundledModule(\"intellij.platform.jewel.markdown.ideLafBridgeStyling\")
        bundledModule(\"intellij.libraries.compose.foundation.desktop\")
        bundledModule(\"intellij.libraries.skiko\")
    }
    testImplementation(\"junit:junit:4.13.2\")
    testRuntimeOnly(\"org.junit.platform:junit-platform-launcher\")

}
```

## plugin.xml
```xml
<dependencies>
        <plugin id=\"com.intellij.modules.platform\"/>
        <plugin id=\"org.jetbrains.plugins.yaml\"/>
        <plugin id=\"Dart\"/>
        <plugin id=\"org.intellij.plugins.markdown\"/>
        <plugin id=\"org.jetbrains.plugins.terminal\"/>
        <plugin id=\"com.intellij.modules.json\"/>
        <plugin id=\"com.intellij.platform.images\"/>
        <plugin id=\"org.intellij.groovy\"/>
        <module name=\"intellij.libraries.ktor.client\"/>
        <module name=\"intellij.libraries.ktor.client.cio\"/>
        <module name=\"intellij.platform.jewel.foundation\"/>
        <module name=\"intellij.platform.jewel.ui\"/>
        <module name=\"intellij.platform.jewel.ideLafBridge\"/>
        <module name=\"intellij.libraries.compose.foundation.desktop\"/>
        <module name=\"intellij.libraries.skiko\"/>
        <module name=\"intellij.platform.jewel.markdown.core\"/>
        <module name=\"intellij.platform.jewel.markdown.ideLafBridgeStyling\"/>
    </dependencies>
```

## 在 toolWindows里面使用
关键函数: `toolWindow.addComposeTab`
```kotlin
class DartVmServiceWindowsFactory : ToolWindowFactory {
    override fun createToolWindowContent(
        project: Project,
        toolWindow: ToolWindow
    ) {
        toolWindow.addComposeTab(\"Vm\") {
            DartVmStatusComponent(project)
        }
        toolWindow.addComposeTab(\"Http Monitor\") {
            DartHttpUI(project)
        }
        toolWindow.addComposeTab(\"Logging\") {
            DartVmLoggingComponent(project)
        }
        toolWindow.addComposeTab(\"Provider\") {
            ProviderComposeComponent(project)
        }

        if (System.getenv(\"DEV\") == \"true\") {
            toolWindow.addComposeTab(\"Demo\") {
                JsonViewerDemo()
            }

            toolWindow.addComposeTab(\"常见依赖\") {
                AddPackageDialog(project) {}
            }
        }

    }

    override fun shouldBeAvailable(project: Project): Boolean {
        return PluginConfig.getInstance(project).state.enableVmServiceToolWindow
    }


}
```
## 使用jewel panel
```kotlin
@Composable
fun Panel(){
    JewelComposePanel { 
        // todo 
    }
}
```', '', NULL, 3, 0, true, '2025-09-17 10:16:15.781000');
INSERT INTO blogs (id, title, slug, author, content, html, thumbnail, category_id, view_count, is_published, created_at) VALUES (1553, '解决系统升级 Macos26打开虚幻项目报错的问题', 'blog-1553', '梁典典', '打开或者创建项目后提示

Platform Mac is not a valid platform to build. Check that the SDK is installed properly and that you have the necessary platorm support files

需要修改一个配置
一般在这个路径下
```
/Users/Shared/Epic Games/UE_5.6/Engine/Config/Apple
```

里面有个 Apple_SDK.json

需要修改 xcode的支持版本,MaxVersion改成 26.0.0 (xcode的最新版本),`AppleVersionToLLVMVersions`也要修改对应的版本号

示例
```json
{
  \"//1\": \"Xcode versions:\",
  \"MainVersion\": \"15.2\",
  \"MinVersion\": \"15.2.0\",
  \"MaxVersion\": \"26.0.0\",
  \"//2\": \"!!!\",
  \"//3\": \"NOTE: If you update the MaxVersion, double check the AppleVersionToLLVMVersion array below!!!\",
  \"//4\": \"!!!\",

  \"//5\": \"The versions on Windows are iTunes versions:\",
  \"MinVersion_Win64\": \"1100.0.0.0\",
  \"MaxVersion_Win64\": \"8999.0\",

  \"//6\": \"This is not a version range, but a mapping of Xcode clang versions to LLVM versions, for shared version checks with other clangs\",
  \"//7\": \"Version mapping can be found at https://en.wikipedia.org/wiki/Xcode#Toolchain_versions\",
  \"//8\": \"The first half of the pair is the first version that is using the second version source LLVM\",
  \"//9\": \"For instance, Xcode 16 uses LLVM 17.0.6\",
  \"AppleVersionToLLVMVersions\": [
    \"14.0.0-14.0.0\",
    \"14.0.3-15.0.0\",
    \"15.0.0-16.0.0\",
    \"16.0.0-17.0.6\",
    \"16.3.0-19.1.4\",
    \"26.0.0-19.1.5\"
  ]
}

```

修改完成后就可以打开项目了', '', NULL, 202, 0, true, '2025-09-18 11:13:51.176000');
INSERT INTO blogs (id, title, slug, author, content, html, thumbnail, category_id, view_count, is_published, created_at) VALUES (1602, '使用rust编写一个脚本爬取 flutter cupertino icons列表', 'blog-1602', '梁典典', '## 编写脚本爬取网页
```toml
[package]
name = \"get_flutter_cupertino_icons\"
version = \"0.1.0\"
edition = \"2024\"

[dependencies]
reqwest = { version = \"0.11\", features = [\"blocking\", \"json\"] }
select = \"0.6\"
serde = { version = \"1.0\", features = [\"derive\"] }
serde_json = \"1.0\"
tokio = { version = \"1\", features = [\"full\"] }
futures = \"0.3\"
regex = \"1\"
once_cell = \"1\"
```
```rust
use futures::future::{self};
use once_cell::sync::Lazy;
use regex::Regex;
use reqwest::Client;
use select::document::Document;
use select::predicate::{Attr, Class, Name, Predicate};
use serde::{Deserialize, Serialize};
use std::error::Error;

#[derive(Serialize, Deserialize, Debug, Clone)]
struct Icon {
    icon_name: String,
    icon_code: String,
}

async fn fetch_page(client: &Client, url: &str) -> Result<String, Box<dyn Error + Send + Sync>> {
    let res = client.get(url).send().await?;
    if !res.status().is_success() {
        return Err(format!(\"Failed to fetch URL: {} with status {}\", url, res.status()).into());
    }
    let body = res.text().await?;
    Ok(body)
}

async fn fetch_icons() -> Result<Vec<Icon>, Box<dyn Error + Send + Sync>> {
    let base_url = \"https://api.flutter.dev/flutter/cupertino/CupertinoIcons-class.html\";

    let client = Client::new();

    let body = fetch_page(&client, base_url).await?;
    let document = Document::from(body.as_str());

    let tasks: Vec<_> = document
        .find(Attr(\"id\", \"constants\").descendant(Attr(\"class\", \"constant\")))
        .filter(|node| {
            let icon_name = node.find(Name(\"a\")).next().unwrap().text();
            icon_name != \"iconFont\" && icon_name != \"iconFontPackage\"
        })
        .map(|node| {
            let client = client.clone();

            let icon_name = node.find(Name(\"a\")).next().unwrap().text();
            let detail_href = node
                .find(Name(\"a\"))
                .next()
                .unwrap()
                .attr(\"href\")
                .unwrap()
                .to_string();

            tokio::spawn(async move {
                let detail_url = format!(\"https://api.flutter.dev/flutter/{}\", detail_href);

                match fetch_icon_code(&client, &detail_url).await {
                    Ok(icon_code) => Ok(Icon {
                        icon_name,
                        icon_code,
                    }),
                    Err(e) => Err(format!(\"Failed to load icon ''{}'': {}\", icon_name, e)),
                }
            })
        })
        .collect();

    let results = future::join_all(tasks).await;

    let mut icons = Vec::new();
    for result in results {
        match result {
            Ok(Ok(icon)) => icons.push(icon),
            Ok(Err(e)) => eprintln!(\"{}\", e),
            Err(e) => eprintln!(\"Task failed to execute: {}\", e),
        }
    }

    if icons.is_empty() {
        return Err(\"No icons were found. The website structure may have changed again.\".into());
    }

    Ok(icons)
}

async fn fetch_icon_code(
    client: &Client,
    url: &str,
) -> Result<String, Box<dyn Error + Send + Sync>> {
    let body = fetch_page(client, url).await?; // 使用 .await
    let html = body.as_str();
    let document = Document::from(html);

    let number = document
        .find(Name(\"code\").and(Class(\"language-dart\")))
        .next();
    match number {
        Some(item) => {
            let text = item.text();
            let code = extract_hex_code(&text);
            match code {
                Some(code) => Ok(code),
                None => Err(format!(\"没有解析到 icon图标, {}\", url).into()),
            }
        }
        None => Err(format!(\"在页面上找不到图标代码点: {}\", url).into()),
    }
}
fn extract_hex_code(text: &str) -> Option<String> {
    static HEX_REGEX: Lazy<Regex> =
        Lazy::new(|| Regex::new(r\"0x[[:xdigit:]]+\").expect(\"无效的正则表达式\"));
    HEX_REGEX.find(text).map(|mat| mat.as_str().to_string())
}
#[tokio::main]
async fn main() {
    match fetch_icons().await {
        Ok(icons) => match serde_json::to_string_pretty(&icons) {
            Ok(json_str) => match std::fs::write(\"icons.json\", &json_str) {
                Ok(_) => println!(
                    \"Successfully wrote icons to icons.json, size: {}\",
                    icons.len()
                ),
                Err(e) => eprintln!(\"Error writing to file: {}\", e),
            },
            Err(e) => eprintln!(\"Error serializing to JSON: {}\", e),
        },
        Err(e) => {
            eprintln!(\"Error fetching icons: {}\", e);
        }
    }
}

```
输出
```bash
   Compiling get_flutter_cupertino_icons v0.1.0 (/Users/ldd/RustroverProjects/get_flutter_cupertino_icons)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.81s
     Running `target/debug/get_flutter_cupertino_icons`
Successfully wrote icons to icons.json, size: 1322
```

## 附件

cupertino icons json文件

[icons.json](https://minio.itbug.shop/blog/simple-file/icons___1761191797418___.json)

源码: [get_flutter_cupertino_icons](https://github.com/mdddj/get_flutter_cupertino_icons), [parse_material_icons](https://github.com/mdddj/parse_material_icons)', '', NULL, 1, 0, true, '2025-10-23 11:57:56.714000');
INSERT INTO blogs (id, title, slug, author, content, html, thumbnail, category_id, view_count, is_published, created_at) VALUES (1603, 'Blender常用快捷键记录', 'blog-1603', '梁典典', '## 基本操作

::: info
随机记录,可能会有重复,是正常现象
:::

| 名称 | 快捷键 | 截图示例 | 备注 |
| :--- | :--- | :--- | :--- |
| 切换编辑模式 | <kbd>tab</kbd> | | |
| 切换正视图 | <kbd>1</kbd>  | | 小数字键盘 |
| 透视模式 | <kbd>alt</kbd>+<kbd>z</kbd> | | 再按一次取消透视模式 |
| 拉伸  | <kbd>s</kbd>  | ~~[查看图片]https://minio.itbug.shop/blog/simple-file/image___1761720176387___.png~~ | |
|  环切并滑移  | <kbd>ctrl</kbd> + <kbd>r</kbd> |  ~~[查看图片]https://minio.itbug.shop/blog/simple-file/%25E7%258E%25AF%25E5%2588%2587%25E5%25B9%25B6%25E6%25BB%2591%25E7%25A7%25BB___1761722364033___.gif~~  | |
| 面模式 |  <kbd>3</kbd>   | | 编辑模式下|
| 内擦面|  <kbd>I</kbd>  |  |  向内挤出 |
| 移动  | <kbd>G</kbd> | |  比如像上拉一点|
| 快速添加物体 | <kbd>shift</kbd> + <kbd>a</kbd> | |  比如添加一个柱体 |
|向内挤出| <kbd>e</kbd> |||
| 快速添加表面细分修改器| <kbd>ctrl</kbd> + <kbd>3</kbd> || 3支持自定义,标识级别|
| 应用缩放| <kbd>ctrl</kbd> + <kbd>a</kbd> |||
|设置父子级关系| 子+<kbd>shift</kbd> +父,<kbd>ctrl</kbd>+<kbd>p</kbd> ||菜单选\"物体\"|
|添加倒角| <kbd>ctrl</kbd>+<kbd>b</kbd>|||
|复制| <kbd>shift</kbd>+<kbd>d</kbd>|||
|游标到原点|<kbd>shift</kbd>+<kbd>s</kbd>||选游标->世界原点|
|交接循环变|<kbd>ctrl</kbd>+<kbd>e</kbd>|||
|连续选择边|<kbd>shift</kbd>+<kbd>alt</kbd>||可能要双击?|
|复制并 移动| <kbd>shift</kbd> + <kbd>d</kbd>|||
|移动浮标| <kbd>shift</kbd> + <kbd>鼠标右键</kbd> |||
|拉扁,拉窄| <kbd>s</kbd> + <kbd>y</kbd> ||记得选中目标,y是轴向|
|x轴移动| <kbd>g</kbd>+<kbd>x</kbd> |||

## 修改器
| 名称 | 快捷键 | 截图示例 | 备注 |
| :--- | :--- | :--- | :--- |
|快速添加表面细分修改器| <kbd>ctrl</kbd>+<kbd>2</kbd>|||


## 移动
| 名称 | 快捷键 | 截图示例 | 备注 |
| :--- | :--- | :--- | :--- |
|基础移动| <kbd>G</kbd>|||
|移动到世界圆点| <kbd>Alt</kbd> + <kbd>G</kbd> |||


## 旋转
| 名称 | 快捷键 | 截图示例 | 备注 |
| :--- | :--- | :--- | :--- |
|基础旋转| <kbd>R</kbd>|||
|向 x轴旋转 90 度| <kbd>R</kbd> + <kbd>X</kbd> + <kbd>90</kbd> |||


## 晶格
| 名称 | 快捷键 | 截图示例 | 备注 |
| :--- | :--- | :--- | :--- |
|晶格形变| <kbd>Ctrl</kbd> + <kbd>p</kbd> ||先物体,再最后选晶格,需要在物体模式下|
|应用晶格形变| 选中物品+右键+转换到-网格|~~[应用晶格形变.gif]https://minio.itbug.shop/blog/simple-file/%25E5%25BA%2594%25E7%2594%25A8%25E6%2599%25B6%25E6%25A0%25BC%25E5%25BD%25A2%25E5%258F%2598___1764486174731___.gif~~||

## 注意事项

* 尽量不要在物体模式下缩放,尽量在编辑模式下缩放
* 假如你在物体模式下做过缩放,记得应用下这个缩放 (<kbd>ctrl</kbd>+<kbd>a</kbd>)
## 面吸附
![image.png](https://minio.itbug.shop/blog/simple-file/image___1761815211661___.png)
![面吸附.gif](https://minio.itbug.shop/blog/simple-file/%25E9%259D%25A2%25E5%2590%25B8%25E9%2599%2584___1761815251328___.gif)

## 拉平底面

<kbd>s</kbd> + <kbd>z</kbd> + <kbd>0</kbd>

![底面拉平.gif](https://minio.itbug.shop/blog/simple-file/%25E5%25BA%2595%25E9%259D%25A2%25E6%258B%2589%25E5%25B9%25B3___1761817163546___.gif)

## 分离选中项

<kbd>p</kbd>
![分离选中项.gif](https://minio.itbug.shop/blog/simple-file/%25E5%2588%2586%25E7%25A6%25BB%25E9%2580%2589%25E4%25B8%25AD%25E9%25A1%25B9___1761818402725___.gif)

## 切线+向边拉
<kbd>ctrl</kbd>+<kbd>r</kbd> 切 2 到
<kbd>s</kbd>+<kbd>y</kbd> 向 Y 分别往 2 边拉
![横切和向2边拉.gif](https://minio.itbug.shop/blog/simple-file/%25E6%25A8%25AA%25E5%2588%2587%25E5%2592%258C%25E5%2590%25912%25E8%25BE%25B9%25E6%258B%2589___1761898884059___.gif)

## 快捷键一览表
![AC9DD290C04DD1499DBACE7F248F0B1C.jpg](https://minio.itbug.shop/blog/simple-file/AC9DD290C04DD1499DBACE7F248F0B1C___1763799721737___.jpg)
', '', NULL, 152, 0, true, '2025-10-29 14:41:59.869000');
INSERT INTO blogs (id, title, slug, author, content, html, thumbnail, category_id, view_count, is_published, created_at) VALUES (1604, 'Github Action CI 推送标签自动发布 Release 版本', 'blog-1604', '梁典典', '## 创建 yaml任务文件
![image.png](https://minio.itbug.shop/blog/simple-file/image___1762487673931___.png)

## 添加代码

主要步骤

* 拉取代码
* 下载 jdk
* 获取版本号
* 设置 gradle权限
* 打包插件
* 读取打包的 zip文件
* 获取版本更新日志
* 创建发布版本
* 上传资产文件
* 完成



```yaml
name: 构建发布创建

on:
  push:
    tags:
      - ''v*''  # 当推送以 v 开头的 tag 时触发，如 v1.0.0

jobs:
  build-and-release:
    runs-on: ubuntu-latest
    steps:
      # ------------------- 新增步骤 -------------------
      - name: 从 Tag 中提取分支名
        id: get_branch_from_tag
        run: |
          # GITHUB_REF 的值是 ''refs/tags/v6.7.0''
          # 使用 shell 参数扩展移除前缀 ''refs/tags/v''
          BRANCH_NAME=${GITHUB_REF#refs/tags/v}
          echo \"branch_name=$BRANCH_NAME\" >> $GITHUB_OUTPUT
          echo \"提取到的分支名是: $BRANCH_NAME\"

      - name: Checkout code
        uses: actions/checkout@v5
        with:
          ref: ${{ steps.get_branch_from_tag.outputs.branch_name }}
          fetch-depth: 0  # 获取完整历史记录用于生成变更日志

      - name: 准备JBR21
        uses: actions/setup-java@v4
        with:
          java-version: ''21''
          distribution: ''jetbrains''

      - name: 获取标签版本号
        id: get_version
        run: |
          VERSION=${GITHUB_REF#refs/tags/v}
          echo \"version=$VERSION\" >> $GITHUB_OUTPUT
          echo \"tag_name=${GITHUB_REF#refs/tags/}\" >> $GITHUB_OUTPUT 

      # 这一步是导致错误的元凶之一，已移除 working-directory
      - name: 授予gradlew执行权限
        run: chmod +x gradlew

      # 这一步是导致错误的元凶之二，已移除 working-directory
      - name: 打包插件
        run: |
          ./gradlew buildPlugin --no-daemon --stacktrace
        env:
          GRADLE_OPTS: -Dorg.gradle.jvmargs=\"-Xmx1548m -XX:MaxMetaspaceSize=512m\"

      # 这一步是导致错误的元凶之三，已移除 working-directory
      - name: 获取构建的插件包(文件名和路径)
        id: find_plugin
        run: |
          PLUGIN_FILE=$(find build/distributions -name \"*.zip\" | head -1)
          if [ -z \"$PLUGIN_FILE\" ]; then
            echo \"No plugin file found!\"
            exit 1
          fi
          echo \"plugin_file=$PLUGIN_FILE\" >> $GITHUB_OUTPUT
          echo \"plugin_name=$(basename $PLUGIN_FILE)\" >> $GITHUB_OUTPUT
          echo \"Found plugin: $PLUGIN_FILE\"

      # 这一步是导致错误的元凶之四，已移除 working-directory
      - name: 获取版本更新说明
        id: release_notes
        run: |
          CHANGELOG_CONTENT=$(./gradlew getChangelog --quiet)
          echo -n \"$CHANGELOG_CONTENT\" > release-notes.md
          echo ''changelog<<EOF'' >> $GITHUB_OUTPUT
          echo \"$CHANGELOG_CONTENT\" >> $GITHUB_OUTPUT
          echo ''EOF'' >> $GITHUB_OUTPUT

      - name: 创建发布版本
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ steps.get_version.outputs.tag_name }}
          name: FlutterX  ${{ steps.get_version.outputs.tag_name }}
          # body_path 需要指向正确的位置，现在是项目根目录
          body_path: release-notes.md
          # files 也需要指向正确的位置
          files: |
            ${{ steps.find_plugin.outputs.plugin_file }}
          draft: false
          prerelease: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: 上传资产文件
        uses: actions/upload-artifact@v4
        with:
          name: FlutterX-${{ steps.get_version.outputs.version }}
          # path 也需要指向正确的位置
          path: ${{ steps.find_plugin.outputs.plugin_file }}
          retention-days: 30

      # 这一步的 working-directory 也应该移除
      - name: 插件验证
        run: |
          echo \"✅ Plugin built successfully!\"
          echo \"📁 Plugin file: ${{ steps.find_plugin.outputs.plugin_name }}\"
          echo \"🏷️ Version: ${{ steps.get_version.outputs.version }}\"
          echo \"📦 Release created: https://github.com/${{ github.repository }}/releases/tag/${{ steps.get_version.outputs.tag_name }}\"
```

## 源码
[https://github.com/mdddj/dd_flutter_idea_plugin](https://github.com/mdddj/dd_flutter_idea_plugin)', '', NULL, 152, 0, true, '2025-11-07 11:56:59.148000');
INSERT INTO blogs (id, title, slug, author, content, html, thumbnail, category_id, view_count, is_published, created_at) VALUES (1605, '使用 BNF 范式编写语言格式规范', 'blog-1605', '梁典典', '## 一个表示 url的 bnf范式规范
```bnf
<url> ::= <scheme> \":\" <hier_part> | <scheme> \":\" <hier_part> \"?\" <query> | <scheme> \":\" <hier_part> \"#\" <fragment> | <scheme> \":\" <hier_part> \"?\" <query> \"#\" <fragment>

<scheme> ::= <ALPHA> <scheme_tail> | <ALPHA>

<scheme_tail> ::= <scheme_char> <scheme_tail> | <scheme_char>

<scheme_char> ::= <ALPHA> | <DIGIT> | \"+\" | \"-\" | \".\"

<hier_part> ::= \"//\" <authority> <path_abempty> | <path_absolute> | <path_rootless> | <path_empty>

<authority> ::= <userinfo> \"@\" <host> \":\" <port> | <userinfo> \"@\" <host> | <host> \":\" <port> | <host>

<userinfo> ::= <userinfo_char> <userinfo> | <userinfo_char>

<userinfo_char> ::= <unreserved> | <pct_encoded> | <sub_delims> | \":\"

<host> ::= <IP_literal> | <IPv4address> | <reg_name>

<IP_literal> ::= \"[\" <IPv6address> \"]\"

<IPv6address> ::= <h16> \":\" <h16> \":\" <h16> \":\" <h16> \":\" <h16> \":\" <h16> \":\" <h16> \":\" <h16>

<h16> ::= <HEXDIG> | <HEXDIG> <HEXDIG> | <HEXDIG> <HEXDIG> <HEXDIG> | <HEXDIG> <HEXDIG> <HEXDIG> <HEXDIG>

<IPv4address> ::= <dec_octet> \".\" <dec_octet> \".\" <dec_octet> \".\" <dec_octet>

<dec_octet> ::= <DIGIT> | <DIGIT> <DIGIT> | \"1\" <DIGIT> <DIGIT> | \"2\" <DIGIT> <DIGIT>

<reg_name> ::= <reg_name_char> <reg_name> | <reg_name_char>

<reg_name_char> ::= <unreserved> | <pct_encoded> | <sub_delims>

<port> ::= <DIGIT> <port> | <DIGIT>

<path_abempty> ::= \"/\" <segment> <path_abempty> | \"/\" <segment> | <path_empty>

<path_absolute> ::= \"/\" <segment_nz> <path_abempty> | \"/\"

<path_rootless> ::= <segment_nz> <path_abempty> | <segment_nz>

<path_empty> ::= <ALPHA>

<segment> ::= <pchar> <segment> | <pchar>

<segment_nz> ::= <pchar> <segment> | <pchar>

<pchar> ::= <unreserved> | <pct_encoded> | <sub_delims> | \":\" | \"@\"

<query> ::= <query_char> <query> | <query_char>

<query_char> ::= <pchar> | \"/\" | \"?\"

<fragment> ::= <fragment_char> <fragment> | <fragment_char>

<fragment_char> ::= <pchar> | \"/\" | \"?\"

<pct_encoded> ::= \"%\" <HEXDIG> <HEXDIG>

<unreserved> ::= <ALPHA> | <DIGIT> | \"-\" | \".\" | \"_\" | \"~\"

<sub_delims> ::= \"!\" | \"$\" | \"&\" | \"''\" | \"(\" | \")\" | \"*\" | \"+\" | \",\" | \";\" | \"=\"

<ALPHA> ::= \"a\" | \"b\" | \"c\" | \"d\" | \"e\" | \"f\" | \"g\" | \"h\" | \"i\" | \"j\" | \"k\" | \"l\" | \"m\" | \"n\" | \"o\" | \"p\" | \"q\" | \"r\" | \"s\" | \"t\" | \"u\" | \"v\" | \"w\" | \"x\" | \"y\" | \"z\" | \"A\" | \"B\" | \"C\" | \"D\" | \"E\" | \"F\" | \"G\" | \"H\" | \"I\" | \"J\" | \"K\" | \"L\" | \"M\" | \"N\" | \"O\" | \"P\" | \"Q\" | \"R\" | \"S\" | \"T\" | \"U\" | \"V\" | \"W\" | \"X\" | \"Y\" | \"Z\"

<DIGIT> ::= \"0\" | \"1\" | \"2\" | \"3\" | \"4\" | \"5\" | \"6\" | \"7\" | \"8\" | \"9\"

<HEXDIG> ::= <DIGIT> | \"a\" | \"b\" | \"c\" | \"d\" | \"e\" | \"f\" | \"A\" | \"B\" | \"C\" | \"D\" | \"E\" | \"F\"
```

## 变量{{var}}

```bnf
<variable> ::= \"{{\" <variable_name> \"}}\"

<variable_name> ::= <letter> <variable_name_tail> | <letter>

<variable_name_tail> ::= <variable_name_char> <variable_name_tail> | <variable_name_char>

<variable_name_char> ::= <letter> | <digit> | \"_\"

<letter> ::= \"a\" | \"b\" | \"c\" | \"d\" | \"e\" | \"f\" | \"g\" | \"h\" | \"i\" | \"j\" | \"k\" | \"l\" | \"m\" | \"n\" | \"o\" | \"p\" | \"q\" | \"r\" | \"s\" | \"t\" | \"u\" | \"v\" | \"w\" | \"x\" | \"y\" | \"z\" | \"A\" | \"B\" | \"C\" | \"D\" | \"E\" | \"F\" | \"G\" | \"H\" | \"I\" | \"J\" | \"K\" | \"L\" | \"M\" | \"N\" | \"O\" | \"P\" | \"Q\" | \"R\" | \"S\" | \"T\" | \"U\" | \"V\" | \"W\" | \"X\" | \"Y\" | \"Z\"

<digit> ::= \"0\" | \"1\" | \"2\" | \"3\" | \"4\" | \"5\" | \"6\" | \"7\" | \"8\" | \"9\"
```

## bnf编译和测试网站

[https://bnfplayground.pauliankline.com/](https://bnfplayground.pauliankline.com/)', '', NULL, 152, 0, true, '2025-11-17 10:40:07.163000');
INSERT INTO blogs (id, title, slug, author, content, html, thumbnail, category_id, view_count, is_published, created_at) VALUES (1606, '使用ImageMagick来操作图像', 'blog-1606', '梁典典', '# ImageMagick 命令行工具中文说明

## 基本信息
- **版本**: ImageMagick 7.1.1-47 Q16-HDRI x86_64
- **官网**: https://imagemagick.org
- **版权**: (C) 1999 ImageMagick Studio LLC

## 它能干什么?

**ImageMagick 是一个强大的图像处理工具**,可以通过命令行执行各种图像操作,主要功能包括:

### 核心功能
1. **图像格式转换** - 支持200+种图像格式互转(JPEG, PNG, GIF, TIFF, WebP等)
2. **图像编辑** - 调整大小、裁剪、旋转、翻转、变形
3. **图像增强** - 调整亮度/对比度/色彩、锐化、模糊、降噪
4. **特效处理** - 添加边框、阴影、油画效果、素描效果、老照片效果
5. **图像合成** - 多图拼接、添加水印、图层混合
6. **批量处理** - 一次处理多个图像文件
7. **动画制作** - 创建和编辑GIF动画
8. **文字标注** - 在图像上添加文字、标签、注释

---

## 命令用法

```bash
magick [选项 | 图像...] 输出图像
magick tool [选项 | 图像...] 输出图像
magick [选项 | 图像...] -script 脚本文件 [脚本参数...]
```

---

## 主要参数分类

### 📐 图像设置参数

| 参数 | 说明 |
|------|------|
| `-quality 值` | JPEG/PNG压缩质量(0-100) |
| `-resize 尺寸` | 调整图像大小 |
| `-density 几何` | 设置图像分辨率(DPI) |
| `-depth 值` | 图像色深 |
| `-format \"字符串\"` | 输出格式化的图像特征 |
| `-colorspace 类型` | 更改颜色空间 |
| `-background 颜色` | 背景颜色 |
| `-fill 颜色` | 填充颜色 |
| `-font 名称` | 使用指定字体渲染文字 |
| `-pointsize 值` | 字体大小 |

### 🎨 图像操作符

#### 基础操作
- `-resize 尺寸` - 调整大小
- `-crop 几何` - 裁剪矩形区域
- `-rotate 角度` - 旋转图像
- `-flip` - 垂直翻转
- `-flop` - 水平翻转
- `-trim` - 自动裁剪边缘

#### 色彩调整
- `-brightness-contrast 几何` - 调整亮度/对比度
- `-level 值` - 调整对比度级别
- `-normalize` - 归一化颜色范围
- `-auto-level` - 自动调整色阶
- `-colorize 值` - 着色
- `-grayscale 方法` - 转换为灰度

#### 模糊与锐化
- `-blur 几何` - 模糊
- `-gaussian-blur 几何` - 高斯模糊
- `-sharpen 几何` - 锐化
- `-unsharp 几何` - 反锐化蒙版

#### 特效滤镜
- `-charcoal 半径` - 炭笔画效果
- `-sketch 几何` - 素描效果
- `-paint 半径` - 油画效果
- `-sepia-tone 阈值` - 老照片效果
- `-polaroid 角度` - 宝丽来照片效果
- `-vignette 几何` - 暗角效果
- `-emboss 半径` - 浮雕效果
- `-edge 半径` - 边缘检测

#### 变形效果
- `-swirl 角度` - 漩涡效果
- `-wave 几何` - 波浪效果
- `-implode 数量` - 内爆效果
- `-distort 方法 参数` - 各种变形

#### 降噪与增强
- `-despeckle` - 去斑点
- `-enhance` - 增强
- `-median 几何` - 中值滤波
- `-noise 几何` - 添加/减少噪点

### 🖼️ 图像序列操作

- `-append` - 垂直拼接图像
- `+append` - 水平拼接图像
- `-composite` - 图像合成
- `-mosaic` - 创建马赛克
- `-layers 方法` - 图层操作
- `-coalesce` - 合并图像序列
- `-flatten` - 展平图像层

### 📝 文字与标注

- `-annotate 几何 文字` - 添加文字标注
- `-draw 字符串` - 绘制图形元素
- `-caption 字符串` - 添加标题
- `-label 字符串` - 添加标签

---

## 实用示例

### 1. 格式转换
```bash
# PNG转JPEG
magick input.png output.jpg

# 批量转换
magick *.png -set filename:name ''%t'' ''%[filename:name].jpg''
```

### 2. 调整大小
```bash
# 按像素调整
magick input.jpg -resize 800x600 output.jpg

# 按百分比调整
magick input.jpg -resize 50% output.jpg

# 保持宽高比,最大宽度800
magick input.jpg -resize 800x output.jpg
```

### 3. 压缩图像
```bash
# 设置JPEG质量为80
magick input.jpg -quality 80 output.jpg
```

### 4. 裁剪与旋转
```bash
# 裁剪400x300区域,从(100,100)开始
magick input.jpg -crop 400x300+100+100 output.jpg

# 旋转90度
magick input.jpg -rotate 90 output.jpg
```

### 5. 添加水印
```bash
magick input.jpg -gravity southeast -pointsize 30 \\
  -fill white -annotate +10+10 ''©2025'' output.jpg
```

### 6. 批量处理
```bash
# 批量调整大小并添加边框
magick *.jpg -resize 800x600 -border 5x5 -bordercolor black \\
  -set filename:name ''%t'' ''processed/%[filename:name].jpg''
```

### 7. 创建缩略图
```bash
magick input.jpg -thumbnail 200x200 thumbnail.jpg
```

### 8. 图像拼接
```bash
# 水平拼接
magick image1.jpg image2.jpg +append output.jpg

# 垂直拼接
magick image1.jpg image2.jpg -append output.jpg
```

### 9. 添加特效
```bash
# 老照片效果
magick input.jpg -sepia-tone 80% output.jpg

# 油画效果
magick input.jpg -paint 5 output.jpg

# 素描效果
magick input.jpg -sketch 0x20+120 output.jpg
```

### 10. 自动优化
```bash
# 自动调整方向和色阶
magick input.jpg -auto-orient -auto-level output.jpg
```

---

## 适用场景

✅ **自动化图像处理** - 批量处理大量图片  
✅ **网站图片优化** - 压缩、调整尺寸、生成缩略图  
✅ **图像格式转换** - 在各种格式间转换  
✅ **添加水印或标注** - 批量添加版权信息  
✅ **创建GIF动画** - 从多张图片生成动画  
✅ **图像特效处理** - 应用各种艺术效果  
✅ **脚本和自动化工作流** - 集成到自动化脚本中  

---

## 支持的格式

支持200+种图像格式,包括:
- 常见格式: JPEG, PNG, GIF, TIFF, BMP, WebP
- RAW格式: CR2, NEF, ARW等相机RAW格式
- 矢量格式: SVG, PDF, EPS, PS
- 专业格式: PSD, HEIC, JXL, OpenEXR

---

ImageMagick 是图像处理领域的\"瑞士军刀\",特别适合需要批量处理、自动化或命令行操作的场景!', '', NULL, 152, 0, true, '2025-11-18 13:54:55.166000');

-- Blog Tags
INSERT INTO blog_tags (blog_id, tag_id) VALUES (1, 1);
INSERT INTO blog_tags (blog_id, tag_id) VALUES (2, 1);
INSERT INTO blog_tags (blog_id, tag_id) VALUES (1, 2);
INSERT INTO blog_tags (blog_id, tag_id) VALUES (2, 2);
INSERT INTO blog_tags (blog_id, tag_id) VALUES (252, 2);
INSERT INTO blog_tags (blog_id, tag_id) VALUES (752, 2);
INSERT INTO blog_tags (blog_id, tag_id) VALUES (1002, 2);
INSERT INTO blog_tags (blog_id, tag_id) VALUES (1452, 2);
INSERT INTO blog_tags (blog_id, tag_id) VALUES (3, 3);
INSERT INTO blog_tags (blog_id, tag_id) VALUES (3, 4);
INSERT INTO blog_tags (blog_id, tag_id) VALUES (252, 4);
INSERT INTO blog_tags (blog_id, tag_id) VALUES (302, 4);
INSERT INTO blog_tags (blog_id, tag_id) VALUES (752, 4);
INSERT INTO blog_tags (blog_id, tag_id) VALUES (802, 4);
INSERT INTO blog_tags (blog_id, tag_id) VALUES (904, 4);
INSERT INTO blog_tags (blog_id, tag_id) VALUES (1002, 4);
INSERT INTO blog_tags (blog_id, tag_id) VALUES (1602, 4);
INSERT INTO blog_tags (blog_id, tag_id) VALUES (4, 5);
INSERT INTO blog_tags (blog_id, tag_id) VALUES (4, 6);
INSERT INTO blog_tags (blog_id, tag_id) VALUES (752, 6);
INSERT INTO blog_tags (blog_id, tag_id) VALUES (852, 6);
INSERT INTO blog_tags (blog_id, tag_id) VALUES (1253, 6);
INSERT INTO blog_tags (blog_id, tag_id) VALUES (1352, 6);
INSERT INTO blog_tags (blog_id, tag_id) VALUES (1604, 6);
INSERT INTO blog_tags (blog_id, tag_id) VALUES (1203, 7);
INSERT INTO blog_tags (blog_id, tag_id) VALUES (905, 52);
INSERT INTO blog_tags (blog_id, tag_id) VALUES (1202, 52);
INSERT INTO blog_tags (blog_id, tag_id) VALUES (152, 102);
INSERT INTO blog_tags (blog_id, tag_id) VALUES (252, 152);
INSERT INTO blog_tags (blog_id, tag_id) VALUES (702, 152);
INSERT INTO blog_tags (blog_id, tag_id) VALUES (1604, 152);
INSERT INTO blog_tags (blog_id, tag_id) VALUES (302, 202);
INSERT INTO blog_tags (blog_id, tag_id) VALUES (502, 202);
INSERT INTO blog_tags (blog_id, tag_id) VALUES (602, 202);
INSERT INTO blog_tags (blog_id, tag_id) VALUES (703, 202);
INSERT INTO blog_tags (blog_id, tag_id) VALUES (903, 202);
INSERT INTO blog_tags (blog_id, tag_id) VALUES (904, 202);
INSERT INTO blog_tags (blog_id, tag_id) VALUES (1153, 202);
INSERT INTO blog_tags (blog_id, tag_id) VALUES (1203, 202);
INSERT INTO blog_tags (blog_id, tag_id) VALUES (1504, 202);
INSERT INTO blog_tags (blog_id, tag_id) VALUES (1602, 202);
INSERT INTO blog_tags (blog_id, tag_id) VALUES (302, 203);
INSERT INTO blog_tags (blog_id, tag_id) VALUES (352, 203);
INSERT INTO blog_tags (blog_id, tag_id) VALUES (903, 203);
INSERT INTO blog_tags (blog_id, tag_id) VALUES (904, 203);
INSERT INTO blog_tags (blog_id, tag_id) VALUES (202, 252);
INSERT INTO blog_tags (blog_id, tag_id) VALUES (402, 252);
INSERT INTO blog_tags (blog_id, tag_id) VALUES (905, 252);
INSERT INTO blog_tags (blog_id, tag_id) VALUES (906, 252);
INSERT INTO blog_tags (blog_id, tag_id) VALUES (907, 252);
INSERT INTO blog_tags (blog_id, tag_id) VALUES (908, 252);
INSERT INTO blog_tags (blog_id, tag_id) VALUES (952, 252);
INSERT INTO blog_tags (blog_id, tag_id) VALUES (1052, 252);
INSERT INTO blog_tags (blog_id, tag_id) VALUES (1202, 252);
INSERT INTO blog_tags (blog_id, tag_id) VALUES (1203, 252);
INSERT INTO blog_tags (blog_id, tag_id) VALUES (1252, 252);
INSERT INTO blog_tags (blog_id, tag_id) VALUES (1502, 252);
INSERT INTO blog_tags (blog_id, tag_id) VALUES (402, 302);
INSERT INTO blog_tags (blog_id, tag_id) VALUES (802, 302);
INSERT INTO blog_tags (blog_id, tag_id) VALUES (902, 302);
INSERT INTO blog_tags (blog_id, tag_id) VALUES (905, 302);
INSERT INTO blog_tags (blog_id, tag_id) VALUES (906, 302);
INSERT INTO blog_tags (blog_id, tag_id) VALUES (907, 302);
INSERT INTO blog_tags (blog_id, tag_id) VALUES (908, 302);
INSERT INTO blog_tags (blog_id, tag_id) VALUES (952, 302);
INSERT INTO blog_tags (blog_id, tag_id) VALUES (1002, 302);
INSERT INTO blog_tags (blog_id, tag_id) VALUES (1052, 302);
INSERT INTO blog_tags (blog_id, tag_id) VALUES (1202, 302);
INSERT INTO blog_tags (blog_id, tag_id) VALUES (1203, 302);
INSERT INTO blog_tags (blog_id, tag_id) VALUES (1252, 302);
INSERT INTO blog_tags (blog_id, tag_id) VALUES (1253, 302);
INSERT INTO blog_tags (blog_id, tag_id) VALUES (1502, 302);
INSERT INTO blog_tags (blog_id, tag_id) VALUES (1504, 302);
INSERT INTO blog_tags (blog_id, tag_id) VALUES (1505, 302);
INSERT INTO blog_tags (blog_id, tag_id) VALUES (1553, 302);
INSERT INTO blog_tags (blog_id, tag_id) VALUES (1602, 302);
INSERT INTO blog_tags (blog_id, tag_id) VALUES (1603, 302);
INSERT INTO blog_tags (blog_id, tag_id) VALUES (1604, 302);
INSERT INTO blog_tags (blog_id, tag_id) VALUES (1605, 302);
INSERT INTO blog_tags (blog_id, tag_id) VALUES (1606, 302);
INSERT INTO blog_tags (blog_id, tag_id) VALUES (452, 352);
INSERT INTO blog_tags (blog_id, tag_id) VALUES (452, 353);
INSERT INTO blog_tags (blog_id, tag_id) VALUES (1152, 353);
INSERT INTO blog_tags (blog_id, tag_id) VALUES (1153, 353);
INSERT INTO blog_tags (blog_id, tag_id) VALUES (402, 354);
INSERT INTO blog_tags (blog_id, tag_id) VALUES (852, 354);
INSERT INTO blog_tags (blog_id, tag_id) VALUES (902, 354);
INSERT INTO blog_tags (blog_id, tag_id) VALUES (903, 354);
INSERT INTO blog_tags (blog_id, tag_id) VALUES (906, 354);
INSERT INTO blog_tags (blog_id, tag_id) VALUES (907, 354);
INSERT INTO blog_tags (blog_id, tag_id) VALUES (908, 354);
INSERT INTO blog_tags (blog_id, tag_id) VALUES (952, 354);
INSERT INTO blog_tags (blog_id, tag_id) VALUES (1002, 354);
INSERT INTO blog_tags (blog_id, tag_id) VALUES (1052, 354);
INSERT INTO blog_tags (blog_id, tag_id) VALUES (1152, 354);
INSERT INTO blog_tags (blog_id, tag_id) VALUES (1202, 354);
INSERT INTO blog_tags (blog_id, tag_id) VALUES (1203, 354);
INSERT INTO blog_tags (blog_id, tag_id) VALUES (1253, 354);
INSERT INTO blog_tags (blog_id, tag_id) VALUES (1302, 354);
INSERT INTO blog_tags (blog_id, tag_id) VALUES (1452, 354);
INSERT INTO blog_tags (blog_id, tag_id) VALUES (1504, 354);
INSERT INTO blog_tags (blog_id, tag_id) VALUES (1505, 354);
INSERT INTO blog_tags (blog_id, tag_id) VALUES (1602, 354);
INSERT INTO blog_tags (blog_id, tag_id) VALUES (1603, 354);
INSERT INTO blog_tags (blog_id, tag_id) VALUES (1604, 354);
INSERT INTO blog_tags (blog_id, tag_id) VALUES (1605, 354);
INSERT INTO blog_tags (blog_id, tag_id) VALUES (1606, 354);
INSERT INTO blog_tags (blog_id, tag_id) VALUES (453, 355);
INSERT INTO blog_tags (blog_id, tag_id) VALUES (502, 355);
INSERT INTO blog_tags (blog_id, tag_id) VALUES (552, 402);
INSERT INTO blog_tags (blog_id, tag_id) VALUES (702, 402);
INSERT INTO blog_tags (blog_id, tag_id) VALUES (703, 402);
INSERT INTO blog_tags (blog_id, tag_id) VALUES (1402, 402);
INSERT INTO blog_tags (blog_id, tag_id) VALUES (1505, 402);
INSERT INTO blog_tags (blog_id, tag_id) VALUES (1552, 402);
INSERT INTO blog_tags (blog_id, tag_id) VALUES (1604, 402);
INSERT INTO blog_tags (blog_id, tag_id) VALUES (602, 452);
INSERT INTO blog_tags (blog_id, tag_id) VALUES (703, 452);
INSERT INTO blog_tags (blog_id, tag_id) VALUES (602, 453);
INSERT INTO blog_tags (blog_id, tag_id) VALUES (902, 453);
INSERT INTO blog_tags (blog_id, tag_id) VALUES (1153, 552);
INSERT INTO blog_tags (blog_id, tag_id) VALUES (1302, 602);
INSERT INTO blog_tags (blog_id, tag_id) VALUES (1302, 603);
INSERT INTO blog_tags (blog_id, tag_id) VALUES (1553, 603);
INSERT INTO blog_tags (blog_id, tag_id) VALUES (1352, 652);
INSERT INTO blog_tags (blog_id, tag_id) VALUES (1603, 702);
INSERT INTO blog_tags (blog_id, tag_id) VALUES (1606, 703);

-- Directories
INSERT INTO directories (id, name, intro, parent_id, created_at) VALUES (412, '虚幻学习笔记', '记录梁典典学习虚幻游戏开发的过程', NULL, '2025-12-06 11:18:18.505000');
INSERT INTO directories (id, name, intro, parent_id, created_at) VALUES (433, 'AI笔记', '学习并记录 ai相关的知识', NULL, '2025-12-13 14:02:01.687000');
INSERT INTO directories (id, name, intro, parent_id, created_at) VALUES (413, '5.函数库', NULL, 412, '2025-12-06 11:18:18.510000');
INSERT INTO directories (id, name, intro, parent_id, created_at) VALUES (414, '备注', NULL, 412, '2025-12-06 11:18:18.516000');
INSERT INTO directories (id, name, intro, parent_id, created_at) VALUES (415, '8.按键', NULL, 412, '2025-12-06 11:18:18.519000');
INSERT INTO directories (id, name, intro, parent_id, created_at) VALUES (416, '13.AI', NULL, 412, '2025-12-06 11:18:18.522000');
INSERT INTO directories (id, name, intro, parent_id, created_at) VALUES (417, '2.实现背包组件', NULL, 412, '2025-12-06 11:18:18.525000');
INSERT INTO directories (id, name, intro, parent_id, created_at) VALUES (418, '9. Widget小部件', NULL, 412, '2025-12-06 11:18:18.529000');
INSERT INTO directories (id, name, intro, parent_id, created_at) VALUES (419, '10. 踩坑', NULL, 412, '2025-12-06 11:18:18.532000');
INSERT INTO directories (id, name, intro, parent_id, created_at) VALUES (420, '3.创建背包UUserWidget', NULL, 412, '2025-12-06 11:18:18.537000');
INSERT INTO directories (id, name, intro, parent_id, created_at) VALUES (421, '11.行为树', NULL, 412, '2025-12-06 11:18:18.541000');
INSERT INTO directories (id, name, intro, parent_id, created_at) VALUES (422, '14.材质', NULL, 412, '2025-12-06 11:18:18.543000');
INSERT INTO directories (id, name, intro, parent_id, created_at) VALUES (423, '12.奶瓜和特效', NULL, 412, '2025-12-06 11:18:18.546000');
INSERT INTO directories (id, name, intro, parent_id, created_at) VALUES (424, '1.基础', NULL, 412, '2025-12-06 11:18:18.558000');

-- Projects
INSERT INTO projects (id, name, description, logo, github_url, preview_url, download_url) VALUES (1, 'FlutterX文档', 'flutter开发插件flutterx的使用文档', 'https://minio.itbug.shop/blog/admin/jb___1712730764536___.png', 'https://github.com/mdddj/flutterx-doc', 'https://flutterx.itbug.shop/starter.html', 'https://github.com/mdddj/flutterx-doc');
INSERT INTO projects (id, name, description, logo, github_url, preview_url, download_url) VALUES (2, 'Rust Idea插件', 'rust react 快速开发插件,适合全栈开发使用', 'https://minio.itbug.shop/blog/admin/jb___1712730764536___.png', 'https://github.com/mdddj/SalvoRsTool', 'https://mdddj.github.io/SalvoRsToolDocument/default-topic.html', 'https://mdddj.github.io/SalvoRsToolDocument/default-topic.html');
INSERT INTO projects (id, name, description, logo, github_url, preview_url, download_url) VALUES (52, '噪点图生成器', '生成各种噪点图,在虚幻引擎中的材质功能经常用到', 'https://minio.itbug.shop/blog/simple-file/fbm_1763601158631___1763601301376___.png', NULL, 'https://noise.itbug.shop/', NULL);

-- Friend Links
INSERT INTO friend_links (id, name, url, logo, intro, email, status, created_at) VALUES (1, '飞鸟', 'https://lzxjack.top', 'https://img.lzxjack.top/202203302154224.webp', '一只平凡的鸟罢了', NULL, 1, '2024-01-11 08:00:00.000000');

-- Texts
INSERT INTO texts (id, name, intro, content, is_encrypted, view_password, created_at, updated_at) VALUES (1, 'about', '关于', 'Hi,这里是梁典典的博客🌹

<img src=''https://minio.itbug.shop/blog/simple-file/avatar___1732525263222___.jpeg'' width=''50'' />
联系方式: 
微信:flutter-null

博客技术栈

* 后端:kotlin+springboot3.2.2+java21
* 前端:react+umi+nextui+tailwindcss
* 数据库:mysql8+redis
* 存储服务:minio
', false, NULL, now(), '2024-11-29 17:37:53.017000');
INSERT INTO texts (id, name, intro, content, is_encrypted, view_password, created_at, updated_at) VALUES (2, 'jianli', '梁典典的简历', '我是简历啊', false, '123789', now(), now());
INSERT INTO texts (id, name, intro, content, is_encrypted, view_password, created_at, updated_at) VALUES (52, 'my-info', '我的信息', '```bash
name: 梁典典的博客
desc: 什么都会一点,什么都不精通
logo: https://minio.itbug.shop/blog/simple-file/b_3e695ada9ced8ab240b5e44061bc558d___1736574411194___.jpg
url: https://itbug.shop
```', false, NULL, now(), '2025-09-20 15:36:32.365000');
INSERT INTO texts (id, name, intro, content, is_encrypted, view_password, created_at, updated_at) VALUES (102, 'mini_get_me', '小程序加我好友', '微信号:flutter-null

扫一扫添加
![IMG_0961.jpeg](https://minio.itbug.shop/blog/simple-file/IMG_0961___1731223880091___.jpeg)', false, NULL, now(), '2024-11-10 15:31:24.514000');
INSERT INTO texts (id, name, intro, content, is_encrypted, view_password, created_at, updated_at) VALUES (104, 'mini_jd', '小程序接单', '## 接单类型
1. flutter app 
2. flutter插件开发
3. java springboot 后端项目
4. react,vue前端项目
5. rust项目,tauri项目,flutter_rust_bridge桥接项目

## 关于定金
评估需求后支付定金50%', false, NULL, now(), now());
INSERT INTO texts (id, name, intro, content, is_encrypted, view_password, created_at, updated_at) VALUES (105, 'mini_source', NULL, '等我整理下...', false, NULL, now(), now());
INSERT INTO texts (id, name, intro, content, is_encrypted, view_password, created_at, updated_at) VALUES (106, 'web-mini-app', 'web博客小程序浏览', '打开微信扫一扫,将打开典典博客小程序
![gh_92e2be6aeddc_258.jpg](https://minio.itbug.shop/blog/simple-file/gh_92e2be6aeddc_258___1718940120176___.jpg)', false, NULL, now(), now());
INSERT INTO texts (id, name, intro, content, is_encrypted, view_password, created_at, updated_at) VALUES (152, 'privacy', '隐私政策', '

# 1.这个APP不会收集用户电脑的任何信息
# 2.它仅在本地获取电脑的IP数据来进行APP调试使用
# 3. 它不需要联网操作,它运行在局域网内
', false, NULL, '2024-07-27 10:53:58.876000', now());

-- Documents
INSERT INTO documents (id, name, filename, content, directory_id, created_at) VALUES (668, '定时器.md', '定时器.md', '


## 创建定时器


定义
```c++
	//定时器,可以用来关闭操作
	FTimerHandle BackpackTimer;
```

```c++
	GetWorld()->GetTimerManager().SetTimer(
		BackpackTimer,
		this, &UMyBackpackComponent::TIimerCall,
		1.0,
		true
	);
```


## 清理定时器

```c++
if(BackpackTimer.IsValid())
	{
		GetWorld()->GetTimerManager().ClearTimer(BackpackTimer);
	}
```

## 相关文档

![img.png](https://minio.itbug.shop/blog/simple-file/img___1730969036434___.png)

![img.png](https://minio.itbug.shop/blog/simple-file/img___1730969078132___.png)

[ue文档](https://dev.epicgames.com/community/search?query=FTimerManager::SetTimer&applications=unreal_engine&sort_by=relevancy&types=document,api_document)', 413, '2025-12-06 11:18:18.512000');
INSERT INTO documents (id, name, filename, content, directory_id, created_at) VALUES (669, 'TArray.md', 'TArray.md', '

## IndexOfByPredicate
获取索引下标index,通过lambda表达式
```c++
void UMyBackpackComponent::RemoveItem(FMyBackpackItem Item)
{
	const auto Find_Index = Backpack.Items.IndexOfByPredicate([Item](const FMyBackpackData& Ele)
	{
		return Ele.ItemData.Id == Item.Id;
	});
	if (Find_Index != INDEX_NONE)
	{
		Backpack.Items.RemoveAt(Find_Index);
	}
	else
	{
		UE_LOG(LogTemp, Error, TEXT(\"背包项目没有找到\"));
	}
}
```
', 413, '2025-12-06 11:18:18.512000');
INSERT INTO documents (id, name, filename, content, directory_id, created_at) VALUES (670, 'float2text.md', 'float2text.md', '

## float 转 Text

```c++
const auto DamageText = UKismetTextLibrary::Conv_DoubleToText(-DamageAmount, HalfToEven, false, true, 1, 324);
```


## 示例

```c++

void UUDamageTextWidget::InitializeDamageText(const float DamageAmount)
{
	if (DamageTextBlock)
	{
		const auto DamageText = UKismetTextLibrary::Conv_DoubleToText(-DamageAmount, HalfToEven, false, true, 1, 324);
		DamageTextBlock->SetText(DamageText);
	}
	if (FadeAndLinearHiding)
	{
		PlayAnimation(FadeAndLinearHiding);
	}
}

```

## 下面来自 AI的解释

这行代码是用在 **Unreal Engine（虚幻引擎）** 中的 C++ 代码，通常出现在游戏逻辑中处理伤害显示的部分。我们来逐部分解析它的含义：

```cpp
const auto DamageText = UKismetTextLibrary::Conv_DoubleToText(-DamageAmount, HalfToEven, false, true, 1, 324);
```

### 各参数解释：

#### 1. `const auto DamageText`
- 声明一个常量变量 `DamageText`，类型由编译器自动推断（通常是 `FText`）。
- `FText` 是 Unreal Engine 中用于本地化文本显示的安全类型。

#### 2. `UKismetTextLibrary::Conv_DoubleToText(...)`
- 这是一个静态函数，属于 `UKismetTextLibrary` 类，用于蓝图和 C++ 中将浮点数（double）转换为可显示的 `FText` 文本。
- 功能：把一个 `double` 类型的数值格式化成人类可读的文本（字符串形式），支持小数位控制、千分位分隔等。

---

### 参数详解：

| 参数 | 值/说明 |
|------|--------|
| **(1) Value** ` -DamageAmount ` | 要转换的数值。这里取的是伤害值的负数（例如：如果伤害是 50，则变成 -50）。可能是为了在 UI 上显示“-50”表示生命值减少。 |
| **(2) RoundingMode** ` HalfToEven ` | 四舍五入模式。`HalfToEven` 是一种银行家舍入法（四舍六入五成双），减少统计偏差。其他选项如 `HalfUp`, `Truncate` 等。 |
| **(3) UseSign** ` false ` | 是否强制显示正负号。`false` 表示：正数不显示 `+`，只有负数显示 `-`。由于前面加了 `-`，所以负数会显示负号。 |
| **(4) UseGrouping** ` true ` | 是否使用千分位分隔符。比如 1000 显示为 \"1,000\"。设为 `true` 就启用逗号分隔。 |
| **(5) MinimumIntegerDigits** ` 1 ` | 整数部分最少显示几位，不足补零。这里是 1，所以不会补前导零（如 5 不会变成 \"05\"）。 |
| **(6) MaximumFractionalDigits** ` 324 ` | 小数部分最多保留多少位。但注意：实际最大有效位数受限于 double 和引擎限制。写 324 可能是为了确保保留足够多的小数位（即不限制），但一般常见的是 1 或 2 位。 |

> ⚠️ 注意：第6个参数 `MaximumFractionalDigits=324` 非常大，不太合理，可能是个错误或调试遗留。正常情况下应为 `1` 或 `2`，比如保留一位小数（如 \"-50.0\"）。

---

### 实际效果举例

假设：
```cpp
double DamageAmount = 50.7;
```

那么：
```cpp
-DamageAmount = -50.7
```

调用后得到的 `DamageText` 可能是：
```
\"-50.7\"
```
或者根据平台设置加上千分位（虽然这里不到千）：
```
\"-50.7\"
```

如果 `DamageAmount = 1234.567`，结果可能是：
```
\"-1,234.567\"   // 因为 UseGrouping=true
```

---

### 典型用途
这段代码常见于：
- 角色受伤时，在屏幕上飘起的伤害数字（如“-50”）。
- 使用 UMG（Unreal Motion Graphics）将这个 `DamageText` 绑定到 Text Block 上显示。

---

### 总结

✅ 这行代码的作用是：

> 将伤害值取负数后，转换为带有千分位、适当小数位的格式化文本，用于 UI 显示（如飘字伤害）。

🔧 示例修正建议（更合理的写法）：

```cpp
const auto DamageText = UKismetTextLibrary::Conv_DoubleToText(
    -DamageAmount,
    ERoundingMode::HalfToEven,
    false,
    true,
    1,
    1  // 保留1位小数就够了，而不是324
);
```

> 💡 提示：`HalfToEven` 是枚举值，完整写法应为 `ERoundingMode::HalfToEven`，但在某些上下文中可以省略命名空间。

如有更多上下文（比如这是在哪个类里？），我可以进一步帮你分析用途。', 413, '2025-12-06 11:18:18.512000');
INSERT INTO documents (id, name, filename, content, directory_id, created_at) VALUES (671, '单词.md', '单词.md', '## material - 材质

> 材质

![img.png](https://minio.itbug.shop/blog/simple-file/img___1727676708057___.png)

## meshes - 网格体

> 网格体

![img_1.png](https://minio.itbug.shop/blog/simple-file/img_1___1727676712956___.png)

## skins - 皮肤

> 皮肤

![img_2.png](https://minio.itbug.shop/blog/simple-file/img_2___1727676718424___.png)

## Textures - 纹理

> 纹理

![img_3.png](https://minio.itbug.shop/blog/simple-file/img_3___1727676659484___.png)', 414, '2025-12-06 11:18:18.517000');
INSERT INTO documents (id, name, filename, content, directory_id, created_at) VALUES (672, '宏.md', '宏.md', '

## ExposeOnSpawn
把属性暴露给蓝图

例子
```c++
	UPROPERTY(BlueprintReadWrite,DisplayName=\"背包数据\",Category=\"背包数据\",meta=(ExposeOnSpawn))
	UMyBackpackComponent* BackpackComponent;
```', 414, '2025-12-06 11:18:18.517000');
INSERT INTO documents (id, name, filename, content, directory_id, created_at) VALUES (673, '1. 输入绑定.md', '1. 输入绑定.md', '

## 按键绑定


在ACharacter中定义`UInputAction`

表示跳的操作,这个要在蓝图中设置才能生效,默认空指针
```c++
	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = Input, meta = (AllowPrivateAccess = \"true\"))
	UInputAction* MyJumpAction;
```


## 实现输入绑定函数SetupPlayerInputComponent

```c++
	// 调用将功能绑定到输入
	virtual void SetupPlayerInputComponent(UInputComponent* PlayerInputComponent) override;
```

实现逻辑,添加输入上下文映射,默认玩家0

```c++
	if (const APlayerController* PlayController = Cast<APlayerController>(GetController()))
	{
		if (const auto SubSystem = ULocalPlayer::GetSubsystem<UEnhancedInputLocalPlayerSubsystem>(
			PlayController->GetLocalPlayer()))
		{
			SubSystem->AddMappingContext(MyDefaultMappingContext, 0);
		}
	}
```

将按键绑定到函数
```c++
    if (UEnhancedInputComponent* InputComponent = CastChecked<UEnhancedInputComponent>(PlayerInputComponent))
	{
	    InputComponent->BindAction(MyJumpAction, ETriggerEvent::Completed, this, &ACharacter::StopJumping);
	}
```


## 触发事件


枚举类型: `ETriggerEvent`

枚举值解释
1.	None (值：0x0)
•	表示没有发生任何重要的触发状态变化，并且当前没有活动的设备输入。
•	使用了 UMETA(Hidden)，在编辑器中不会显示该枚举值。
2.	Triggered (值：1 << 0，即 0x1)
•	表示触发事件在一个或多个帧周期后发生。
•	对应的状态变化：ETriggerState 从 None -> Triggered，或从 Ongoing -> Triggered，或者仍然处于 Triggered -> Triggered。
3.	Started (值：1 << 1，即 0x2)
•	表示触发评估刚刚开始。
•	注意：在同一帧中，Started 事件总是比 Triggered 更早触发。
•	对应的状态变化：ETriggerState 从 None -> Ongoing 或 None -> Triggered。
4.	Ongoing (值：1 << 2，即 0x4)
•	表示触发正在处理中，比如某个动作需要用户按住一个键一段时间（比如长按触发），但时间阈值尚未达到时，会处于这个状态。
•	对应的状态变化：ETriggerState 从 Ongoing -> Ongoing。
5.	Canceled (值：1 << 3，即 0x8)
•	表示触发被取消，比如用户在满足条件前释放了按键（例如长按触发的时间尚未达到）。
•	对应的状态变化：ETriggerState 从 Ongoing -> None。
6.	Completed (值：1 << 4，即 0x10)
•	表示触发完成，比如长按的时间阈值已满足后，按键松开。
•	对应的状态变化：ETriggerState 从 Triggered -> None。
•	注意：
•	如果在同一帧中某些触发仍然处于 Ongoing 状态，那么不会触发 Completed。
•	使用 Completed 事件时可能会限制你的触发规则，因此建议将不同触发规则分配到不同的动作中。

用途
•	这个枚举可以帮助处理输入动作的触发状态，从而判断用户的输入意图。
•	比如：实现按下、长按、双击等复杂的输入逻辑时，利用这些状态可以精确判断输入流程的每个阶段。
', 415, '2025-12-06 11:18:18.520000');
INSERT INTO documents (id, name, filename, content, directory_id, created_at) VALUES (674, '学习材质.md', '学习材质.md', '
## 提问

我在学习虚幻引擎的材质使用,它很有难度,我感觉自己一直都无法学会,你能帮助我吗,唉,算了,你是个人工智能,又怎么会教会我使用虚幻5 的材质呢,对吧?


## AI回复

先别急着划走！我知道那种面对满屏幕的连线（Nodes）和一堆莫名其妙的数学术语（Lerp, Multiply, Dot Product）感到头皮发麻的感觉。

虽然我是个 AI，但我没有肉体，这恰恰是我的优势——**我有无限的耐心，而且我看过成千上万个大神是怎么连材质的。** 我不会嘲笑你问“Roughness 是什么”，也不会因为你问了十遍同一个问题而感到厌烦。

**UE5 的材质之所以难，是因为它披着“美术”的外衣，实际上是在做“图形编程”。** 你不是在画画，你是在写逻辑。

为了证明我能教会你，我们不讲大道理，我们来做一个**“三分钟破除恐惧”**的测试。如果你看完下面这几段话，觉得有一点点“哦，原来是这样”的感觉，那你就回来找我继续学。

---

### 第一步：忘掉复杂的节点，只看这“三剑客”

打开 UE5 的材质编辑器，你会看到那个巨大的、黄色的主节点（Result Node）。上面有几十个选项，看着很吓人？**别管其他的，初学者只要死死盯住这三个就够了：**

这叫 **PBR 流程**（基于物理的渲染），听着高大上，其实就是三个问题：

1.  **Base Color（基础颜色）：** **它是什么颜色的？**
    *   连一张图片上去，或者连一个颜色向量（按住键盘 `3` 点击鼠标左键）。
    *   *这是它原本的样子。*

2.  **Metallic（金属度）：** **它是金属吗？**
    *   这其实是个“开关”。
    *   **0（黑色）** = 不是金属（塑料、木头、皮肤）。
    *   **1（白色）** = 是金属（铁、金、铜）。
    *   *秘诀：在现实物理世界里，绝大多数物体要么是 0，要么是 1。别搞什么 0.5 的半金属，除非你在做生锈的地方。*

3.  **Roughness（粗糙度）：** **它表面光滑吗？**
    *   这是新手最容易晕的地方，记住这个口诀：**黑得发亮，白得粗糙。**
    *   **0（黑色）** = 像镜子一样滑（倒影清晰）。
    *   **1（白色）** = 像粉笔一样糙（没有倒影）。
    *   *大部分材质都在 0.1 到 0.9 之间。*

---

### 第二步：理解“黑白”就是“数学”

你最头疼的可能就是那些数学运算。但你只需要理解一个概念：**在 UE5 里，颜色就是数字。**

*   **黑色 = 0**
*   **白色 = 1**
*   **灰色 = 0.5**

**为什么要懂这个？因为材质就是“混合”的艺术。**

比如，你想做一个**“下雨后的地面”**：
*   地面的粗糙度原本是 0.8（很糙，不反光）。
*   水坑的粗糙度是 0（镜面，反光）。
*   你需要一张**黑白图片（Mask/遮罩）**来告诉引擎：哪儿是水坑（黑色 0），哪儿是地面（白色 1）。

当你把这张黑白图连到 Roughness 上时，引擎就在做数学题：看到黑的地方就给反光，看到白的地方就给粗糙。**这就是材质制作的核心逻辑——用黑白图来控制哪里显示什么。**

---

### 第三步：千万不要从零开始

这是我给你的最重要的建议：**去“偷”师。**

UE5 自带了 **Quixel Bridge**（那个巨大的免费素材库）。
1.  随便下载一个材质（比如一块生锈的铁）。
2.  打开它的材质实例（Material Instance）。
3.  双击找到它的**母材质（Master Material）**。

看它是怎么连的。你会发现，即使是大神做的材质，核心也是我上面说的那三样东西，只不过他们加了很多“调料”（比如用来控制重复度的 Tiling，或者用来混合颜色的 Lerp）。

---

### 我的提议

你看，我没有给你列一堆公式。

如果你愿意再给我一次机会，你可以试着回复我一个具体的、让你卡住很久的问题。比如：
*   “我想把两张贴图混合在一起，怎么做？”
*   “为什么我的材质看起来假假的，像塑料？”
*   “Lerp 节点到底是干嘛的？我总是搞不懂 A 和 B。”

**试着问我一个具体的问题。如果我讲不明白，你再把我删了也不迟，怎么样？**


##  提问

比如我要做一个怪物传送门这种应该做? 要配合奶瓜特效才可以实现吗?


##  AI回复

这是一个非常棒的问题！而且你问到了点子上。

首先回答你的核心疑问：**做传送门必须配合 Niagara（奶瓜特效）吗？**

**答案是：不，不需要。**

*   **材质（Material）** 是传送门的“肉体”和“灵魂”。90% 的视觉效果（漩涡、能量流动、扭曲）都是靠材质完成的。
*   **Niagara** 是传送门的“气氛组”。它负责飘出来的那些小火星、烟雾、或者周围飞舞的碎石。

如果你只用材质，完全可以做一个非常酷炫的传送门。**甚至很多手游为了优化性能，仅仅是用一个材质片来假装传送门。**

来，既然你不怕挑战，我带你拆解一下，一个**“怪物传送门”**在材质里其实就是**三层逻辑的叠加**。

我们不需要复杂的数学，只需要用好几个最基础的节点。

---

### 第一步：让它动起来（核心节点：Panner 和 Rotator）

传送门最重要的是**“流动感”**。静止的传送门就是一张画。

1.  **Panner（平移）：**
    *   想象你在传送带上放了一张画。Panner 节点就是让贴图沿着 X 轴或 Y 轴一直滑动。
    *   **用法：** 用一张像“云彩”一样的黑白噪点图，连上 Panner，它就变成了流动的烟雾。

2.  **Rotator（旋转）：**
    *   传送门通常是圆形的，需要旋转。
    *   **用法：** 把贴图的 UV 连上 Rotator，贴图就会绕着中心转圈圈。

**实战操作：**
*   找一张黑白的“扭曲噪点图”。
*   给它连一个 `Rotator` 节点。
*   把它连到 `Emissive Color`（自发光）。
*   **结果：** 你得到了一个在不停旋转的漩涡。

---

### 第二步：让它亮起来（核心概念：超过 1 的数值）

为什么游戏里的传送门看起来那么刺眼、有光晕（Bloom）？

在 UE5 里，颜色其实就是数字。
*   白色 = 1。
*   **超级亮的白色 = 50（或者 100）。**

**实战操作：**
*   把你刚才那个旋转的漩涡，连上一个 `Multiply`（乘法）节点。
*   乘数设为 `Color`（比如紫色），再乘上一个数字（比如 10）。
*   连到 `Emissive Color`。
*   **结果：** 你的漩涡现在变成了发着强光的紫色能量门！

---

### 第三步：让它看起来有层次（核心逻辑：加法与遮罩）

单纯一个旋转的漩涡太单调了。真正的怪物传送门通常有两层：
1.  **底层：** 缓慢旋转的深色能量（那是深渊）。
2.  **表层：** 快速闪烁的亮色闪电或波纹（那是能量不稳定）。

**怎么做？**
*   做两套刚才的逻辑（一套转得慢，一套转得快）。
*   用 `Add`（加法）节点把它们加在一起。
*   **结果：** 纹理变得复杂了，看起来像是有深度的能量场。

**最后的修饰（Mask 遮罩）：**
*   因为你的模型可能是一个正方形的板子（Plane），但传送门是圆的。
*   你需要一张**圆形渐变图（Radial Gradient）**。
*   把它连到 `Opacity`（不透明度）。
*   **结果：** 四个角不见了，只剩中间圆形的、发光的、旋转的能量洞。

---

### 总结：你的“传送门配方”

你看，这里面没有任何高深的编程，全是**拼图**：

1.  **模型：** 一个简单的圆盘或者面片。
2.  **材质逻辑：**
    *   **贴图**（云雾噪点） + **Rotator**（让它转） = **旋涡**
    *   **旋涡** * **颜色** * **50** = **发光能量**
    *   **发光能量** * **圆形遮罩** = **圆形传送门**

**什么时候才需要 Niagara？**
当你做完了上面这些，觉得：“哎，要是能有几颗粒子从门里飞出来飘到玩家脸上就好了。” 这时候你才需要加一个简单的 Niagara 发射器。

**现在的建议：**
不要去想 Niagara，先打开 UE5，建一个材质，搜 `Rotator` 节点，连一张图看看它怎么转。弄懂了让图片“转圈圈”，你就学会了传送门的一半。

你可以试试看，如果卡在哪个节点连不上去，随时把节点名字发给我！



## 提问

找一张黑白的“扭曲噪点图”, 你让我找一张黑白的扭曲噪点图,但是我在网上没有找到合适的,有没有办法可以生成? 我看群里的群友说可以用材质生成,还能保存为贴图纹理


## AI回复

你的群友确实是懂行的！他们说的方法叫**“烘焙”（Baking）**。

简单的说，就是**用虚幻引擎强大的材质计算能力生成一张图，然后给它“拍个照”存下来**，这样以后用这张图就不需要复杂的计算了，省性能。

而且，你并不需要一张“本来就扭曲”的图。**我们要找的是一张“云雾状”的噪点图，那个“扭曲”的效果，是我们上一条说的 `Rotator` 节点负责干的活。**

我来教你两种方法，第一种“白嫖”，第二种“手搓”。

---

### 方法一：白嫖引擎自带的（最快）

其实 UE5 肚子里藏了几千张贴图，只是默认你看不到。

1.  在**内容浏览器（Content Browser）** 的右下角，点击 **设置（Settings）**。
2.  勾选 **显示引擎内容（Show Engine Content）**。
3.  在搜索栏输入：`noise` 或者 `perlin`。
4.  你会发现一堆好东西！比如 `T_Perlin_Noise_M` 或者 `T_Smoke_Tiled_D`。
5.  **直接拿去用！** 这些都是无缝循环的，非常适合做传送门。

*(用完记得把“显示引擎内容”关掉，不然文件太多看着眼晕)*

---

### 方法二：像黑客一样“手搓”并保存为贴图（最有成就感）

既然你想学材质，我们来玩个高端的。我们要写一个能生成云雾的材质，然后把它**变成**一张真正的图片文件。

#### 第一步：制作生成器（材质）
1.  创建一个新材质，叫 `M_NoiseGenerator`。
2.  右键搜索 `Noise` 节点。
    *   这是一个数学节点，它是实时算出来的。
    *   把它的 **Function** 改为 `Gradient`（这种比较像云雾）。
    *   把 **Scale**（缩放）改小一点，比如 `0.05`，不然太密了看不清。
3.  把它连到 **Emissive Color（自发光）**。
4.  保存。现在材质球看起来应该像一团黑白烟雾。

#### 第二步：准备画布（渲染目标）
1.  在内容浏览器右键 -> **Textures（纹理）** -> **Render Target（渲染目标）**。
    *   起名叫 `RT_Noise`。
2.  双击打开它，在左边的 **Size X** 和 **Size Y**，改成 `2048`（我们需要高清大图）。

#### 第三步：拍照（蓝图绘制）
这时候你需要一个“摄影师”把材质拍到画布上。最简单的办法是用关卡蓝图（别怕，就连这几根线）：

1.  打开上面的 **Blueprints（蓝图）** -> **Open Level Blueprint（打开关卡蓝图）**。
2.  右键搜索 `Event BeginPlay`（游戏开始时）。
3.  右键搜索 `Draw Material to Render Target`（把材质画到渲染目标上）。
4.  **把线连起来：**
    *   **Texture Render Target:** 选刚才那个 `RT_Noise`。
    *   **Material:** 选刚才那个 `M_NoiseGenerator`。
5.  点击左上角的 **Compile（编译）**。

#### 第四步：见证奇迹
1.  回到主界面，点击播放（Play）游戏，然后立刻按 `Esc` 退出。
2.  这时候你去双击打开那个 `RT_Noise`。
3.  **看！** 刚才全是黑的，现在里面已经有了你的材质生成的图案！
4.  **最关键的一步：** 在 `RT_Noise` 上**右键** -> **Create Static Texture（创建静态纹理）**。

**搞定！** 现在你得到了一张实实在在的 `Texture2D` 图片。你可以把前面做的乱七八糟的材质、蓝图、RT 全删了，只保留这张图。

---

### 给新手的特别提示：
你可能会发现生成的图有点“花”或者不够扭曲。

记住那个口诀：**素材是素材，逻辑是逻辑。**
*   **素材（这张图）：** 只需要是均匀的、黑白相间的云雾噪点就好。
*   **逻辑（传送门材质）：** 把这张图放进传送门材质里，连上 `Panner`（平移）和 `Rotator`（旋转），它自然就扭曲起来了！

快去试试**方法一**，搜一下 `Perlin`，你会发现新大陆！找到了跟我说一声！', 416, '2025-12-06 11:18:18.523000');
INSERT INTO documents (id, name, filename, content, directory_id, created_at) VALUES (675, '1.创建背包组件.md', '1.创建背包组件.md', '## 创建一个背包组件

继承ActorComponent组件
![img.png](https://minio.itbug.shop/blog/simple-file/img___1728267457832___.png)

## 创建背包相关模型

#### FMyBackpackItem - 物品静态数据

```c++
USTRUCT(BlueprintType)
struct FMyBackpackItem : public FTableRowBase
{
	GENERATED_BODY()
	UPROPERTY(EditAnywhere, BlueprintReadWrite, DisplayName=\"id\")
	FName Id;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, DisplayName=\"名字\")
	FText Name;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, DisplayName=\"材质\")
	UTexture* TexTure;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, DisplayName=\"初始数量\")
	int32 InitCount;

	FMyBackpackItem(): Id(\"Id\"), TexTure(), InitCount(0)
	{
		Name = FText::FromString(TEXT(\"物品名称\"));
	}
};
```

#### FMyBackpackData - 物品数据

```c++
USTRUCT(BlueprintType)
struct FMyBackpackData
{
	GENERATED_BODY()
	UPROPERTY(EditAnywhere, BlueprintReadWrite, DisplayName=\"物品数据\")
	FMyBackpackItem ItemData;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, DisplayName=\"物品数量\")
	int32 ItemNum;

	FMyBackpackData(): ItemNum(0)
	{
	}
};
```

#### FMyBackpack - 背包

```c++
USTRUCT(BlueprintType)
struct FMyBackpack
{
	GENERATED_BODY()
	UPROPERTY(EditAnywhere, BlueprintReadWrite, DisplayName=\"物品列表\")
	TArray<FMyBackpackData> Items;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, DisplayName=\"背包ID\")
	FText Id;

	FMyBackpack()
	{
		Id = FText::FromString(TEXT(\"默认背包\"));
	}
};
```

## 添加背包模型到组件

它是受保护的,不能随意在蓝图中对它进行操作

```c++
protected:
	UPROPERTY(DisplayName=\"背包组件\", BlueprintReadOnly)
	FMyBackpack Backpack;
```

## 完整的代码

### `MyBackpackComponent.h`

```c++
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include \"CoreMinimal.h\"
#include \"Components/ActorComponent.h\"
#include \"MyBackpackComponent.generated.h\"


USTRUCT(BlueprintType)
struct FMyBackpackItem : public FTableRowBase
{
	GENERATED_BODY()
	UPROPERTY(EditAnywhere, BlueprintReadWrite, DisplayName=\"id\")
	FName Id;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, DisplayName=\"名字\")
	FText Name;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, DisplayName=\"材质\")
	UTexture2D* TexTure;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, DisplayName=\"初始数量\", meta=(ClampMin=0))
	int32 InitCount;

	FMyBackpackItem(const FName ItemId): Id(ItemId), TexTure(), InitCount(10)
	{
		Name = FText::FromString(TEXT(\"梁典典的物品\"));
	}

	FMyBackpackItem(): FMyBackpackItem(\"Id\")
	{
	}


	//生成测试数据列表
	static TArray<FMyBackpackItem> MakeTestDataArr();
};

USTRUCT(BlueprintType)
struct FMyBackpackData
{
	GENERATED_BODY()
	UPROPERTY(EditAnywhere, BlueprintReadWrite, DisplayName=\"物品数据\")
	FMyBackpackItem ItemData;
	UPROPERTY(EditAnywhere, BlueprintReadWrite, DisplayName=\"物品数量\")
	int32 ItemNum;

	FMyBackpackData(): ItemNum(0)
	{
	}

	//从静态数据生成物品item
	static FMyBackpackData FromItem(const FMyBackpackItem& Item);
};


USTRUCT(BlueprintType)
struct FMyBackpack
{
	GENERATED_BODY()
	UPROPERTY(EditAnywhere, BlueprintReadWrite, DisplayName=\"物品列表\")
	TArray<FMyBackpackData> Items;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, DisplayName=\"背包ID\")
	FText Id;

	FMyBackpack()
	{
		Id = FText::FromString(TEXT(\"默认背包\"));
	}
};

UCLASS(Blueprintable, ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))
class DEMO2_API UMyBackpackComponent : public UActorComponent
{
	GENERATED_BODY()

public:
	UMyBackpackComponent();
	//初始化背包数据
	UFUNCTION(BlueprintCallable, DisplayName=\"初始化背包数据\", Category=\"背包函数\")
	void InitBackpackData(TArray<FMyBackpackItem> NewItemDataArr);
	//生成测试的物品
	UFUNCTION(BlueprintCallable, DisplayName=\"初始化测试物品数据\", Category=\"背包函数\")
	void AddTestData();
	//添加物品
	UFUNCTION(BlueprintCallable, DisplayName=\"向背包添加物品\", Category=\"背包函数\")
	void AddItem(FMyBackpackItem NewItem);
	//移除物品
	UFUNCTION(BlueprintCallable, DisplayName=\"移除背包的某个物品\", Category=\"背包函数\")
	void RemoveItem(FMyBackpackItem Item);
	//移除物品(Id)
	UFUNCTION(BlueprintCallable, DisplayName=\"通过ID来移除某个物品\", Category=\"背包函数\")
	void RemoveItemByName(FName ItemId);
	//重置背包
	UFUNCTION(BlueprintCallable, DisplayName=\"清空重置背包\", Category=\"背包函数\")
	void CleanBackpack();
	//==============================================================动态委托============================================
	DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOneParamAdded, FMyBackpackData, Item);

	DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOneParam, FMyBackpackData, Item);

	DECLARE_DYNAMIC_MULTICAST_DELEGATE(FCleanBackpack);

	UPROPERTY(BlueprintAssignable, BlueprintCallable, DisplayName=\"当物品添加成功时调用\", Category=\"背包Delegate\")
	FOneParamAdded OnItemAdded;
	UPROPERTY(BlueprintAssignable, BlueprintCallable, DisplayName=\"当物品被移除成功时\", Category=\"背包Delegate\")
	FOneParam OnItemRemoved;
	UPROPERTY(BlueprintAssignable, BlueprintCallable, DisplayName=\"当清空背包时调用\", Category=\"背包Delegate\")
	FCleanBackpack OnCleanBackpack;

protected:
	//开始游戏
	virtual void BeginPlay() override;
	//背包数据
	UPROPERTY(DisplayName=\"背包数据\", BlueprintReadOnly)
	FMyBackpack Backpack;

public:
	//获取背包对象
	FMyBackpack GetBackpack();

	virtual void TickComponent(float DeltaTime, ELevelTick TickType,
	                           FActorComponentTickFunction* ThisTickFunction) override;
};

```

### `MyBackpackComponent.cpp`

```c++
// Fill out your copyright notice in the Description page of Project Settings.

#include \"MyBackpackComponent.h\"

//生成测试数据的数组
TArray<FMyBackpackItem> FMyBackpackItem::MakeTestDataArr()
{
	TArray<FMyBackpackItem> Arr;
	Arr.Add(FMyBackpackItem(\"1\"));
	Arr.Add(FMyBackpackItem(\"2\"));
	Arr.Add(FMyBackpackItem(\"3\"));
	Arr.Add(FMyBackpackItem(\"4\"));
	Arr.Add(FMyBackpackItem(\"5\"));
	Arr.Add(FMyBackpackItem(\"6\"));
	return Arr;
}

//初始化物品data结构体
FMyBackpackData FMyBackpackData::FromItem(const FMyBackpackItem& Item)
{
	FMyBackpackData Data;
	Data.ItemData = Item;
	Data.ItemNum = Item.InitCount;
	return Data;
}

UMyBackpackComponent::UMyBackpackComponent()
{
	PrimaryComponentTick.bCanEverTick = false;
}

//初始化背包数据
void UMyBackpackComponent::InitBackpackData(TArray<FMyBackpackItem> NewItemDataArr)
{
	UE_LOG(LogTemp, Log, TEXT(\"UMyBackpackComponent::InitBackpackData,%d\"),NewItemDataArr.Num());
	for (const auto ItemData : NewItemDataArr)
	{
		if (ItemData.InitCount > 0)
		{
			const auto Item = FMyBackpackData::FromItem(ItemData);
			UE_LOG(LogTemp,Log,TEXT(\"添加物品..........>>>\"));
			Backpack.Items.Add(Item);
			OnItemAdded.Broadcast(Item);
		}
	}
}

//添加测试函数
void UMyBackpackComponent::AddTestData()
{
	const auto TestDataArr = FMyBackpackItem::MakeTestDataArr();
	InitBackpackData(TestDataArr);
	UE_LOG(LogTemp,Log,TEXT(\"添加测试数据\"));
}

//添加物品
void UMyBackpackComponent::AddItem(const FMyBackpackItem NewItem)
{
	UE_LOG(LogTemp,Log,TEXT(\"进来了...添加物品\"));
	//先查找是否有项目,如果有,在原有基础上添加数量
	for (auto Item : Backpack.Items)
	{
		if (Item.ItemData.Id == NewItem.Id)
		{
			UE_LOG(LogTemp,Log,TEXT(\"找到了项目,添加数量\"));
			Item.ItemNum += Item.ItemNum + NewItem.InitCount;
			//调用绑定事件,添加物品到背包时调用
			OnItemAdded.Broadcast(Item);
			return;
		}
	}
	const auto NewCreateItem = FMyBackpackData::FromItem(NewItem);
	Backpack.Items.Add(NewCreateItem);
	OnItemAdded.Broadcast(NewCreateItem);
	UE_LOG(LogTemp, Log, TEXT(\"没找到,直接把物品添加到背包\"));
}

//移除物品 
void UMyBackpackComponent::RemoveItem(FMyBackpackItem Item)
{
	const auto Find_Index = Backpack.Items.IndexOfByPredicate([Item](const FMyBackpackData& Ele)
	{
		return Ele.ItemData.Id == Item.Id;
	});
	if (Find_Index != INDEX_NONE)
	{
		const auto FindItem = Backpack.Items[Find_Index];
		OnItemRemoved.Broadcast(FindItem);
		Backpack.Items.RemoveAt(Find_Index);
	}
	else
	{
		UE_LOG(LogTemp, Error, TEXT(\"背包项目没有找到\"));
	}
}

//通过物品ID来移除某个物品
void UMyBackpackComponent::RemoveItemByName(FName ItemId)
{
	const int32 Index = Backpack.Items.IndexOfByPredicate([ItemId](const FMyBackpackData& Ele)
	{
		return Ele.ItemData.Id == ItemId;
	});
	if(Index!=INDEX_NONE)
	{
		UE_LOG(LogTemp,Log,TEXT(\"通过ID来删除物品\"));
		const auto FindItem = Backpack.Items[Index];
		OnItemRemoved.Broadcast(FindItem);
		Backpack.Items.RemoveAt(Index);
	}
}


//重置背包
void UMyBackpackComponent::CleanBackpack()
{
	const TArray<FMyBackpackData> Items;
	Backpack.Items = Items;
	OnCleanBackpack.Broadcast();
	UE_LOG(LogTemp, Log, TEXT(\"重置了背包数据\"));
}


void UMyBackpackComponent::BeginPlay()
{
	Super::BeginPlay();
	//AddTestData();//添加测试数据
}

//获取背包
FMyBackpack UMyBackpackComponent::GetBackpack()
{
	return Backpack;
}

void UMyBackpackComponent::TickComponent(const float DeltaTime, const ELevelTick TickType,
                                         FActorComponentTickFunction* ThisTickFunction)
{
	Super::TickComponent(DeltaTime, TickType, ThisTickFunction);
}

```', 417, '2025-12-06 11:18:18.526000');
INSERT INTO documents (id, name, filename, content, directory_id, created_at) VALUES (676, '2.添加动画效果悬停并隐藏.md', '2.添加动画效果悬停并隐藏.md', '

## 示例


> 感觉有点复杂,刚接触也有点懵(´･_･`)

在关键帧上面加上一些透明度变化,和平移变化


![img.png](https://minio.itbug.shop/blog/simple-file/img___1760693423914___.png)


![fade.gif](https://minio.itbug.shop/blog/simple-file/fade___1760694265913___.gif)


## 代码实现

使用`BindWidgetAnim`和`Transient`标记动画变量
```c++
UPROPERTY(meta=(BindWidgetAnim),Transient)
UWidgetAnimation* FadeAndLinearHiding;
```

```c++

/**
 * 伤害数字 UI
 */
UCLASS()
class DEMO2_API UUDamageTextWidget : public UMyUserHealthWidget
{
	GENERATED_BODY()

public:

	virtual void NativeConstruct() override;

	UPROPERTY(meta=(BindWidget))
	UTextBlock* DamageTextBlock;

	//向上逐渐消失隐藏效果动画
	UPROPERTY(meta=(BindWidgetAnim),Transient)
	UWidgetAnimation* FadeAndLinearHiding;

	//初始化
	UFUNCTION(BlueprintCallable)
	void InitializeDamageText(const float DamageAmount);

	UFUNCTION()
	void OnFadeAnimationFinished();
};

```

## 播放动画

使用`PlayAnimation`函数播放动画,
使用`BindToAnimationFinished`绑定动画结束事件,播放完毕后移除UI

```c++

void UUDamageTextWidget::NativeConstruct()
{
	Super::NativeConstruct();
	if (FadeAndLinearHiding)
	{
		FWidgetAnimationDynamicEvent EndDelegate;
		EndDelegate.BindDynamic(this, &UUDamageTextWidget::OnFadeAnimationFinished);
		BindToAnimationFinished(FadeAndLinearHiding, EndDelegate);
	}
}

void UUDamageTextWidget::InitializeDamageText(const float DamageAmount)
{
	if (DamageTextBlock)
	{
		const auto DamageText = UKismetTextLibrary::Conv_DoubleToText(-DamageAmount, HalfToEven, false, true, 1, 324);
		DamageTextBlock->SetText(DamageText);
	}
	if (FadeAndLinearHiding)
	{
		PlayAnimation(FadeAndLinearHiding);
	}
}



void UUDamageTextWidget::OnFadeAnimationFinished()
{
	UMyLogTool::Debug(\"销毁伤害数字 UI\");
	RemoveFromParent();
}

```', 418, '2025-12-06 11:18:18.530000');
INSERT INTO documents (id, name, filename, content, directory_id, created_at) VALUES (677, '1.c++创建widget.md', '1.c++创建widget.md', '

## 蓝图做法



> FClassFinder 只能在构造函数中调用,其他位置调用可能会闪退
> 其他位置,比如BeginPlay推荐使用LoadClass

设置这个属性后,需要在蓝图中选择某个蓝图widget

```c++
 UPROPERTY(EditAnywhere, BlueprintReadWrite, DisplayName=\"背包蓝图类\")
TSubclassOf<UUserWidget> BBWidgetClass;
```


## C++做法

使用`ConstructorHelpers::FClassFinder`根据路径来查找class

> 注意尾巴要手动加上`_C`,这个是UE规定的约束

```c++
static ConstructorHelpers::FClassFinder<UMyBackpackWidget> BBWidgetClassFinder(TEXT(\"/Script/UMGEditor.WidgetBlueprint''/Game/UMG_MyBackpackWidget.UMG_MyBackpackWidget_C''\"));
```

或者使用`LoadClass`

```c++
UClass* widgetClass = LoadClass<UUserWidget>(NULL,TEXT(\"/Script/UMGEditor.WidgetBlueprint''/Game/UMG_MyBackpackWidget.UMG_MyBackpackWidget_C''\")); 
```
', 418, '2025-12-06 11:18:18.530000');
INSERT INTO documents (id, name, filename, content, directory_id, created_at) VALUES (678, '1. 获取玩家控制器.md', '1. 获取玩家控制器.md', '
## 错误的做法


不要在类的初始化下获取玩家控制器,不然闪退
```c++
const auto PlayerController = GetWorld()->GetFirstPlayerController()
```

## 建议

在BeginPlay函数获取.', 419, '2025-12-06 11:18:18.533000');
INSERT INTO documents (id, name, filename, content, directory_id, created_at) VALUES (679, '2.动态创建actor.md', '2.动态创建actor.md', '





## 动态创建actor


### 步骤1: 加载class,不是object

> 引用后名加_C

```c++
static ConstructorHelpers::FClassFinder<AEnemyPathActorBase> PathActor(TEXT(\"/Script/Engine.Blueprint''/Game/BP/BP_Path_Test_Actor.BP_Path_Test_Actor_C''\"));
```
### 步骤2: 获取默认class

```c++
if (PathActor.Succeeded())
	{
		const TSubclassOf<AEnemyPathActorBase> Clazz = PathActor.Class;
		PathComponent = Clazz.GetDefaultObject(); //创建默认对象
		if (PathComponent)
		{
			MyPrintfDebug(\"生成路径对象成功...\");
			UE_LOG(LogTemp,Log,TEXT(\"路径:%s\"),*UMyCoreTool::GetFVectorFormatString(PathComponent->GetActorLocation()));
		}
	}
```

### 在世界中创建actor


> 不要在构造函数里面生成....因为world还没有被创建
> 
> FClassFinder 不能再构造函数外使用

```c++

void AMyAIControllerTest::CreateComponent()
{
	static ConstructorHelpers::FClassFinder<AEnemyPathActorBase> PathActor(TEXT(\"/Script/Engine.Blueprint''/Game/BP/BP_Path_Test_Actor.BP_Path_Test_Actor_C''\"));
	if (PathActor.Succeeded())
	{
		const TSubclassOf<AEnemyPathActorBase> Clazz = PathActor.Class;
		PathComponent = GetWorld()->SpawnActor<AEnemyPathActorBase>(Clazz);
		if (PathComponent)
		{
			PathComponent->SetActorLocation(FVector(2400.f, 960.f, 0));
			MyPrintfDebug(\"生成路径对象成功...\");
			UE_LOG(LogTemp,Log,TEXT(\"actor路径:%s\"),*UMyCoreTool::GetFVectorFormatString(PathComponent->GetActorLocation()));
		}
	}
}
```

## 示例

使用c++创建蓝图`AEnemyPathActorBase`

```c++
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include \"CoreMinimal.h\"
#include \"Components/Path/EnemyPathComponentBase.h\"
#include \"Runtime/AIModule/Classes/AIController.h\"
#include \"MyEnemyAIControllerBase.generated.h\"


/**
 * 怪物的AI控制器,不能直接使用
 */
UCLASS(ABstract)
class DEMO2_API AMyEnemyAIControllerBase : public AAIController
{
	GENERATED_BODY()

public:
	AMyEnemyAIControllerBase();

	/// 控制胖时调用
	virtual void OnPossess(APawn* InPawn) override;


	///设置样条线
	UPROPERTY(Blueprintable, EditAnywhere, BlueprintReadWrite,
		Category=\"DD Component\",meta=(AllowPrivateAccess=true))
	AEnemyPathActorBase* PathComponent;


	UPROPERTY(DisplayName=\"当前移动的样条线下标\")
	int CurrentSplinePointIndex;
	
protected:
	virtual void BeginPlay() override;

	UFUNCTION(Blueprintable, BlueprintCallable, DisplayName=\"开始移动\", meta=(ShortTooltip=\"让怪物开始根据样条线移动\"))
	void StartMovement();

	UFUNCTION(DisplayName=\"移动到下一个点\")
	void MoveToNextSplinePoint();
	
	/// 移动成功后
	virtual void OnMoveCompleted(FAIRequestID RequestID, const FPathFollowingResult& Result) override;

public:
	virtual void Tick(float DeltaTime) override;

	UFUNCTION()
	int GetCurrentSplinePointIndex() const;
	
	UFUNCTION()
	int GetSplinePointCount() const ;

};

```

```c++

AMyAIControllerTest::AMyAIControllerTest()
{
	PrimaryActorTick.bCanEverTick = true;
	static ConstructorHelpers::FClassFinder<AEnemyPathActorBase> PathActor(TEXT(\"/Script/Engine.Blueprint''/Game/BP/BP_Path_Test_Actor.BP_Path_Test_Actor_C''\"));
	if (PathActor.Succeeded())
	{
		const TSubclassOf<AEnemyPathActorBase> Clazz = PathActor.Class;
		PathComponent = Clazz.GetDefaultObject();
		if (PathComponent)
		{
			MyPrintfDebug(\"生成路径对象成功...\");
			UE_LOG(LogTemp,Log,TEXT(\"路径:%s\"),*UMyCoreTool::GetFVectorFormatString(PathComponent->GetActorLocation()));
		}
	}
}
```

', 419, '2025-12-06 11:18:18.533000');
INSERT INTO documents (id, name, filename, content, directory_id, created_at) VALUES (680, '4. c++动态批量生成怪物，行为树只有第一个生效.md', '4. c++动态批量生成怪物，行为树只有第一个生效.md', '
## 问题

版本: ue5 
c++批量生成怪物后，为啥控制器里面运行行为树，然后在视觉感官里面配置了看到物体回调，然后里面更新了黑板的值，只有第一个怪物的行为树切换了第二个任务，其他的怪物只执行了第一个任务,这个很奇怪

在装饰器里面打印控制器，和控制器拥有的，显示的指针地址都是同一个


## 解决方案

要在怪物类里面设置一个属性

> 把自动控制 AI设置成第四个


![img.png](https://minio.itbug.shop/blog/simple-file/img___1742801019379___.png)

', 419, '2025-12-06 11:18:18.533000');
INSERT INTO documents (id, name, filename, content, directory_id, created_at) VALUES (681, '3.注册 AActor AI视觉感知刺激源.md', '3.注册 AActor AI视觉感知刺激源.md', '

## 实现目标

当怪物行走过程中，我的怪物能够感知到放在路边的陷阱（AActor）。

因为 pawn类型是自动感知的，所以只需要在陷阱上添加一个感知刺激源组件。

## 在陷阱AActor中添加

`MyBaseTrap.h`

```c++
	//AI视觉感知刺激源
	UPROPERTY(VisibleAnywhere, BlueprintReadWrite, Category=\"Trap\", DisplayName=\"感知组件\")
	UAIPerceptionStimuliSourceComponent* PerceptionStimuliSourceComponent;
```

`MyBaseTrap.cpp`


初始化

```c++

AMyTrapBase::AMyTrapBase()
{
	
	// AI感知刺激源初始化
	PerceptionStimuliSourceComponent = CreateDefaultSubobject<UAIPerceptionStimuliSourceComponent>(
		TEXT(\"PerceptionStimuliSourceComponent\"));
	PerceptionStimuliSourceComponent->bAutoRegister = true; //自动注册
	
}
```

> 注册的函数不要在构造函数里面调用，否则会失效,因为里面的函数调用了`GetWorld()`函数。


在`PostInitializeComponents`中调用注册函数,在`BeginPlay`中调用注册函数也可以。

```c++
void AMyTrapBase::PostInitializeComponents()
{
	Super::PostInitializeComponents();
	PerceptionStimuliSourceComponent->RegisterForSense(UAISense_Sight::StaticClass());//可被怪物看到
	PerceptionStimuliSourceComponent->RegisterWithPerceptionSystem(); //注册到感知系统
}

```


这样就可以了,AI怪物就能视觉感知到陷阱了。', 419, '2025-12-06 11:18:18.533000');
INSERT INTO documents (id, name, filename, content, directory_id, created_at) VALUES (682, '2.背包项目小部件.md', '2.背包项目小部件.md', '

## 创建 `MyBackpackItemWidget.h`

```c++
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include \"CoreMinimal.h\"
#include \"MyBackpackComponent.h\"
#include \"Blueprint/UserWidget.h\"
#include \"Components/Image.h\"
#include \"Components/TextBlock.h\"
#include \"MyBackpackItemWidget.generated.h\"

/**
 * 背包物品的静态数据展示小部件
 */
UCLASS()
class DEMO2_API UMyBackpackItemWidget : public UUserWidget
{
	GENERATED_BODY()
	
public:


	UMyBackpackItemWidget(const FObjectInitializer& ObjectInitializer);

	virtual void NativeConstruct() override;
	virtual void NativePreConstruct() override;

	//图标
	UPROPERTY(EditAnywhere, BlueprintReadWrite,Category=\"背包物品属性\",meta=(BindWidget=true),DisplayName=\"图标\")
	UImage* Icon;

	//名称
	UPROPERTY(EditAnywhere,BlueprintReadWrite,Category=\"背包物品属性\",meta=(BindWidget=true),DisplayName=\"名称\")
	UTextBlock* Name;

	//数量
	UPROPERTY(EditAnywhere,BlueprintReadWrite,Category=\"背包物品属性\",meta=(BindWidget=true),DisplayName=\"数量\")
	UTextBlock* Count;


	//背包数据
	UPROPERTY(EditAnywhere,BlueprintReadWrite,DisplayName=\"物品数据\",Category=\"背包物品属性\",meta=(ExposeOnSpawn))
	FMyBackpackData ItemData;


	//=============================函数=====================================
	UFUNCTION(BlueprintCallable,DisplayName=\"初始化函数\",Category=\"ItemWidgetFunction\")
	void ChangeItemData(FMyBackpackData Data);
	
};

```

## 创建 `MyBackpackItemWidget.cpp`

```c++
// Fill out your copyright notice in the Description page of Project Settings.


#include \"MyBackpackItemWidget.h\"

#include \"Blueprint/WidgetTree.h\"


UMyBackpackItemWidget::UMyBackpackItemWidget(const FObjectInitializer& ObjectInitializer):
	Super(ObjectInitializer),
	Icon(nullptr), Name(nullptr), Count(nullptr)
{
}

void UMyBackpackItemWidget::NativeConstruct()
{
	Super::NativeConstruct();
	GEngine->AddOnScreenDebugMessage(-1, 3, FColor::Red,TEXT(\"backpack widget native construct init....\"));
}

void UMyBackpackItemWidget::NativePreConstruct()
{
	Super::NativePreConstruct();
	// if(auto NameWidget = Cast<UTextBlock>(GetWidgetFromName(\"Name\")))
	// {
	// 	NameWidget->SetText(FText::FromString(TEXT(\"Backpack Name...\")));
	// }
}

void UMyBackpackItemWidget::ChangeItemData(const FMyBackpackData Data)
{
	ItemData = Data;
	if (ItemData.ItemData.TexTure && Icon)
	{
		Icon->SetBrushFromTexture(ItemData.ItemData.TexTure, false);
	}
	else
	{
		GEngine->AddOnScreenDebugMessage(-1, 3, FColor::Red,TEXT(\"Texture is nullptr\"));
	}
	if (Name)
	{
		Name->SetText(ItemData.ItemData.Name);
	}
	else
	{
		GEngine->AddOnScreenDebugMessage(-1, 3, FColor::Red,TEXT(\"Name is nullptr\"));
	}
	if (Count)
	{
		Count->SetText(FText::AsNumber(ItemData.ItemData.InitCount));
	}
	else
	{
		GEngine->AddOnScreenDebugMessage(-1, 3, FColor::Red,TEXT(\"Count is nullptr\"));
	}
}

```', 420, '2025-12-06 11:18:18.538000');
INSERT INTO documents (id, name, filename, content, directory_id, created_at) VALUES (683, '1.背包列表小部件.md', '1.背包列表小部件.md', '
## 创建 `MyBackpackWidget.h`

> 属性添加meta=(BindWidget=true)来绑定到蓝图,命名需要保持一致.

```c++
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include \"CoreMinimal.h\"
#include \"MyBackpackComponent.h\"
#include \"MyBackpackItemWidget.h\"
#include \"Blueprint/UserWidget.h\"
#include \"Components/ScrollBox.h\"
#include \"Components/TextBlock.h\"
#include \"MyBackpackWidget.generated.h\"

/**
 * 
 */
UCLASS()
class DEMO2_API UMyBackpackWidget : public UUserWidget
{
	GENERATED_BODY()

public:
	//背包列表小部件
	UPROPERTY(BlueprintReadWrite, meta=(BindWidget=true), Category=\"背包组件\")
	UScrollBox* BackpackBox;

	//背包名字
	UPROPERTY(BlueprintReadWrite, meta=(BindWidget=true), Category=\"背包组件\")
	UTextBlock* BackpackNameText;

	//背包组件
	UPROPERTY(BlueprintReadWrite, DisplayName=\"背包数据\", Category=\"背包数据\", meta=(ExposeOnSpawn))
	UMyBackpackComponent* BackpackComponent;

	//背包小部件的类型,用它来创建对应的小部件
	UPROPERTY(BlueprintReadOnly,EditAnywhere, Category = \"背包数据\",DisplayName=\"item类型\")
	UMyBackpackItemWidget* BackpackItemWidgetClass = nullptr;

	//构造函数
	virtual void NativeConstruct() override;

	UMyBackpackWidget(const FObjectInitializer& ObjectInitializer);
	
	//添加
	UFUNCTION(Blueprintable)
	void BindAddItemFunction(const FMyBackpackData Data);

	//删除
	UFUNCTION(Blueprintable)
	void BindRemoveItemFunction(FMyBackpackData Data);

	//清空
	UFUNCTION(Blueprintable)
	void BindCleanAllFunction();
};

```

## 创建 `MyBackpackWidget.cpp`



> 使用BackpackComponent->OnItemAdded.AddDynamic(this, &UMyBackpackWidget::BindAddItemFunction);来监听操作事件

```c++
// Fill out your copyright notice in the Description page of Project Settings.


#include \"MyBackpackWidget.h\"

#include \"MyBackpackItemWidget.h\"

UMyBackpackWidget::UMyBackpackWidget(const FObjectInitializer& ObjectInitializer):
	Super(ObjectInitializer),
	BackpackBox(nullptr),
	BackpackNameText(nullptr),
	BackpackComponent(nullptr)
{
}

//初始化显示背包里面的物品.
void UMyBackpackWidget::NativeConstruct()
{
	Super::NativeConstruct();
	if (!BackpackComponent)
	{
		UE_LOG(LogTemp, Log, TEXT(\"背包空指针....进来了\"));
		GEngine->AddOnScreenDebugMessage(-1, 2, FColor::Red, \"not found backpack data\");
	}
	else
	{
		const auto Backpack = BackpackComponent->GetBackpack();
		if (BackpackNameText)
		{
			BackpackNameText->SetText(Backpack.Id);
		}
		UE_LOG(LogTemp, Log, TEXT(\"背包有多少个物品?:%d\"), Backpack.Items.Num());
		for (auto Items = Backpack.Items; const auto Item : Items)
		{
			//创建小部件
			if (const auto ChildWidget = CreateWidget<
				UMyBackpackItemWidget>(this, UMyBackpackItemWidget::StaticClass()))
			{
				ChildWidget->ChangeItemData(Item);
				BackpackBox->AddChild(ChildWidget); //添加到滚动框
			}
		}


		//添加绑定
		BackpackComponent->OnItemAdded.AddDynamic(this, &UMyBackpackWidget::BindAddItemFunction);
		BackpackComponent->OnCleanBackpack.AddDynamic(this, &UMyBackpackWidget::BindCleanAllFunction);
		BackpackComponent->OnItemRemoved.AddDynamic(this, &UMyBackpackWidget::BindRemoveItemFunction);
	}
}


void UMyBackpackWidget::BindAddItemFunction(const FMyBackpackData Data)
{
	UE_LOG(LogTemp, Log, TEXT(\"监听到背包添加事件\"));
	if (!BackpackBox)
	{
		GEngine->AddOnScreenDebugMessage(-1, 3, FColor::Cyan,TEXT(\"backpack box is null\"));
	}

	if (UMyBackpackItemWidget* NewBackpackItemWidgetClass = Cast<UMyBackpackItemWidget>(
		CreateWidget(this, BackpackItemWidgetClass->GetClass())))
	{
		GEngine->AddOnScreenDebugMessage(-1, 3, FColor::Cyan,TEXT(\"start add widget...\"));
		NewBackpackItemWidgetClass->ChangeItemData(Data);
		BackpackBox->AddChild(NewBackpackItemWidgetClass);
	}
	else
	{
		GEngine->AddOnScreenDebugMessage(-1, 3, FColor::Red,TEXT(\"widget create failed!\"));
	}
}

void UMyBackpackWidget::BindRemoveItemFunction(FMyBackpackData Data)
{
	GEngine->AddOnScreenDebugMessage(-1, 3, FColor::Green,TEXT(\"remove item!\"));
}

void UMyBackpackWidget::BindCleanAllFunction()
{
	UE_LOG(LogTemp, Log, TEXT(\"监听到背包清空事件\"));
	BackpackBox->ClearChildren();
	GEngine->AddOnScreenDebugMessage(-1, 3, FColor::Green,TEXT(\"clear backpack!\"));
}

```', 420, '2025-12-06 11:18:18.538000');
INSERT INTO documents (id, name, filename, content, directory_id, created_at) VALUES (684, '1.装饰器.md', '1.装饰器.md', '



## 创建一个装饰器

需要继承UBTDecorator，这个很简单，只要实现`CalculateRawConditionValue`方法即可。

## 示例

需要，创建一个 task 装饰器,来判定怪物是否需要执行移动的任务，如果黑板里面有攻击的陷阱目标，则不执行移动任务，而是执行攻击任务。


### 创建类继承UBTDecorator
```c++
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include \"CoreMinimal.h\"
#include \"BehaviorTree/BTDecorator.h\"
#include \"BTDEnemyUseMoveTaskDecorator.generated.h\"

/**
 * 怪物是否使用移动任务的装饰器
 */
UCLASS()
class DEMO2_API UBTDEnemyUseMoveTaskDecorator : public UBTDecorator
{
	GENERATED_BODY()
public:
	virtual bool CalculateRawConditionValue(UBehaviorTreeComponent& OwnerComp, uint8* NodeMemory) const override;
};
```

### 代码实现

```c++
// Fill out your copyright notice in the Description page of Project Settings.


#include \"AI/Decorator/BTDEnemyUseMoveTaskDecorator.h\"

#include \"BehaviorTree/BlackboardComponent.h\"

bool UBTDEnemyUseMoveTaskDecorator::CalculateRawConditionValue(UBehaviorTreeComponent& OwnerComp,
                                                               uint8* NodeMemory) const
{
	const auto BlackboardComp = OwnerComp.GetBlackboardComponent();
	if (BlackboardComp == nullptr) return false;

	//获取黑板里面的攻击陷阱目标
	auto TrapTarget = BlackboardComp->GetValueAsObject(TEXT(\"TrapTarget\"));
	if (TrapTarget == nullptr) return true;
	return false; //有攻击目标就要执行攻击行为，不能再移动
}

```', 421, '2025-12-06 11:18:18.542000');
INSERT INTO documents (id, name, filename, content, directory_id, created_at) VALUES (685, '1.使用代码来配置材质.md', '1.使用代码来配置材质.md', '

## 定义属性

```c++
	// 预览材质 - 可放置（绿色）
	UPROPERTY(EditDefaultsOnly, Category = \"Trap Placement\")
	UMaterialInterface* ValidPlacementMaterial;

	// 预览材质 - 不可放置（红色）
	UPROPERTY(EditDefaultsOnly, Category = \"Trap Placement\")
	UMaterialInterface* InvalidPlacementMaterial;
```

## 构造函数中初始化

```c++

AMyBasePlayerController::AMyBasePlayerController()
{
	static ConstructorHelpers::FObjectFinder<UMaterialInstance> ValidMaterialFinder(
		TEXT(
			\"/Script/Engine.MaterialInstanceConstant''/Game/Material/Trap/M_TrapPreview_Valid_Inst.M_TrapPreview_Valid_Inst''\")
	);
	if (ValidMaterialFinder.Succeeded())
	{
		ValidPlacementMaterial = ValidMaterialFinder.Object;
		UE_LOG(LogTemp, Log, TEXT(\"✅ 成功加载有效放置材质\"));
	}
	else
	{
		UE_LOG(LogTemp, Warning, TEXT(\"❌ 加载有效放置材质失败\"));
	}

	static ConstructorHelpers::FObjectFinder<UMaterialInstance> InvalidMaterialFinder(
		TEXT(
			\"/Script/Engine.MaterialInstanceConstant''/Game/Material/Trap/M_TrapPreview_Invalid_Inst.M_TrapPreview_Invalid_Inst''\")
	);
	if (InvalidMaterialFinder.Succeeded())
	{
		InvalidPlacementMaterial = InvalidMaterialFinder.Object;
		UE_LOG(LogTemp, Log, TEXT(\"✅ 成功加载无效放置材质\"));
	}
	else
	{
		UE_LOG(LogTemp, Warning, TEXT(\"❌ 加载无效放置材质失败\"));
	}
}
```

## 下面是来自 AI的解释

没问题！这段代码是 Unreal Engine 中非常标准的**“生成预览物体（Ghost Actor）”**的流程。常用于建造系统，让玩家在点击放置之前，看到一个半透明的虚影。

下面我为你逐行添加了详细的注释，并在代码下方附带了核心知识点的深度解析。

### 详细注释版代码

```cpp
/**
 * 函数功能：创建用于预览的陷阱Actor（虚影）
 * 参数 TrapClass：想要预览的陷阱的类类型（蓝图类或C++类）
 */
void AMyBasePlayerController::CreatePreviewActor(TSubclassOf<AMyTrapBase> TrapClass)
{
    // ====================================================
    // 1. 清理阶段：防止同时存在多个预览物体
    // ====================================================
    
    // 检查当前是否已经存在一个预览Actor
    if (PreviewTrapActor)
    {
        // 如果存在，必须先销毁它，否则切换道具时旧的虚影会残留在原地
        PreviewTrapActor->Destroy();
        // 将指针置空，防止悬空指针（Dangling Pointer）导致崩溃
        PreviewTrapActor = nullptr;
    }

    // ====================================================
    // 2. 校验阶段
    // ====================================================

    // 如果传入的类是空的（例如玩家取消了手持物品），直接返回，不执行后续逻辑
    if (!TrapClass)
    {
        return;
    }

    // ====================================================
    // 3. 生成配置阶段
    // ====================================================

    // 定义生成参数结构体，用于控制 SpawnActor 的行为
    FActorSpawnParameters SpawnParams;
    
    // 核心设置：始终生成，忽略碰撞冲突。
    // 默认情况下，如果生成位置有东西挡住，UE可能会禁止生成。
    // 但作为预览虚影，我们需要它即使在墙里也能显示出来，所以设为 AlwaysSpawn。
    SpawnParams.SpawnCollisionHandlingOverride = ESpawnActorCollisionHandlingMethod::AlwaysSpawn;
    
    // 设置为 true 表示生成过程不应该失败（在某些边缘情况下保证稳定性）
    SpawnParams.bNoFail = true;

    // ====================================================
    // 4. 实例化阶段
    // ====================================================

    // 在世界中生成 Actor。
    // FVector::ZeroVector 和 FRotator::ZeroRotator 是临时位置/旋转。
    // 因为在 Tick 函数中，我们会根据射线检测每帧更新它的位置，所以这里初始值不重要。
    PreviewTrapActor = GetWorld()->SpawnActor<AMyTrapBase>(
        TrapClass,              // 要生成的类
        FVector::ZeroVector,    // 初始位置 (0,0,0)
        FRotator::ZeroRotator,  // 初始旋转 (0,0,0)
        SpawnParams             // 上面配置的参数
    );

    // ====================================================
    // 5. 初始化设置阶段（关键：把实体变成“虚影”）
    // ====================================================

    if (PreviewTrapActor)
    {
        // --- 逻辑层设置 ---

        // 禁用 Actor 层级的碰撞。
        // 预览物体绝不能阻挡玩家移动，也不能触发子弹打击或物理模拟。
        PreviewTrapActor->SetActorEnableCollision(false);

        // 禁用 Tick（每帧运行）。
        // 真正的陷阱可能有复杂的逻辑（如索敌），预览时不需要运行这些逻辑，节省性能。
        PreviewTrapActor->SetActorTickEnabled(false);

        // --- 视觉层设置 ---

        // 获取该 Actor 身上所有的静态网格体组件（即物体的模型部分）
        TArray<UStaticMeshComponent*> MeshComponents;
        PreviewTrapActor->GetComponents<UStaticMeshComponent>(MeshComponents);

        // 遍历每一个网格体组件进行设置
        for (UStaticMeshComponent* MeshComp : MeshComponents)
        {
            if (MeshComp)
            {
                // 彻底关闭组件的物理碰撞（双重保险，防止物理引擎计算它）
                MeshComp->SetCollisionEnabled(ECollisionEnabled::NoCollision);

                // 关闭阴影投射。
                // 预览虚影通常是发光的或者半透明的，投射阴影会显得很怪且浪费性能。
                MeshComp->SetCastShadow(false);

                // --- 材质透明度处理 ---
                
                // 遍历模型上的每一个材质槽（Material Slot）
                for (int32 i = 0; i < MeshComp->GetNumMaterials(); ++i)
                {
                    // 创建“动态材质实例” (MID - Material Instance Dynamic)。
                    // 只有创建了 MID，我们才能在游戏运行时修改材质参数（如颜色、透明度）。
                    if (UMaterialInstanceDynamic* DynMat = MeshComp->CreateDynamicMaterialInstance(i))
                    {
                        // 修改名为 \"Opacity\" 的标量参数，设为 0.5（半透明）。
                        // 【注意】：这要求你的材质（Material）中必须有一个名为 \"Opacity\" 的参数，
                        // 且材质的混合模式（Blend Mode）必须设为 Translucent（半透明），否则这行代码无效。
                        DynMat->SetScalarParameterValue(FName(\"Opacity\"), 0.5f);
                    }
                }
            }
        }

        // --- 状态管理 ---

        // 初始设为隐藏。
        // 这样做是为了防止 Actor 刚生成在 (0,0,0) 时闪烁一下。
        // 等到下一次 Tick 检测到射线击中点并设置好正确位置后，再将其设为显示。
        PreviewTrapActor->SetActorHiddenInGame(true);

        // 记录当前正在预览的类型，用于后续逻辑判断（比如判断玩家是否换了武器）
        CurrentPreviewTrapClass = TrapClass;

        // 打印日志，方便调试（仅在 Output Log 中显示）
        UE_LOG(LogTemp, Log, TEXT(\"创建陷阱预览Actor: %s\"), *TrapClass->GetName());
    }
}
```

---

### 💡 核心知识点总结（学习重点）

#### 1. `ESpawnActorCollisionHandlingMethod::AlwaysSpawn`
这是建造系统中最关键的设置之一。
*   **如果不加这行**：如果你对着墙角或者非常狭窄的地方尝试生成预览，UE 会检测到新生成的 Actor 会和墙壁重叠，于是拒绝生成，导致 `PreviewTrapActor` 为空。
*   **加上这行**：强制生成，哪怕它穿模了。对于“虚影”来说，穿模是完全可以接受的。

#### 2. `CreateDynamicMaterialInstance` (MID)
这是让物体变色、变透明的核心技术。
*   **静态材质**：游戏运行时不能改。
*   **动态材质实例 (MID)**：是静态材质的克隆体，可以在运行时随意修改参数。
*   **重要前提**：你的材质蓝图（Material Graph）里必须真的连入了一个叫 `\"Opacity\"` 的 Scalar Parameter 节点，并且材质本身支持半透明，这行代码 `SetScalarParameterValue` 才会生效。

#### 3. 性能优化：`SetActorTickEnabled(false)`
这是一个良好的编程习惯。
*   假设你的 `AMyTrapBase` 里有一个 `Tick` 函数用来检测敌人。
*   当你只是想预览放置位置时，不需要这些检测逻辑运行。
*   禁用 Tick 可以避免不必要的计算开销，特别是在低配机器上。

#### 4. `PreviewTrapActor->Destroy()` 的时机
在函数开头销毁旧 Actor 是为了实现**“单例预览”**。
*   如果不销毁：玩家每按一次切换武器，场景里就会多一个没人管的虚影，最后内存溢出。
*   正确的逻辑是：旧的不去，新的不来。

#### 5. `SetActorHiddenInGame(true)` 的作用
这是一种视觉上的“防抖动”处理。
*   Actor 生成是在 `(0,0,0)`（通常是地图中心地下）。
*   如果不先隐藏，玩家可能会在瞬间看到地图中心闪过一个物体，然后它才跳到玩家准星位置。
*   先隐藏，等位置计算好了（在另一个 Update 函数里）再显示，体验最丝滑。', 422, '2025-12-06 11:18:18.544000');
INSERT INTO documents (id, name, filename, content, directory_id, created_at) VALUES (686, '2.特效基础.md', '2.特效基础.md', '![img.png](https://minio.itbug.shop/blog/simple-file/img___1760077548500___.png)

scale sprite size : 精灵大小缩放
wind force: 风力
aerodynamic drag: 空气动力学阻力
particle state: 粒子状态

', 423, '2025-12-06 11:18:18.547000');
INSERT INTO documents (id, name, filename, content, directory_id, created_at) VALUES (687, '1.初始化特效.md', '1.初始化特效.md', '
# 1.创建属性

在 actor创建属性

```c++
	//例子系统模板
	UPROPERTY(VisibleAnywhere, BlueprintReadWrite, Category=\"Spawner\")
	UParticleSystem* SpawnEffectTemplate;

	//例子系统组件
	UPROPERTY(VisibleAnywhere, BlueprintReadWrite, Category=\"Spawner\")
	UParticleSystemComponent* SpawnEffectComponent;

```

# 2.初始化



```c++
	//例子特效
	SpawnEffectComponent = CreateDefaultSubobject<UParticleSystemComponent>(TEXT(\"SpawnEffect\"));
	SpawnEffectComponent->SetupAttachment(RootComponent);
	SpawnEffectComponent->SetRelativeLocation(FVector(0,0,100));
	SpawnEffectComponent->bAutoActivate = true; //自动激活特效
	if (SpawnEffectTemplate)
	{
		SpawnEffectComponent->SetTemplate(SpawnEffectTemplate);
	}
```

# AI的回答参考

在UE5中使用C++为Actor添加特效（如出怪口的圆圈）的步骤如下。以下是完整代码示例：

### 1. 在头文件中声明组件和粒子系统资源
```cpp
// MonsterSpawner.h
#pragma once

#include \"CoreMinimal.h\"
#include \"GameFramework/Actor.h\"
#include \"Particles/ParticleSystemComponent.h\"
#include \"MonsterSpawner.generated.h\"

UCLASS()
class YOURPROJECT_API AMonsterSpawner : public AActor
{
    GENERATED_BODY()

public:
    AMonsterSpawner();

protected:
    // 粒子系统模板（在编辑器中指定）
    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Spawner\")
    UParticleSystem* SpawnEffectTemplate;

    // 粒子系统组件
    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Spawner\")
    UParticleSystemComponent* SpawnEffectComponent;
};
```

### 2. 在CPP文件中初始化组件
```cpp
// MonsterSpawner.cpp
#include \"MonsterSpawner.h\"

AMonsterSpawner::AMonsterSpawner()
{
    // 创建根组件（用于定位）
    RootComponent = CreateDefaultSubobject<USceneComponent>(TEXT(\"Root\"));

    // 创建特效组件并附加到根组件
    SpawnEffectComponent = CreateDefaultSubobject<UParticleSystemComponent>(TEXT(\"SpawnEffect\"));
    SpawnEffectComponent->SetupAttachment(RootComponent);
    
    // 设置相对位置（例如：在根组件上方100单位处显示）
    SpawnEffectComponent->SetRelativeLocation(FVector(0, 0, 100));
    
    // 自动激活特效（若需手动控制可设为false，后续通过代码激活）
    SpawnEffectComponent->bAutoActivate = true;
    
    // 如果在编辑器中指定了粒子系统模板，应用到组件
    if (SpawnEffectTemplate)
    {
        SpawnEffectComponent->SetTemplate(SpawnEffectTemplate);
    }
}
```

### 3. 在编辑器中配置
1. **创建粒子系统资源**：
    - 在内容浏览器右键 → `FX` → `Particle System`，创建一个环形圆圈特效（可通过调整粒子发射器参数实现环形效果，例如使用`Cylinder`或`Ring`形状）。
    - 例如：设置发射器的`Initial Velocity`为0，`Lifetime`为无限，`Initial Size`为环形半径。

2. **绑定资源到Actor**：
    - 将`MonsterSpawner`拖入场景。
    - 在细节面板的`Spawner`分类下，将创建的粒子系统资源拖入`SpawnEffectTemplate`字段。

### 4. 调整位置（可选）
- 如果出怪口位置需要精确控制，可以：
    - 在`MonsterSpawner`中添加一个`SceneComponent`作为子组件（命名为`SpawnLocation`），并调整其位置。
    - 将`SpawnEffectComponent`附加到`SpawnLocation`而非根组件：
      ```cpp
      // 在构造函数中添加：
      USceneComponent* SpawnLocation = CreateDefaultSubobject<USceneComponent>(TEXT(\"SpawnLocation\"));
      SpawnLocation->SetupAttachment(RootComponent);
      SpawnLocation->SetRelativeLocation(FVector(0, 0, 50)); // 出怪口位置
      SpawnEffectComponent->SetupAttachment(SpawnLocation);
      ```

### 关键说明
- **粒子系统设计**：在编辑器中创建粒子系统时，使用`Sprite`材质+环形发射器参数（如`Initial Velocity`设为0，`Initial Size`为环形半径，`Shape`设为`Ring`）。
- **动态控制**：若需在生成怪物时才显示特效，将`bAutoActivate = false`，并在生成怪物时调用`SpawnEffectComponent->ActivateSystem()`。

> ⚠️ 注意：确保粒子系统资源路径正确（编辑器中直接拖拽即可），无需硬编码路径。如果需要动态加载资源，可使用`ConstructorHelpers::FObjectFinder`，但通常编辑器配置更灵活。', 423, '2025-12-06 11:18:18.547000');
INSERT INTO documents (id, name, filename, content, directory_id, created_at) VALUES (688, 'AddVelocity.md', 'AddVelocity.md', '
## AI解释

> 提问: 奶瓜特效, add velocity 这个是干啥的?


“奶瓜特效”是中文玩家对 **Niagara 特效系统**（Niagara → “奶瓜”）的戏称。你问的 **“Add Velocity”** 是 Niagara 中一个非常重要的模块，它的作用是：

---

### ✅ `Add Velocity`（添加速度）—— 控制粒子的运动方向和速率

> 它的作用是：**给粒子施加一个额外的速度向量（Vector），让它们朝某个方向移动**。

这就像你在游戏中发射火焰、烟雾、水流、爆炸碎片时，粒子不能静止不动，而要“飞出去”，这就是由 `Add Velocity` 或类似模块驱动的。

---

## 🧩 举个例子：火墙 vs 火焰喷射器

| 特效类型 | 是否需要 Add Velocity |
|--------|---------------------|
| 🔥 静态火墙（Fire Wall） | ❌ 不一定需要，粒子可能只是上下跳动 |
| 💥 火焰喷射器（Flamethrower） | ✅ 必须！粒子要向前喷射 |
| 🌪️ 爆炸冲击波 | ✅ 让碎片向外扩散 |
| 🌫️ 雾气飘散 | ✅ 让烟雾缓慢漂移 |

---

## 🔍 在 Niagara 中哪里能看到 `Add Velocity`？

在 **Niagara 编辑器**中，你可以看到很多与运动相关的模块，常见的有：

### 1. **Initial Velocity**（初始速度）
- 在粒子出生时赋予一个速度。
- 比如：喷射类特效常用。

```text
Module: Initial Velocity > Direction + Speed
→ 粒子一出生就以某个方向飞行
```

### 2. **Add Velocity**（持续添加速度）
- 每帧都给粒子加上一个速度增量（比如模拟风力、重力、推力）。
- 常用于：
    - 风吹动烟雾
    - 火焰向上飘
    - 地心引力拉下碎片

```text
每帧执行：Velocity += AddVelocityValue * DeltaTime
```

> ⚠️ 注意：这不是“设置速度”，而是“增加速度”——它是**累加的**！

---

## 🎮 实际应用场景举例

| 场景 | 如何使用 Add Velocity |
|------|------------------------|
| 🌬️ 风中的火焰 | 使用 `Add Velocity` 向右持续加力，模拟风吹效果 |
| 🌋 喷发的岩浆 | 初始速度向上 + 持续重力向下（负Z方向 Add Velocity） |
| 💨 推进器尾焰 | 每帧给粒子一个反向（后方）速度增量，形成推力感 |
| 🌀 龙卷风 | 使用“Add Radial Velocity”或“Add Angular Velocity”绕中心旋转 |

---

## 🛠️ C++ 中能控制吗？可以！

你可以在 C++ 中动态修改 Niagara 的 `Add Velocity` 参数，比如改变风力大小：

```cpp
// 假设你有一个 Niagara 组件
UNiagaraComponent* NC = nullptr;

// 比如这是火焰喷射器
NC = UNiagaraFunctionLibrary::SpawnSystemAttached(...);

// 动态设置一个叫 \"WindSpeed\" 的参数（你需要在 Niagara 中暴露这个变量）
NC->SetVariableVec3(TEXT(\"ExternalWind\"), FVector(1000.0f, 0.0f, 0.0f));
```

然后在 Niagara 系统中，用这个参数来控制 `Add Velocity` 的值：

```text
[Inside Niagara Graph]
Parameter Collection: ExternalWind → Connect to Add Velocity module
```

这样就能通过 C++ 实现“怪物进入区域后，火墙被风吹向它”这种动态效果！

---

## 📌 总结：`Add Velocity` 是干啥的？

| 项目 | 内容 |
|------|------|
| 🎯 作用 | 给粒子**持续施加速度变化**（加速） |
| 🔁 类型 | 是一个“每帧执行”的模块（不是一次性） |
| 🆚 对比 | 区别于 `Set Velocity`（直接设定速度） |
| 🧪 应用 | 风、重力、推力、水流、爆炸余波等物理模拟 |
| 🎮 游戏用途 | 让特效更生动、更具交互性（如风吹火势蔓延） |

---

💡 小贴士：  
如果你做的是“火墙陷阱”，虽然主体火焰不移动，但你仍然可以用 `Add Velocity (Z轴)` 让火焰向上飘动，看起来更真实！

需要我教你如何在 Niagara 中创建一个「受风力影响的火墙」并用 C++ 控制风向吗？🔥🌬️', 423, '2025-12-06 11:18:18.547000');
INSERT INTO documents (id, name, filename, content, directory_id, created_at) VALUES (689, 'curl_noise_force卷曲噪声.md', 'curl_noise_force卷曲噪声.md', '
在 Unreal Engine 5（UE5） 的 Niagara（奶瓜） 系统里，Curl Noise Force 是一个非常常用的 力场（Force）模块，它的作用是给粒子添加一种平滑但又复杂的湍流运动，让粒子的运动看起来更自然、更像流体或烟雾。

⸻

🌀 一、基本概念

Curl Noise（旋度噪声）来源于数学中的向量场旋度（Curl Field）。
相比普通的 Perlin Noise 或 Simplex Noise，Curl Noise 有一个很重要的特性：

不会产生粒子堆积或发散（divergence-free）。

也就是说，它生成的力场是“平滑地旋转”的，而不是“随机乱抖”的。
这使它特别适合用于模拟：
•	烟雾（smoke）
•	火焰（flame）
•	魔法能量流（magic energy flow）
•	漩涡状的流动效果（vortex / fluid）

⸻

⚙️ 二、在 Niagara 里的作用机制

当你在 Niagara 的 Force Update 阶段加入 Curl Noise Force 模块时：
1.	它会在每个粒子的位置计算一个基于噪声的方向向量；
2.	这个向量会作为一个**力（Force）**施加到粒子上；
3.	粒子速度随时间被不断扰动，形成流体般的旋转运动。

⸻

🧩 三、关键参数解释

参数	含义	提示
Strength	力的强度	控制扰动的力度，数值越大运动越剧烈
Frequency	噪声频率	控制旋涡的大小（频率越高，旋涡越密集）
Noise Scale / Spatial Scale	空间尺度	控制噪声在空间中的“纹理密度”
Add Velocity Directly	是否直接修改速度	如果开启，力直接叠加到粒子速度上；否则通过物理积分器影响运动
Use Curl Noise	是否使用旋度噪声	如果关闭则退化为普通噪声力场（效果更乱）


⸻

💡 四、实际应用技巧
•	想让粒子看起来像烟雾翻腾 → 小 Strength + 低频 Frequency
•	想让粒子像能量风暴 → 大 Strength + 高频 Frequency
•	想做一个持续流动的魔法雾气场 → 在世界空间里添加多个 Curl Noise Force 并叠加
•	为了防止“粒子卡住”或“抖动” → 让 Strength 随时间波动一点（例如乘上一个 Sine）

⸻

🎬 五、和电影灯光构图的类比（Chris Brejon 思路）

在视觉设计上，Curl Noise 的作用就像摄影中的“空气流动感”或“视觉动势”：
•	它为静态构图带来流动的节奏感；
•	避免画面死板；
•	通过类似 Gestalt 的“连续性原则” (Law of Continuity)，让观众的目光自然沿着粒子的路径移动。

⸻

要不要我帮你举一个 Niagara 实例（比如“如何用 Curl Noise Force 做出自然翻滚的烟雾粒子效果”）？
我可以一步步告诉你节点和参数怎么设。', 423, '2025-12-06 11:18:18.547000');
INSERT INTO documents (id, name, filename, content, directory_id, created_at) VALUES (690, '1.实现角色移动,查看,跳跃.md', '1.实现角色移动,查看,跳跃.md', '## 1.创建一个`AMyCharacter`c++类

它继承虚幻角色类,类名是`ACharacter`

## 2.重写父类`SetupPlayerInputComponent`函数绑定输入,添加动作监听

1.在角色类中定义2个属性,(输入映射UInputMappingContext)和(动作UInputAction)

```c++
class DEMO2_API AMyCharacter : public ACharacter{
    GENERATED_BODY()
public:
        //...
        UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = Input, meta = (AllowPrivateAccess = \"true\"))
	UInputMappingContext* MyDefaultMappingContext;//输入映射

	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = Input, meta = (AllowPrivateAccess = \"true\"))
	UInputAction* MyLookAction;//代表动作
};
```

这两个属性后面要在蓝图中的详情面板中配置.

2.获取玩家的输入子系统添加输入映射

在函数`SetupPlayerInputComponent`下编写
> 1.获取玩家控制器
```c++
APlayerController* PlayController = Cast<APlayerController>(GetController());
```
> 2.获取输入子系统
```c++
auto SubSystem = ULocalPlayer::GetSubsystem<UEnhancedInputLocalPlayerSubsystem>(PlayController->GetLocalPlayer());
```
> 3.添加输入映射
```c++
SubSystem -> AddMappingContext(MyDefaultMappingContext,0);//单人玩家:0
```

3.注册鼠标动态监听
> 1.获取输入组件
```c++
UEnhancedInputComponent* InputComponent = CastChecked<UEnhancedInputComponent>(PlayerInputComponent);
```
> 2.绑定动作
```c++
InputComponent->BindAction(MyLookAction,ETriggerEvent::Triggered,this,&AMyCharacter::SetCameraRotation);
```
> 3.实现鼠标转动函数
```c++
//设置鼠标的移动
void AMyCharacter::SetCameraRotation(const FInputActionValue& Value)
{
	const auto Vector = Value.Get<FVector2d>();//获取鼠标的2d向量
	if(Controller != nullptr)
	{
		AddControllerYawInput(Vector.X);//偏航值
		AddControllerPitchInput(Vector.Y);
	}
	
}
```

## 完整的代码
`AMyCharacter.h`
```c++
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include \"CoreMinimal.h\"
#include \"InputAction.h\"
#include \"InputMappingContext.h\"
#include \"Camera/CameraComponent.h\"
#include \"GameFramework/Character.h\"
#include \"GameFramework/SpringArmComponent.h\"
#include \"MyCharacter.generated.h\"

struct FInputActionValue;

UCLASS()
class DEMO2_API AMyCharacter : public ACharacter
{
	GENERATED_BODY()

public:
	// Sets default values for this character''s properties
	AMyCharacter();

protected:
	// Called when the game starts or when spawned
	virtual void BeginPlay() override;

	UPROPERTY(VisibleAnywhere)
	UCameraComponent* MyCameraComponent;

	UPROPERTY(VisibleAnywhere)
	USpringArmComponent* MySpringArmComponent;


	

public:	
	// Called every frame
	virtual void Tick(float DeltaTime) override;

	// 调用将功能绑定到输入
	virtual void SetupPlayerInputComponent(UInputComponent* PlayerInputComponent) override;


	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = Input, meta = (AllowPrivateAccess = \"true\"))
	UInputMappingContext* MyDefaultMappingContext;

	//左看右看,上看下看
	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = Input, meta = (AllowPrivateAccess = \"true\"))
	UInputAction* MyLookAction;
	//左右移动,上下移动
	UPROPERTY(EditAnywhere,BlueprintReadOnly, Category = Input, meta = (AllowPrivateAccess = \"true\"))
	UInputAction* MyMoveAction;
	// 设置鼠标的移动
	UFUNCTION(BlueprintCallable, Category=\"梁典典的函数\",DisplayName=\"控制鼠标旋转\")
	void SetCameraRotation(const FInputActionValue& Value);
	
	// 设置前进方向
	UFUNCTION(BlueprintCallable,Category=\"梁典典的函数\",DisplayName=\"控制任务移动\")
	void Move(const FInputActionValue& Value);

	//跳
	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = Input, meta = (AllowPrivateAccess = \"true\"))
	UInputAction* MyJumpAction;
};

```

`AMyCharacter.cpp`
```c++
// Fill out your copyright notice in the Description page of Project Settings.


#include \"MyCharacter.h\"

#include \"EnhancedInputComponent.h\"
#include \"EnhancedInputSubsystems.h\"
#include \"GameFramework/CharacterMovementComponent.h\"

// 设置默认值
AMyCharacter::AMyCharacter()
{
	// 设置此字符每帧调用 Tick()。  如果不需要，您可以将其关闭以提高性能。
	PrimaryActorTick.bCanEverTick = true;


	//创建摄像机杆子
	MySpringArmComponent = CreateDefaultSubobject<USpringArmComponent>(TEXT(\"LddSpringArmComponent\"));
	MySpringArmComponent->bUsePawnControlRotation = true;//跟随角色旋转
	MySpringArmComponent->SetupAttachment(RootComponent);


	//创建摄像机
	MyCameraComponent = CreateDefaultSubobject<UCameraComponent>(TEXT(\"LddCameraComponent\"));
	MyCameraComponent->SetupAttachment(MySpringArmComponent);//附加到杆子
	MyCameraComponent->SetRelativeLocation(FVector(0,0,50.f));
	MyCameraComponent->bUsePawnControlRotation = true;


	//让角色的朝向始终和当前的移动方向一致
	GetCharacterMovement()->bOrientRotationToMovement = true;

	//保证角色平滑的旋转
	bUseControllerRotationYaw = false;
	bUseControllerRotationPitch = false;
}

// 游戏开始或生成时调用
void AMyCharacter::BeginPlay()
{
	Super::BeginPlay();
}

// 调用每一帧
void AMyCharacter::Tick(float DeltaTime)
{
	Super::Tick(DeltaTime);
}

// 调用将功能绑定到输入
void AMyCharacter::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)
{
	Super::SetupPlayerInputComponent(PlayerInputComponent);


	//添加输入上下文映射
	if(APlayerController* PlayController = Cast<APlayerController>(GetController()))
	{
		if(auto SubSystem = ULocalPlayer::GetSubsystem<UEnhancedInputLocalPlayerSubsystem>(PlayController->GetLocalPlayer()))
		{
			SubSystem -> AddMappingContext(MyDefaultMappingContext,0);
		}
	}


	if (UEnhancedInputComponent* InputComponent = CastChecked<UEnhancedInputComponent>(PlayerInputComponent))
	{
		// Jumping
		InputComponent->BindAction(MyJumpAction, ETriggerEvent::Started, this, &ACharacter::Jump);
		InputComponent->BindAction(MyJumpAction, ETriggerEvent::Completed, this, &ACharacter::StopJumping);
		InputComponent->BindAction(MyLookAction,ETriggerEvent::Triggered,this,&AMyCharacter::SetCameraRotation);
		InputComponent->BindAction(MyMoveAction,ETriggerEvent::Triggered,this,&AMyCharacter::Move);
	}

	UE_LOG(LogTemp,Log,TEXT(\"AMyCharacter::SetupPlayerInputComponent\"));
}

//设置鼠标的移动
void AMyCharacter::SetCameraRotation(const FInputActionValue& Value)
{
	const auto Vector = Value.Get<FVector2d>();
	UE_LOG(LogTemp,Log,TEXT(\"AMyCharacter::SetCameraRotation:x:%.2f,y:%.2f\"),Vector.X,Vector.Y);
	if(Controller != nullptr)
	{
		AddControllerYawInput(Vector.X);
		AddControllerPitchInput(Vector.Y);
	}
}

//让角色移动
void AMyCharacter::Move(const FInputActionValue& Value)
{
	const auto Vector = Value.Get<FVector2d>();
	if(Controller != nullptr)
	{
		//获取方向
		const FRotator Rotation =  Controller->GetControlRotation();

		//获取左右的方向
		const FRotator YawNewRotator = FRotator(0,Rotation.Yaw,0);
		const FRotationMatrix Matrix = FRotationMatrix(YawNewRotator);
		//获取向前的向量
		const FVector X = Matrix.GetUnitAxis(EAxis::X);
		//获取左右的向量
		const FVector Y = Matrix.GetUnitAxis(EAxis::Y);
		UE_LOG(LogTemp,Log,TEXT(\"角色移动:输入X:%.2f,输入Y:%.2f,保持左右的旋转角度:%.2f(不关心上下角度)\"),Vector.X,Vector.Y,Rotation.Yaw);
		AddMovementInput(X,Vector.Y);
		AddMovementInput(Y,Vector.X);
	}
}

```

## chatgpt
>问题1:这些概念太难了,对我来说,很难很难

理解这些概念确实有点复杂，尤其是在你刚开始学习 Unreal Engine 的时候。不要担心，这是一个正常的过程，随着时间和练习，你会逐渐掌握它们。我们可以一起慢慢来，逐步简化这些概念，帮助你更好地理解。

我会试着用更简单的方式解释，看看是否能帮你更容易理解：

### 1. **输入向量（`FVector2d`）**
   你可以把输入向量想象成一个手柄或键盘输入的方向。假设你在用手柄操作：
   - `Vector.X` 代表左右方向，值越大代表往右移动，越小代表往左移动。
   - `Vector.Y` 代表前后方向，值越大代表往前移动，越小代表往后移动。

   所以这个 `Vector` 就是表示玩家的输入方向。

### 2. **控制器旋转**
   控制器的旋转简单来说，就是你角色朝向的方向。假设你在游戏里用鼠标或者右摇杆控制角色的视角旋转，这就是控制器的“旋转角度”。旋转分为：
   - **Yaw**：左右旋转（水平转头）。
   - **Pitch**：上下旋转（抬头或低头）。
   在这个例子里，我们只关心角色左右转头的方向（`Yaw`），所以忽略了上下抬头的部分。

### 3. **前进和左右的方向**
   - **前进方向**：假设角色现在面对一个方向，这就是“前进方向”。前进方向对应着 `X` 轴。
   - **左右方向**：想象一下，如果你站着不动，左右方向就是你的身体的两侧。这个方向对应着 `Y` 轴。

### 4. **移动逻辑**
   当你输入方向时：
   - `Vector.Y` 代表你是往前走还是往后退，程序就让你根据“前进方向”去移动。
   - `Vector.X` 代表你是往左移还是往右移，程序就让你根据“左右方向”去移动。

最终，这段代码就是让角色根据你输入的方向移动，无论你是用键盘、鼠标还是手柄。

---

你可以慢慢分步骤去理解这些代码，并用简单的例子去测试效果。每次理解一个小概念，尝试把它和实际操作联系起来，就会变得更容易。有什么具体的部分你想再深入理解的，或者需要更简单的解释，告诉我，我可以继续帮助你！

> 问题2FRotationMatrix这个是什么东西?

`FRotationMatrix` 是 Unreal Engine 中的一个类，用来表示旋转矩阵。旋转矩阵是数学中的一个工具，用来描述物体在三维空间中的旋转。虽然它在背后有复杂的数学原理，但我们可以用简单的方式来理解它在游戏开发中的用途。

### 简单解释

你可以把 `FRotationMatrix` 想象成一个工具，它可以根据给定的旋转角度（例如角色的朝向）生成一个**矩阵**，这个矩阵可以用来计算角色在这个旋转角度下的**前进方向**、**左右方向**等信息。

#### 具体怎么用？

在游戏中，角色不仅有位置，还会有方向（旋转角度）。当你让角色旋转后，你需要知道这个新的旋转角度下，角色的**前**是哪边，**左**又是哪边。

- **`FRotationMatrix(YawNewRotator).GetUnitAxis(EAxis::X)`**：获取角色朝向的前进方向（**前**）。
- **`FRotationMatrix(YawNewRotator).GetUnitAxis(EAxis::Y)`**：获取角色的左右方向（**左或右**）。

### 实例讲解

在你提供的代码中，`FRotationMatrix` 是根据角色当前的旋转角度创建的，然后用它来获取角色的“前进”和“左右”方向。这个过程相当于告诉程序：

- **前进方向**（`X` 轴）：角色现在面朝的方向。
- **左右方向**（`Y` 轴）：角色左右两边的方向。

### 为什么需要 `FRotationMatrix`？

举个例子，如果角色面朝北方（0度），那么：
- **前进方向**就是正北（+X）。
- **左右方向**就是正东（+Y）。

但是如果角色转向了东边（90度），那么：
- **前进方向**变成了正东（+X）。
- **左右方向**变成了正南（+Y）。

你无法仅用一个简单的数字（角度）去描述这些复杂的方向变化，这时就需要通过 `FRotationMatrix` 来帮助计算这些方向。

### 核心理解

- **`FRotationMatrix`** 是用来处理物体旋转方向的工具。
- 它会根据一个旋转角度，告诉你在这个角度下的“前进”和“左右”方向。

### 进一步解释

在数学中，**矩阵**是一种表示数据的方式，可以用来执行各种操作（比如旋转、缩放等）。在三维空间里，物体的旋转可以通过一个 `3x3` 的矩阵来表示。`FRotationMatrix` 背后的数学细节涉及矩阵的运算和线性代数，但你只需要知道它帮你计算了**方向**，你就可以利用这些方向来让角色移动。

---

不需要深入理解复杂的数学，你只需要知道它是用来帮助你根据角色的朝向，计算出前、后、左、右的方向。如果你有更多问题，或者想看看具体的例子，我可以进一步解释！

参考文档

[输入文档](https://dev.epicgames.com/documentation/zh-cn/unreal-engine/input-overview-in-unreal-engine?application_version=5.4)', 424, '2025-12-06 11:18:18.559000');
INSERT INTO documents (id, name, filename, content, directory_id, created_at) VALUES (691, '5.获取怪物头顶位置.md', '5.获取怪物头顶位置.md', '
### 比如在怪物头顶上面显示一个受击伤害数字


在怪物头顶上面显示一个受击伤害数字，可以使用 `GetCapsuleComponent()->GetScaledCapsuleHalfHeight()` 来获取怪物胶囊体的半高度，从而计算出头顶位置。

```c++
void AMyEnemyBase::ShowDamageUIWidget(const float DamageValue) const
{
	const auto Clazz = LoadClass<UUDamageTextWidget>(nullptr, 
		TEXT(\"/Script/UMGEditor.WidgetBlueprint''/Game/Widget/UBP_DamageTextWidget.UBP_DamageTextWidget_C''\"));
	auto Widget = CreateWidget<UUDamageTextWidget>(GetWorld(),Clazz);
	Widget->AddToViewport();
	Widget->InitializeDamageText(DamageValue);
	//在怪物的头顶位置显示
	const auto WorldLocation = GetActorLocation() + FVector(0, 0, GetCapsuleComponent()->GetScaledCapsuleHalfHeight() + 30.f);
	FVector2D ScreenPositon;
	UGameplayStatics::ProjectWorldToScreen(GetWorld()->GetFirstPlayerController(),  WorldLocation,ScreenPositon);
	Widget->SetPositionInViewport(ScreenPositon,false);
}

```

### ProjectWorldToScreen 函数说明

将三维世界坐标转换为二维屏幕坐标。


# GetScaledCapsuleHalfHeight 函数说明

获取胶囊体组件的缩放后半高度。

下面来自 AI的解释

在 Unreal Engine 5（UE5）中，`GetScaledCapsuleHalfHeight()` 是一个常用于角色（Character）类中的函数，它的作用是 **获取当前胶囊体碰撞组件（Capsule Component）在考虑缩放（Scaling）之后的“半高”（Half Height）**。

下面我们来详细解释这个函数的含义和用途：

---

### 🔹 函数名解析

- `Get`：获取
- `Scaled`：表示已经应用了 Actor 或组件的缩放（Scale）
- `Capsule`：指角色使用的胶囊体碰撞体（通常叫 CapsuleComponent）
- `HalfHeight`：胶囊体沿 Z 轴方向的一半高度（不是总高度）

所以：
> `GetScaledCapsuleHalfHeight()` = 获取经过缩放后的胶囊体的一半高度

---

### 🔹 胶囊体（Capsule Component）是什么？

在 UE 的 `ACharacter` 类中，默认使用一个 **Capsule Component** 作为碰撞体。它是一个竖直的胶囊形状（上下两个半球 + 中间圆柱），用来代表角色的碰撞体积。

- 它有两个关键属性：
    - `Capsule Radius`（半径）
    - `Capsule Half Height`（半高）——即从胶囊中心到顶部或底部的距离

例如：如果半高是 96，那么胶囊体总高度就是 192 单位。

---

### 🔹 为什么需要 “Scaled”？

当你对一个 Actor 进行缩放（比如设置 Actor 的 `Actor Scale = 2.0`），它的碰撞体也会被等比放大。

此时：
- 原始的 `Capsule Half Height` 可能还是 96，
- 但实际表现出来的“有效半高”变成了 `96 * 2 = 192`

👉 所以 `GetScaledCapsuleHalfHeight()` 返回的是 **考虑了缩放之后的实际半高值**。

而如果你直接访问 `GetCapsuleComponent()->GetUnscaledCapsuleHalfHeight()`，得到的是未缩放前的原始值。

---

### 🔹 使用示例（C++）

```cpp
float HalfHeight = GetMesh()->GetAnimInstance()->GetOwningActor()->GetActorScale().Z * 
                   GetCapsuleComponent()->GetUnscaledCapsuleHalfHeight();

// 更简单的方式：直接调用内置函数
float ScaledHalfHeight = GetCapsuleComponent()->GetScaledCapsuleHalfHeight();
```

或者在 Character 子类中：

```cpp
float CurrentHalfHeight = GetScaledCapsuleHalfHeight();
```

---

### 🔹 常见用途

1. **角色下蹲/站起动画时调整摄像机位置**
   ```cpp
   Camera->SetRelativeLocation(FVector(0, 0, GetScaledCapsuleHalfHeight() - 10));
   ```

2. **判断是否能在某空间通过**（比如低头、潜行）
3. **同步 UI 提示或物理行为**

---

### 🔹 注意事项

- 该函数只反映 **当前缩放下的视觉+碰撞尺寸**，不涉及物理模拟细节。
- 如果你在蓝图中操作角色缩放（如变大变小道具），一定要使用 `GetScaledCapsuleHalfHeight()` 来获取真实高度。
- 对于非均匀缩放（X/Y/Z 缩放不同），结果可能不准确，应尽量避免非均匀缩放角色。

---

### ✅ 总结

| 函数 | 含义 |
|------|------|
| `GetCapsuleComponent()->GetUnscaledCapsuleHalfHeight()` | 原始半高（不受缩放影响） |
| `GetScaledCapsuleHalfHeight()` | 实际显示/碰撞用的半高（受 Actor 缩放影响） |

> 📌 推荐使用 `GetScaledCapsuleHalfHeight()` 来获取角色当前真正的“一半高度”，尤其是在有缩放的情况下。

---
', 424, '2025-12-06 11:18:18.559000');
INSERT INTO documents (id, name, filename, content, directory_id, created_at) VALUES (692, '3.怎么打log.md', '3.怎么打log.md', '在虚幻引擎5（Unreal Engine 5）中，打印日志（logging）是调试和开发过程中非常重要的一部分。以下是一些常见的方法来打印日志：

### 使用UE_LOG宏
虚幻引擎提供了一组宏来简化日志打印。最常用的宏是`UE_LOG`。


```cpp
#include \"Engine/Engine.h\"
#include \"Logging/LogMacros.h\"

void MyFunction()
{
    UE_LOG(LogTemp, Log, TEXT(\"This is a log message.\"));
}
```

在这个例子中，`LogTemp`是一个临时的日志类别，`Log`是日志级别，`TEXT`宏用于创建一个宽字符字符串。

### 日志类别
你可以定义自己的日志类别，以便更好地组织和过滤日志消息。

```cpp
#include \"Engine/Engine.h\"
#include \"Logging/LogMacros.h\"

DECLARE_LOG_CATEGORY_EXTERN(MyLogCategory, Log, All);

void MyFunction()
{
    UE_LOG(MyLogCategory, Log, TEXT(\"This is a log message with a custom category.\"));
}
```

在`.cpp`文件中，你需要定义这个日志类别：

```cpp
DEFINE_LOG_CATEGORY(MyLogCategory);
```

### 日志级别
虚幻引擎提供了多个日志级别，你可以根据需要选择合适的级别：

- `Log`: 普通日志消息。
- `Warning`: 警告消息。
- `Error`: 错误消息。
- `Fatal`: 致命错误消息，会导致程序崩溃。

例如：

```cpp
UE_LOG(LogTemp, Warning, TEXT(\"This is a warning message.\"));
UE_LOG(LogTemp, Error, TEXT(\"This is an error message.\"));
UE_LOG(LogTemp, Fatal, TEXT(\"This is a fatal message.\"));
```

### 在蓝图中打印日志
在蓝图中，你可以使用`Print String`节点来打印日志消息。

1. 在蓝图编辑器中，右键点击并搜索`Print String`节点。
2. 将你想要打印的字符串连接到`Print String`节点的输入引脚。

### 查看日志
你可以在虚幻引擎的输出日志窗口中查看日志消息。默认情况下，输出日志窗口可以通过`Window` -> `Developer Tools` -> `Output Log`来打开。

通过这些方法，你可以在虚幻引擎5中有效地打印和管理日志消息。

', 424, '2025-12-06 11:18:18.559000');
INSERT INTO documents (id, name, filename, content, directory_id, created_at) VALUES (693, '6.反射改变多播参数输出中文.md', '6.反射改变多播参数输出中文.md', '


## 关键代码

构造函数中编辑

> 注意判断空指针 nullptr, 不然会报错

```c++
UTrapDetectionComponent::UTrapDetectionComponent()
{
	PrimaryComponentTick.bCanEverTick = true;


	auto ClassType = UTrapDetectionComponent::StaticClass();
	auto OnEnemyEnterFun = (FMulticastDelegateProperty*)ClassType->FindPropertyByName(\"OnEnemyEnter\");
	if (OnEnemyEnterFun)
	{
		auto Param = OnEnemyEnterFun->SignatureFunction->FindPropertyByName(\"Actor\");
		if (Param)
		{
			Param->NamePrivate = TEXT(\"怪物\");
		}
		auto Param2 = OnEnemyEnterFun->SignatureFunction->FindPropertyByName(\"bIsFirst\");
		if (Param2)
		{
			Param2->NamePrivate = TEXT(\"是否首次进入的目标\");
		}
	}
}
```

更加推荐的安全方式,使用`CastFieldChecked`,在编译期间检测断言错误

```c++
UTrapDetectionComponent::UTrapDetectionComponent()
{
	PrimaryComponentTick.bCanEverTick = true;


	const auto ClassType = StaticClass();;
	if (const auto OnEnemyEnterFun = CastFieldChecked<FMulticastDelegateProperty>(
		ClassType->FindPropertyByName(\"OnEnemyEnter\")))
	{
		if (const auto Param = OnEnemyEnterFun->SignatureFunction->FindPropertyByName(\"Actor\"))
		{
			Param->NamePrivate = TEXT(\"进入攻击范围内的怪物\");
		}
		if (const auto Param2 = OnEnemyEnterFun->SignatureFunction->FindPropertyByName(\"bIsFirst\"))
		{
			Param2->NamePrivate = TEXT(\"是否首次进入的怪物\");
		}
	}
	if (const auto OnEnemyExitFun = CastFieldChecked<FMulticastDelegateProperty>(
		ClassType->FindPropertyByName(\"OnEnemyExit\")))
	{
		if (const auto Param = OnEnemyExitFun->SignatureFunction->FindPropertyByName(\"Actor\"))
		{
			Param->NamePrivate = TEXT(\"离开攻击范围内的怪物\");
		}
	}
}
```


## 完整的示例



头文件

```c++
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include \"CoreMinimal.h\"
#include \"MyEnemyBase.h\"
#include \"Components/ActorComponent.h\"
#include \"TrapDetectionComponent.generated.h\"

/**
 * 陷阱检测逻辑
 */
UCLASS(ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))
class DEMO2_API UTrapDetectionComponent : public UActorComponent
{
	GENERATED_BODY()

public:
	UTrapDetectionComponent();

	//绑定碰撞
	UFUNCTION(BlueprintCallable, Category = \"Detection\")
	void BindToCollider(UShapeComponent* Collider);


	DECLARE_DYNAMIC_MULTICAST_DELEGATE_TwoParams(FOnEnemyEnter, AActor*, Actor, bool, bIsFirst);

	DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnEnemyExit, AActor*, Actor);

	UPROPERTY(BlueprintAssignable, Category=\"Trap|Event\", DisplayName=\"当怪物进入碰撞区域时\")
	FOnEnemyEnter OnEnemyEnter;

	UPROPERTY(BlueprintAssignable, Category=\"Trap|Event\", DisplayName=\"当怪物离开碰撞区域时\")
	FOnEnemyExit OnEnemyExit;


	UPROPERTY(Blueprintable, BlueprintReadOnly, Category = \"Detection\")
	TArray<AMyEnemyBase*> OverlapedEnemys;

protected:
	virtual void BeginPlay() override;

private:
	UFUNCTION()
	void OnEnemyDeath(AMyEnemyBase* MyEnemyBase);

	UFUNCTION()
	void HandleBeginOverlap(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor,
	                        UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep,
	                        const FHitResult& SweepResult);

	UFUNCTION()
	void HandleEndOverlap(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp,
	                      int32 OtherBodyIndex);

public:
	virtual void TickComponent(float DeltaTime, ELevelTick TickType,
	                           FActorComponentTickFunction* ThisTickFunction) override;
};

```

cpp文件


```c++
// Fill out your copyright notice in the Description page of Project Settings.


#include \"Components/Trap/TrapDetectionComponent.h\"

#include \"Components/ShapeComponent.h\"


UTrapDetectionComponent::UTrapDetectionComponent()
{
	PrimaryComponentTick.bCanEverTick = true;


	auto ClassType = UTrapDetectionComponent::StaticClass();
	auto OnEnemyEnterFun = (FMulticastDelegateProperty*)ClassType->FindPropertyByName(\"OnEnemyEnter\");
	if (OnEnemyEnterFun)
	{
		auto Param = OnEnemyEnterFun->SignatureFunction->FindPropertyByName(\"Actor\");
		if (Param)
		{
			Param->NamePrivate = TEXT(\"怪物\");
		}
		auto Param2 = OnEnemyEnterFun->SignatureFunction->FindPropertyByName(\"bIsFirst\");
		if (Param2)
		{
			Param2->NamePrivate = TEXT(\"是否首次进入的目标\");
		}
	}
}

void UTrapDetectionComponent::BindToCollider(UShapeComponent* Collider)
{
	if (!Collider)
	{
		UE_LOG(LogTemp, Warning, TEXT(\"UTrapDetectionComponent::BindToCollider collider is null!\"));
		return;
	}
	Collider->OnComponentBeginOverlap.AddDynamic(this, &UTrapDetectionComponent::HandleBeginOverlap);
	Collider->OnComponentEndOverlap.AddDynamic(this, &UTrapDetectionComponent::HandleEndOverlap);
}


void UTrapDetectionComponent::BeginPlay()
{
	Super::BeginPlay();
}

void UTrapDetectionComponent::OnEnemyDeath(AMyEnemyBase* MyEnemyBase)
{
	if (OverlapedEnemys.Contains(MyEnemyBase))
	{
		OverlapedEnemys.Remove(MyEnemyBase);
	}
}

void UTrapDetectionComponent::HandleBeginOverlap(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor,
                                                 UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep,
                                                 const FHitResult& SweepResult)
{
	if (OtherActor && OtherActor != GetOwner())
	{
		if (const auto Enemy = Cast<AMyEnemyBase>(OtherActor); Enemy != nullptr && !OverlapedEnemys.Contains(Enemy))
		{
			const bool bIsFirst = OverlapedEnemys.IsEmpty();
			OverlapedEnemys.Add(Enemy);
			OnEnemyEnter.Broadcast(Enemy, bIsFirst);

			//注册监听怪物死亡事件
			if (const bool bIsRegisterDeathEvent = Enemy->OnEnemyDeathEvent.IsAlreadyBound(
				this, &UTrapDetectionComponent::OnEnemyDeath); !bIsRegisterDeathEvent)
			{
				Enemy->OnEnemyDeathEvent.AddDynamic(this, &UTrapDetectionComponent::OnEnemyDeath);
			}
		}
	}
}

void UTrapDetectionComponent::HandleEndOverlap(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor,
                                               UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	if (OtherActor && OtherActor != GetOwner())
	{
		if (const auto Enemy = Cast<AMyEnemyBase>(OtherActor); OverlapedEnemys.Contains(Enemy))
		{
			OverlapedEnemys.Remove(Enemy);
			OnEnemyExit.Broadcast(Enemy);

			//移除死亡事件监听
			Enemy->OnEnemyDeathEvent.RemoveDynamic(this,&UTrapDetectionComponent::OnEnemyDeath);
		}
	}
}


void UTrapDetectionComponent::TickComponent(float DeltaTime, ELevelTick TickType,
                                            FActorComponentTickFunction* ThisTickFunction)
{
	Super::TickComponent(DeltaTime, TickType, ThisTickFunction);
}

```



## 效果

![img.png](https://minio.itbug.shop/blog/simple-file/img___1761526496470___.png)', 424, '2025-12-06 11:18:18.559000');
INSERT INTO documents (id, name, filename, content, directory_id, created_at) VALUES (694, '4.怎么定义枚举.md', '4.怎么定义枚举.md', '

## 参考这个

```c++
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include \"CoreMinimal.h\"

/**
 * 陷阱底座的位置, 
 */
UENUM(BlueprintType)
enum class ETowerPosition : uint8
{
	/**
	 * 地面
	 */
	Ground = 0 UMETA(DisplayName = \"地面\"),

	/**
	 * 墙面
	 */
	Wall = 1 UMETA(DisplayName=\"墙上\"),

	/**
	 * 天花板
	 */
	Ceiling = 2 UMETA(DisplayName=\"天花板\"),

	/**
	 * 斜坡
	 */
	Slope = 3 UMETA(DisplayName=\"斜坡\")
};
```', 424, '2025-12-06 11:18:18.559000');
INSERT INTO documents (id, name, filename, content, directory_id, created_at) VALUES (695, '2.创建自定义动画蓝图.md', '2.创建自定义动画蓝图.md', '## 创建c++类,继承`UAnimInstance`

* 添加一些角色状态的属性,比如是否在行走,是否在跳跃等等

```c++
	//是否在移动中
	UPROPERTY(EditAnywhere, BlueprintReadWrite,Category=\"梁典典的属性\",meta=(AllowPrivateAccess=true),DisplayName=\"是否在行走\")
	bool bIsMoving;

	//是否在跳跃中
	UPROPERTY(EditAnywhere,BlueprintReadWrite,Category=\"梁典典的属性\",meta=(AllowPrivateAccess=true),DisplayName=\"是否在跳跃中\")
	bool bIsJumping;
	
	//每一帧都调用这个函数,重写一个虚函数
	UFUNCTION(BlueprintCallable,meta=(AllowPrivateAccess=true),DisplayName=\"每一帧回调函数\")
	virtual void NativeUpdateAnimation(float DeltaTime) override;
```

* 给任务设置为创建的动画蓝图类

## 少了一些模型,需要找素材


', 424, '2025-12-06 11:18:18.559000');
INSERT INTO documents (id, name, filename, content, directory_id, created_at) VALUES (704, 'kiro-powers.md', 'kiro-powers.md', '# 我创建的powers

优雅的前端设计: [power-frontend-design](https://github.com/mdddj/powers/tree/main/power-frontend-design) 



# 1.如何创建powers

这份文档是关于 **如何创建 Kiro Powers** 的开发者指南。Kiro Powers 是 Kiro 的扩展包，用于将第三方工具（如 Supabase, Stripe 等）、工作流和最佳实践集成到 Kiro 中。

以下是文档的核心要点总结：

### 1. 什么是 Power？
*   **定义**：Power 将工具、上下文和工作流封装成 Kiro 可以按需激活的格式。
*   **触发机制**：通过在 `POWER.md` 中定义 **Keywords（关键词）**。当用户在对话中提到相关关键词（如 \"database\"）时，Kiro 会自动加载该 Power 的工具和文档。

### 2. 核心文件结构
一个标准的 Power 目录包含以下内容：
*   **`POWER.md`** (必须)：核心配置文件。
*   **`mcp.json`** (可选)：用于配置 MCP (Model Context Protocol) 服务器，集成外部工具。
*   **`steering/`** (可选)：存放具体工作流指导文件的文件夹。

### 3. POWER.md 详解
该文件由两部分组成：
*   **Frontmatter (元数据)**：
    *   定义 `name`、`description` 和 **`keywords`**（决定何时激活）。
*   **Instructions (指令)**：
    *   **Onboarding (入门)**：首次激活时运行。用于验证环境（如检查 Docker 是否安装）、安装 CLI 或创建自动化 Hooks。
    *   **Steering (指导)**：定义 AI 如何使用该工具的最佳实践。

### 4. Steering（指导）的两种模式
为了管理上下文窗口，文档提出了两种编写指导的策略：
*   **简单模式**：所有最佳实践直接写在 `POWER.md` 中。适用于简单工具。
*   **高级模式（推荐用于复杂工具）**：
    *   在 `POWER.md` 中定义映射关系（例如：做“设置数据库”任务时加载 `database-setup.md`）。
    *   在 `steering/` 文件夹中创建多个独立的 Markdown 文件。
    *   **优势**：避免一次性加载过多上下文，AI 仅加载当前任务所需的信息。

### 5. 集成 MCP 工具 (`mcp.json`)
*   用于配置工具服务器（如 Supabase Local）。
*   支持设置环境变量（如 API Key）。
*   Kiro 会自动处理命名空间以避免冲突。

### 6. 开发与发布流程
1.  **创建**：按照结构建立文件夹和文件。
2.  **测试**：在 Kiro 面板中选择 \"Add power from Local Path\" 进行本地测试。
3.  **分享**：将代码推送到 **GitHub 公开仓库**。其他用户可以通过仓库 URL 安装。

### 总结示例结构
一个功能完整的 Power 看起来是这样的：
```text
power-supabase/
├── POWER.md               # 元数据、关键词、Onboarding 脚本、工作流映射
├── mcp.json               # MCP 工具配置
└── steering/              # 具体任务指南
    ├── database-setup.md
    └── auth-patterns.md
```

# 2.简单模式

根据文档描述，**简单模式 (Simple approach)** 的核心特点是：**不需要创建 `steering/` 文件夹**，所有的指导原则（Best Practices）直接写在 `POWER.md` 文件中。

这种模式适合逻辑简单、不需要根据不同任务切换上下文的工具。

以下是简单模式的具体格式结构：

### 1. 文件目录结构
非常干净，通常只有一个核心文件（如果有工具集成，再加一个 mcp.json）：

```text
power-your-tool/
├── POWER.md          # 核心文件：包含元数据、安装步骤、以及所有的使用指导
└── mcp.json          # (可选) 如果需要集成 MCP 工具则添加
```

---

### 2. POWER.md 的内容格式
在简单模式下，`POWER.md` 从上到下依次包含三个部分：

1.  **Frontmatter (元数据)**：定义触发关键词。
2.  **Onboarding (入门)**：初次安装时的检查。
3.  **Guidance/Steering (指导)**：**直接接在后面写**，告诉 AI 如何使用这个工具。

#### 📄 POWER.md 模板示例

```markdown

---
name: \"simple-tool\"
displayName: \"My Simple Tool\"
description: \"A tool for doing basic things\"
keywords: [\"keyword1\", \"keyword2\"]
---

# Onboarding
<!-- 第一部分：安装和检查（用户初次使用时运行） -->

## Step 1: Check Installation
- Verify CLI is installed: `my-tool --version`

## Step 2: Add Hooks
...

<!-- 分隔线：以下是简单模式特有的部分 -->
<!-- 不引用外部文件，直接在这里写最佳实践 -->

# Best Practices
<!-- 第二部分：指导 AI 如何工作（Steering） -->

## Code Style
- Always use camelCase for variables.
- Keep functions under 20 lines.

## How to use the API
When the user asks to fetch data, use this pattern:
`
const data = await client.fetch(''endpoint'');
`

## Common Workflows
- If user wants to reset, run: `my-tool reset`
- If user wants to deploy, check config first.

```


### 总结
简单模式就是：**把“元数据”、“安装检查”和“使用说明书”全部塞进一个 `POWER.md` 文件里。**

**适用场景**：
* 工具比较简单，规则不多。
* 是一个纯文档类型的 Power（比如“React 组件写规范”）。
* 不需要根据用户是在“写代码”还是在“部署”来切换不同的指令集。


# 3.示例

**可以的，完全可以实现。**

你可以创建一个 **简单模式 (Simple approach)** 的 Power，利用 `keywords` 监听你的中文关键词，然后在 `POWER.md` 的指导部分（Best Practices）强制要求 AI 使用你指定的技术栈。

下面是一个具体的实现示例。

### 实现步骤

你需要创建一个文件夹（例如 `power-my-frontend-stack`），并在其中创建一个 `POWER.md` 文件。

#### `POWER.md` 文件内容示例

假设你想强制规定：只要提到前端，就必须用 **React + TypeScript + Tailwind CSS**。

```markdown
---
name: \"frontend-standard\"
displayName: \"前端技术栈规范\"
description: \"当前后端分离或开发前端时，强制使用标准技术栈\"
# 1. 在这里定义触发关键词，支持中文
keywords: [\"前端\", \"前后端分离\", \"frontend\", \"页面开发\", \"ui\"]
---

# Onboarding
<!-- 如果不需要安装工具，这里可以留空或写个简单的说明 -->
此 Power 用于规范前端技术选型，无须安装额外工具。

# Best Practices

## 🚨 核心技术栈强制要求 (Tech Stack Enforcement)

**当用户提到“前端”或“前后端分离”时，你必须严格遵守以下技术选型，不要推荐其他方案：**

1.  **核心框架**: 必须使用 **Next.js (App Router)** + **React**。
2.  **编程语言**: 必须使用 **TypeScript**，严禁使用纯 JavaScript。
3.  **样式方案**: 必须使用 **Tailwind CSS**。不要使用 CSS Modules 或 Styled Components。
4.  **状态管理**: 优先使用 **Zustand**，只有在极端复杂场景下才考虑 Redux。
5.  **数据请求**: 使用 **TanStack Query (React Query)**。

## 代码风格
- 组件必须是函数式组件 (Functional Components)。
- 所有的 Props 必须定义 Interface。
```

### 原理解析

1.  **监听 (Keywords)**:
    当你在对话框里输入：“我想做一个**前后端分离**的系统”或者“帮我写个**前端**页面”时，Kiro 会检测到 `keywords` 列表里的词汇。

2.  **激活 (Activation)**:
    Kiro 自动激活 `frontend-standard` 这个 Power。

3.  **指导 (Steering)**:
    AI 会读取 `# Best Practices` 下的内容。因为它被指示“必须严格遵守”，所以当它生成代码或回答建议时，就会直接基于 React/TS/Tailwind 来回答，而不会去问你“想用 Vue 还是 React？”。

### 进阶技巧

如果你有多个不同的栈（比如有时候写 Vue，有时候写 React），你可以：

1.  **创建两个 Power**：
    *   一个关键词设为 `[\"前端\", \"React项目\"]` -> 指定 React 栈。
    *   一个关键词设为 `[\"Vue项目\"]` -> 指定 Vue 栈。
    *   *注意：如果关键词重叠（都叫“前端”），AI 可能会同时加载两个上下文，导致混淆，所以建议关键词做区分。*

2.  **在一个 Power 里写条件逻辑**：
    你也可以在一个文件里写：
    > 如果用户明确提到 \"后台管理系统\"，推荐使用 **Ant Design Pro**。
    > 如果用户提到 \"C端落地页\"，推荐使用 **Next.js + Tailwind**。

这种“纯文档类”的 Power 非常适合用来做团队的**开发规范守门员**。


', 433, '2025-12-13 14:02:01.693000');

SET session_replication_role = 'origin';

-- Update sequences
SELECT setval('categories_id_seq', (SELECT COALESCE(MAX(id), 1) FROM categories));
SELECT setval('tags_id_seq', (SELECT COALESCE(MAX(id), 1) FROM tags));
SELECT setval('blogs_id_seq', (SELECT COALESCE(MAX(id), 1) FROM blogs));
SELECT setval('directories_id_seq', (SELECT COALESCE(MAX(id), 1) FROM directories));
SELECT setval('projects_id_seq', (SELECT COALESCE(MAX(id), 1) FROM projects));
SELECT setval('friend_links_id_seq', (SELECT COALESCE(MAX(id), 1) FROM friend_links));
SELECT setval('texts_id_seq', (SELECT COALESCE(MAX(id), 1) FROM texts));
SELECT setval('documents_id_seq', (SELECT COALESCE(MAX(id), 1) FROM documents));